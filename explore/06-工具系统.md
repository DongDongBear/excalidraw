# Excalidraw 工具系统详解

## 目录
- [概述](#概述)  
- [工具架构](#工具架构)
- [内置工具详解](#内置工具详解)
- [工具状态管理](#工具状态管理)
- [工具扩展机制](#工具扩展机制)
- [工具栏系统](#工具栏系统)
- [自定义工具开发](#自定义工具开发)
- [工具交互模式](#工具交互模式)
- [实战示例](#实战示例)

## 概述

Excalidraw 的工具系统是应用的核心交互机制，负责处理不同绘图模式下的用户操作。系统采用策略模式设计，每个工具都是一个独立的处理器，具有明确的生命周期和状态管理。

### 核心特性
- **模块化设计**：每个工具独立封装，易于扩展和维护
- **状态驱动**：基于状态机模式的工具切换和管理
- **交互统一**：标准化的事件处理和生命周期接口
- **可扩展性**：支持自定义工具开发和集成
- **性能优化**：工具状态缓存和惰性加载

## 工具架构

### 1. 工具类型定义

```typescript
// 工具类型枚举
export type ToolType =
  | "selection"      // 选择工具
  | "lasso"         // 套索选择工具  
  | "rectangle"     // 矩形工具
  | "diamond"       // 菱形工具
  | "ellipse"       // 椭圆工具
  | "arrow"         // 箭头工具
  | "line"          // 直线工具
  | "freedraw"      // 自由绘制工具
  | "text"          // 文本工具
  | "image"         // 图片工具
  | "eraser"        // 橡皮擦工具
  | "hand"          // 拖拽工具
  | "frame"         // 框架工具
  | "magicframe"    // 智能框架工具
  | "embeddable"    // 嵌入式工具
  | "laser";        // 激光笔工具

// 活动工具状态
export type ActiveTool =
  | {
      type: ToolType;
      customType: null;
    }
  | {
      type: "custom";
      customType: string;
    };

// 工具配置接口
interface ToolConfig {
  type: ToolType;
  name: string;
  icon: React.ReactNode;
  shortcut: string;
  cursor: string;
  locked?: boolean;
  hidden?: boolean;
  group?: string;
}
```

### 2. 工具基类设计

```typescript
// 工具基类接口
abstract class BaseTool {
  public readonly type: ToolType;
  public readonly config: ToolConfig;
  
  constructor(type: ToolType, config: ToolConfig) {
    this.type = type;
    this.config = config;
  }
  
  // 工具激活时调用
  abstract onActivate(appState: AppState): Partial<AppState>;
  
  // 工具停用时调用
  abstract onDeactivate(appState: AppState): Partial<AppState>;
  
  // 处理指针按下事件
  abstract onPointerDown(
    event: PointerDownState,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ): {
    elements: readonly ExcalidrawElement[];
    appState: Partial<AppState>;
  } | null;
  
  // 处理指针移动事件
  abstract onPointerMove(
    event: PointerMoveState,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ): {
    elements: readonly ExcalidrawElement[];
    appState: Partial<AppState>;
  } | null;
  
  // 处理指针抬起事件
  abstract onPointerUp(
    event: PointerUpState,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ): {
    elements: readonly ExcalidrawElement[];
    appState: Partial<AppState>;
  } | null;
  
  // 处理键盘事件
  onKeyDown?(
    event: KeyboardEvent,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ): {
    elements: readonly ExcalidrawElement[];
    appState: Partial<AppState>;
  } | null;
  
  // 处理键盘抬起事件
  onKeyUp?(
    event: KeyboardEvent,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ): {
    elements: readonly ExcalidrawElement[];
    appState: Partial<AppState>;
  } | null;
  
  // 获取工具光标
  getCursor(appState: AppState): string;
  
  // 判断工具是否可用
  isEnabled(appState: AppState, elements: readonly ExcalidrawElement[]): boolean;
  
  // 工具提示信息
  getTooltip(appState: AppState): string;
  
  // 工具快捷键
  getShortcuts(): string[];
}

// 工具管理器接口
interface ToolManager {
  // 注册工具
  registerTool(tool: BaseTool): void;
  
  // 获取工具
  getTool(type: ToolType): BaseTool | null;
  
  // 激活工具
  setActiveTool(type: ToolType, customType?: string): void;
  
  // 获取当前活动工具
  getActiveTool(): BaseTool | null;
  
  // 获取所有工具
  getAllTools(): BaseTool[];
  
  // 获取工具组
  getToolGroup(group: string): BaseTool[];
}
```

### 3. 工具管理器实现

```typescript
class ExcalidrawToolManager implements ToolManager {
  private tools = new Map<ToolType, BaseTool>();
  private activeTool: ActiveTool = { type: 'selection', customType: null };
  private appStateRef: React.MutableRefObject<AppState>;
  
  constructor(appStateRef: React.MutableRefObject<AppState>) {
    this.appStateRef = appStateRef;
    this.initializeBuiltinTools();
  }
  
  private initializeBuiltinTools(): void {
    // 注册内置工具
    this.registerTool(new SelectionTool());
    this.registerTool(new RectangleTool());
    this.registerTool(new EllipseTool());
    this.registerTool(new ArrowTool());
    this.registerTool(new LineTool());
    this.registerTool(new FreeDrawTool());
    this.registerTool(new TextTool());
    this.registerTool(new EraserTool());
    this.registerTool(new HandTool());
    this.registerTool(new ImageTool());
    // ... 其他工具
  }
  
  registerTool(tool: BaseTool): void {
    this.tools.set(tool.type, tool);
  }
  
  getTool(type: ToolType): BaseTool | null {
    return this.tools.get(type) || null;
  }
  
  setActiveTool(type: ToolType, customType?: string): void {
    const currentTool = this.getActiveTool();
    
    // 停用当前工具
    if (currentTool) {
      const newState = currentTool.onDeactivate(this.appStateRef.current);
      this.updateAppState(newState);
    }
    
    // 更新活动工具
    this.activeTool = customType 
      ? { type: 'custom', customType }
      : { type, customType: null };
    
    // 激活新工具
    const newTool = this.getActiveTool();
    if (newTool) {
      const newState = newTool.onActivate(this.appStateRef.current);
      this.updateAppState({ 
        ...newState, 
        activeTool: this.activeTool 
      });
    }
  }
  
  getActiveTool(): BaseTool | null {
    if (this.activeTool.type === 'custom') {
      // 处理自定义工具
      return this.getCustomTool(this.activeTool.customType);
    }
    return this.getTool(this.activeTool.type);
  }
  
  // 处理指针事件
  handlePointerDown(
    event: PointerDownState,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ): { elements: readonly ExcalidrawElement[]; appState: Partial<AppState> } | null {
    const tool = this.getActiveTool();
    return tool?.onPointerDown(event, appState, elements) || null;
  }
  
  handlePointerMove(
    event: PointerMoveState,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ): { elements: readonly ExcalidrawElement[]; appState: Partial<AppState> } | null {
    const tool = this.getActiveTool();
    return tool?.onPointerMove(event, appState, elements) || null;
  }
  
  handlePointerUp(
    event: PointerUpState,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ): { elements: readonly ExcalidrawElement[]; appState: Partial<AppState> } | null {
    const tool = this.getActiveTool();
    return tool?.onPointerUp(event, appState, elements) || null;
  }
  
  // 获取工具光标
  getCursor(appState: AppState): string {
    const tool = this.getActiveTool();
    return tool?.getCursor(appState) || 'default';
  }
  
  private updateAppState(updates: Partial<AppState>): void {
    Object.assign(this.appStateRef.current, updates);
  }
  
  private getCustomTool(customType: string): BaseTool | null {
    // 实现自定义工具获取逻辑
    return null;
  }
}
```

## 内置工具详解

### 1. 选择工具 (Selection Tool)

```typescript
class SelectionTool extends BaseTool {
  constructor() {
    super('selection', {
      type: 'selection',
      name: 'Selection',
      icon: <SelectionIcon />,
      shortcut: 'V',
      cursor: 'default'
    });
  }
  
  onActivate(appState: AppState): Partial<AppState> {
    return {
      activeToolNonLinearElement: null,
      activeToolLinearElement: null,
      multiElement: null,
      isResizing: false,
      isRotating: false,
    };
  }
  
  onDeactivate(appState: AppState): Partial<AppState> {
    return {};
  }
  
  onPointerDown(
    event: PointerDownState,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    const { origin, withShift, withCmdOrCtrl } = event;
    
    // 获取点击位置的元素
    const hitElement = getElementAtPosition(elements, origin.x, origin.y, appState.zoom);
    
    if (hitElement) {
      // 处理元素选择
      return this.handleElementSelection(hitElement, withShift, withCmdOrCtrl, appState, elements);
    } else {
      // 开始框选
      return this.startLassoSelection(origin, appState, elements);
    }
  }
  
  onPointerMove(
    event: PointerMoveState,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    const { pointer, origin } = event;
    
    if (appState.draggingElement) {
      // 拖拽元素
      return this.handleElementDrag(pointer, origin, appState, elements);
    } else if (appState.isResizing) {
      // 调整大小
      return this.handleElementResize(pointer, appState, elements);
    } else if (appState.isRotating) {
      // 旋转元素
      return this.handleElementRotation(pointer, appState, elements);
    } else if (appState.selectionElement) {
      // 更新选择框
      return this.updateLassoSelection(pointer, origin, appState, elements);
    }
    
    return null;
  }
  
  onPointerUp(
    event: PointerUpState,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    if (appState.selectionElement) {
      // 完成框选
      return this.completeLassoSelection(appState, elements);
    } else if (appState.draggingElement || appState.isResizing || appState.isRotating) {
      // 完成拖拽/调整大小/旋转
      return this.completeElementTransform(appState, elements);
    }
    
    return null;
  }
  
  private handleElementSelection(
    element: NonDeletedExcalidrawElement,
    withShift: boolean,
    withCmdOrCtrl: boolean,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    let selectedElementIds = { ...appState.selectedElementIds };
    
    if (withShift) {
      // Shift+点击：切换选择状态
      if (selectedElementIds[element.id]) {
        delete selectedElementIds[element.id];
      } else {
        selectedElementIds[element.id] = true;
      }
    } else if (withCmdOrCtrl) {
      // Ctrl/Cmd+点击：添加到选择
      selectedElementIds[element.id] = true;
    } else {
      // 普通点击：单选
      selectedElementIds = { [element.id]: true };
    }
    
    return {
      elements,
      appState: {
        selectedElementIds,
        draggingElement: element,
      }
    };
  }
  
  private startLassoSelection(
    origin: Point,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    const selectionElement = newElement({
      type: 'selection',
      x: origin.x,
      y: origin.y,
      width: 0,
      height: 0,
    }) as ExcalidrawSelectionElement;
    
    return {
      elements: [...elements, selectionElement],
      appState: {
        selectionElement,
        draggingElement: null,
        selectedElementIds: {},
      }
    };
  }
  
  private updateLassoSelection(
    pointer: Point,
    origin: Point,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    if (!appState.selectionElement) return null;
    
    const width = pointer.x - origin.x;
    const height = pointer.y - origin.y;
    
    const updatedSelection = newElementWith(appState.selectionElement, {
      width,
      height,
    });
    
    // 更新选中的元素
    const selectedElementIds = this.getElementsInSelection(
      updatedSelection,
      elements
    );
    
    return {
      elements: [...elements.slice(0, -1), updatedSelection],
      appState: {
        selectionElement: updatedSelection,
        selectedElementIds,
      }
    };
  }
  
  private completeLassoSelection(
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    return {
      elements: elements.filter(el => el !== appState.selectionElement),
      appState: {
        selectionElement: null,
      }
    };
  }
  
  getCursor(appState: AppState): string {
    if (appState.isResizing) return this.getResizeCursor(appState);
    if (appState.isRotating) return 'grab';
    if (appState.draggingElement) return 'grabbing';
    return 'default';
  }
  
  private getResizeCursor(appState: AppState): string {
    const handle = appState.resizingElement?.handle;
    if (!handle) return 'default';
    
    const cursorMap: Record<string, string> = {
      'nw': 'nw-resize',
      'ne': 'ne-resize', 
      'sw': 'sw-resize',
      'se': 'se-resize',
      'n': 'n-resize',
      's': 's-resize',
      'w': 'w-resize',
      'e': 'e-resize',
    };
    
    return cursorMap[handle] || 'default';
  }
}
```

### 2. 矩形工具 (Rectangle Tool)

```typescript
class RectangleTool extends BaseTool {
  constructor() {
    super('rectangle', {
      type: 'rectangle',
      name: 'Rectangle',
      icon: <RectangleIcon />,
      shortcut: 'R',
      cursor: 'crosshair'
    });
  }
  
  onActivate(appState: AppState): Partial<AppState> {
    return {
      activeToolNonLinearElement: null,
      activeToolLinearElement: null,
      selectedElementIds: {},
    };
  }
  
  onDeactivate(appState: AppState): Partial<AppState> {
    return {
      activeToolNonLinearElement: null,
    };
  }
  
  onPointerDown(
    event: PointerDownState,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    const { origin, withShift } = event;
    
    // 创建新的矩形元素
    const element = newElement({
      type: 'rectangle',
      x: origin.x,
      y: origin.y,
      width: 0,
      height: 0,
      strokeColor: appState.currentItemStrokeColor,
      backgroundColor: appState.currentItemBackgroundColor,
      fillStyle: appState.currentItemFillStyle,
      strokeWidth: appState.currentItemStrokeWidth,
      strokeStyle: appState.currentItemStrokeStyle,
      roughness: appState.currentItemRoughness,
      opacity: appState.currentItemOpacity,
    });
    
    return {
      elements: [...elements, element],
      appState: {
        activeToolNonLinearElement: element,
        selectedElementIds: { [element.id]: true },
      }
    };
  }
  
  onPointerMove(
    event: PointerMoveState,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    if (!appState.activeToolNonLinearElement) return null;
    
    const { pointer, origin, withShift } = event;
    const element = appState.activeToolNonLinearElement;
    
    let width = pointer.x - origin.x;
    let height = pointer.y - origin.y;
    
    // Shift键保持正方形比例
    if (withShift) {
      const size = Math.max(Math.abs(width), Math.abs(height));
      width = width > 0 ? size : -size;
      height = height > 0 ? size : -size;
    }
    
    const updatedElement = newElementWith(element, {
      width,
      height,
    });
    
    return {
      elements: [...elements.slice(0, -1), updatedElement],
      appState: {
        activeToolNonLinearElement: updatedElement,
      }
    };
  }
  
  onPointerUp(
    event: PointerUpState,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    const element = appState.activeToolNonLinearElement;
    if (!element) return null;
    
    // 如果尺寸太小，删除元素
    if (Math.abs(element.width) < 5 || Math.abs(element.height) < 5) {
      return {
        elements: elements.slice(0, -1),
        appState: {
          activeToolNonLinearElement: null,
          selectedElementIds: {},
        }
      };
    }
    
    // 标准化尺寸（处理负数）
    const normalizedElement = this.normalizeElement(element);
    
    return {
      elements: [...elements.slice(0, -1), normalizedElement],
      appState: {
        activeToolNonLinearElement: null,
        selectedElementIds: { [normalizedElement.id]: true },
      }
    };
  }
  
  private normalizeElement(element: ExcalidrawRectangleElement): ExcalidrawRectangleElement {
    const { x, y, width, height } = element;
    
    const newX = width < 0 ? x + width : x;
    const newY = height < 0 ? y + height : y;
    const newWidth = Math.abs(width);
    const newHeight = Math.abs(height);
    
    return newElementWith(element, {
      x: newX,
      y: newY,
      width: newWidth,
      height: newHeight,
    });
  }
  
  getCursor(appState: AppState): string {
    return 'crosshair';
  }
}
```

### 3. 自由绘制工具 (Freedraw Tool)

```typescript
class FreeDrawTool extends BaseTool {
  private currentStroke: Point[] = [];
  private pressures: number[] = [];
  
  constructor() {
    super('freedraw', {
      type: 'freedraw',
      name: 'Draw',
      icon: <PencilIcon />,
      shortcut: 'P',
      cursor: 'crosshair'
    });
  }
  
  onActivate(appState: AppState): Partial<AppState> {
    return {
      activeToolLinearElement: null,
      activeToolNonLinearElement: null,
      selectedElementIds: {},
    };
  }
  
  onDeactivate(appState: AppState): Partial<AppState> {
    this.currentStroke = [];
    this.pressures = [];
    return {
      activeToolLinearElement: null,
    };
  }
  
  onPointerDown(
    event: PointerDownState,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    const { origin, pressure = 0.5 } = event;
    
    // 开始新的笔画
    this.currentStroke = [origin];
    this.pressures = [pressure];
    
    const element = newFreeDrawElement({
      type: 'freedraw',
      x: origin.x,
      y: origin.y,
      points: [[0, 0]],
      pressures: [pressure],
      strokeColor: appState.currentItemStrokeColor,
      strokeWidth: appState.currentItemStrokeWidth,
      strokeStyle: appState.currentItemStrokeStyle,
      roughness: appState.currentItemRoughness,
      opacity: appState.currentItemOpacity,
      simulatePressure: !event.isPen,
    });
    
    return {
      elements: [...elements, element],
      appState: {
        activeToolLinearElement: element,
        selectedElementIds: { [element.id]: true },
      }
    };
  }
  
  onPointerMove(
    event: PointerMoveState,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    if (!appState.activeToolLinearElement) return null;
    
    const { pointer, pressure = 0.5 } = event;
    const element = appState.activeToolLinearElement as ExcalidrawFreeDrawElement;
    
    // 添加新点
    this.currentStroke.push(pointer);
    this.pressures.push(pressure);
    
    // 转换为相对坐标
    const points = this.currentStroke.map((point, index) => {
      if (index === 0) return [0, 0] as [number, number];
      const firstPoint = this.currentStroke[0];
      return [
        point.x - firstPoint.x,
        point.y - firstPoint.y
      ] as [number, number];
    });
    
    // 应用平滑处理
    const smoothedPoints = this.smoothPoints(points);
    const smoothedPressures = this.smoothPressures(this.pressures);
    
    const updatedElement = newElementWith(element, {
      points: smoothedPoints,
      pressures: smoothedPressures,
    });
    
    return {
      elements: [...elements.slice(0, -1), updatedElement],
      appState: {
        activeToolLinearElement: updatedElement,
      }
    };
  }
  
  onPointerUp(
    event: PointerUpState,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    const element = appState.activeToolLinearElement;
    if (!element) return null;
    
    // 清理状态
    this.currentStroke = [];
    this.pressures = [];
    
    // 如果笔画太短，删除元素
    if ((element as ExcalidrawFreeDrawElement).points.length < 3) {
      return {
        elements: elements.slice(0, -1),
        appState: {
          activeToolLinearElement: null,
          selectedElementIds: {},
        }
      };
    }
    
    return {
      elements,
      appState: {
        activeToolLinearElement: null,
      }
    };
  }
  
  // 平滑点序列
  private smoothPoints(points: [number, number][]): [number, number][] {
    if (points.length < 3) return points;
    
    const smoothed: [number, number][] = [points[0]];
    
    for (let i = 1; i < points.length - 1; i++) {
      const prev = points[i - 1];
      const curr = points[i];
      const next = points[i + 1];
      
      // 应用简单的移动平均
      const smoothX = (prev[0] + curr[0] + next[0]) / 3;
      const smoothY = (prev[1] + curr[1] + next[1]) / 3;
      
      smoothed.push([smoothX, smoothY]);
    }
    
    smoothed.push(points[points.length - 1]);
    return smoothed;
  }
  
  // 平滑压力值
  private smoothPressures(pressures: number[]): number[] {
    if (pressures.length < 3) return pressures;
    
    const smoothed: number[] = [pressures[0]];
    
    for (let i = 1; i < pressures.length - 1; i++) {
      const prev = pressures[i - 1];
      const curr = pressures[i];
      const next = pressures[i + 1];
      
      smoothed.push((prev + curr + next) / 3);
    }
    
    smoothed.push(pressures[pressures.length - 1]);
    return smoothed;
  }
  
  getCursor(appState: AppState): string {
    return 'crosshair';
  }
}
```

## 工具状态管理

### 1. 工具状态接口

```typescript
// 工具状态类型定义
interface ToolState {
  // 当前活动工具
  activeTool: ActiveTool;
  
  // 正在创建的非线性元素
  activeToolNonLinearElement: ExcalidrawNonLinearElement | null;
  
  // 正在创建的线性元素
  activeToolLinearElement: ExcalidrawLinearElement | null;
  
  // 多点元素（如箭头、线条）
  multiElement: MultiElement | null;
  
  // 工具锁定状态
  toolLocked: boolean;
  
  // 临时工具（如按住空格的手型工具）
  temporaryTool: ToolType | null;
  
  // 工具配置
  toolConfig: Record<ToolType, ToolConfiguration>;
}

// 工具配置类型
interface ToolConfiguration {
  enabled: boolean;
  visible: boolean;
  locked: boolean;
  customProps?: Record<string, any>;
}

// 多点元素状态
interface MultiElement {
  element: ExcalidrawLinearElement;
  originalElement: ExcalidrawLinearElement;
  isDrawing: boolean;
}
```

### 2. 工具状态管理器

```typescript
class ToolStateManager {
  private state: ToolState;
  private subscribers: Set<(state: ToolState) => void> = new Set();
  
  constructor(initialState: Partial<ToolState> = {}) {
    this.state = {
      activeTool: { type: 'selection', customType: null },
      activeToolNonLinearElement: null,
      activeToolLinearElement: null,
      multiElement: null,
      toolLocked: false,
      temporaryTool: null,
      toolConfig: this.getDefaultToolConfig(),
      ...initialState,
    };
  }
  
  // 获取当前状态
  getState(): ToolState {
    return { ...this.state };
  }
  
  // 更新状态
  updateState(updates: Partial<ToolState>): void {
    this.state = { ...this.state, ...updates };
    this.notifySubscribers();
  }
  
  // 设置活动工具
  setActiveTool(tool: ActiveTool): void {
    // 如果工具被锁定，忽略切换
    if (this.state.toolLocked && tool.type !== this.state.activeTool.type) {
      return;
    }
    
    this.updateState({
      activeTool: tool,
      activeToolNonLinearElement: null,
      activeToolLinearElement: null,
      multiElement: null,
    });
  }
  
  // 设置临时工具
  setTemporaryTool(tool: ToolType | null): void {
    this.updateState({ temporaryTool: tool });
  }
  
  // 获取当前有效工具（考虑临时工具）
  getEffectiveTool(): ToolType {
    return this.state.temporaryTool || this.state.activeTool.type;
  }
  
  // 锁定/解锁工具
  toggleToolLock(): void {
    this.updateState({ toolLocked: !this.state.toolLocked });
  }
  
  // 配置工具
  configureTools(config: Partial<Record<ToolType, Partial<ToolConfiguration>>>): void {
    const newConfig = { ...this.state.toolConfig };
    
    for (const [toolType, toolConfig] of Object.entries(config)) {
      if (newConfig[toolType as ToolType]) {
        newConfig[toolType as ToolType] = {
          ...newConfig[toolType as ToolType],
          ...toolConfig,
        };
      }
    }
    
    this.updateState({ toolConfig: newConfig });
  }
  
  // 订阅状态变化
  subscribe(callback: (state: ToolState) => void): () => void {
    this.subscribers.add(callback);
    return () => this.subscribers.delete(callback);
  }
  
  // 通知订阅者
  private notifySubscribers(): void {
    this.subscribers.forEach(callback => callback(this.state));
  }
  
  // 获取默认工具配置
  private getDefaultToolConfig(): Record<ToolType, ToolConfiguration> {
    const defaultConfig: ToolConfiguration = {
      enabled: true,
      visible: true,
      locked: false,
    };
    
    const toolTypes: ToolType[] = [
      'selection', 'lasso', 'rectangle', 'diamond', 'ellipse',
      'arrow', 'line', 'freedraw', 'text', 'image', 'eraser',
      'hand', 'frame', 'magicframe', 'embeddable', 'laser'
    ];
    
    return toolTypes.reduce((config, toolType) => {
      config[toolType] = { ...defaultConfig };
      return config;
    }, {} as Record<ToolType, ToolConfiguration>);
  }
}
```

## 工具栏系统

### 1. 工具栏组件

```typescript
// 工具栏属性接口
interface ToolbarProps {
  app: App;
  activeTool: ActiveTool;
  onToolChange: (tool: ActiveTool) => void;
  tools?: ToolType[];
  orientation?: 'horizontal' | 'vertical';
  size?: 'small' | 'medium' | 'large';
  showLabels?: boolean;
  showShortcuts?: boolean;
}

// 工具按钮属性
interface ToolButtonProps {
  tool: BaseTool;
  active: boolean;
  disabled?: boolean;
  size?: ToolButtonSize;
  showLabel?: boolean;
  showShortcut?: boolean;
  onClick: (tool: ToolType) => void;
}

// 工具按钮组件
const ToolButton: React.FC<ToolButtonProps> = ({
  tool,
  active,
  disabled = false,
  size = 'medium',
  showLabel = false,
  showShortcut = false,
  onClick,
}) => {
  const handleClick = useCallback(() => {
    if (!disabled) {
      onClick(tool.type);
    }
  }, [tool.type, disabled, onClick]);
  
  const shortcut = useMemo(() => {
    const shortcuts = tool.getShortcuts();
    return shortcuts.length > 0 ? shortcuts[0] : '';
  }, [tool]);
  
  return (
    <button
      className={clsx('ToolButton', {
        'ToolButton--active': active,
        'ToolButton--disabled': disabled,
        [`ToolButton--${size}`]: size,
      })}
      onClick={handleClick}
      disabled={disabled}
      title={tool.getTooltip({})}
      aria-label={tool.config.name}
      aria-pressed={active}
      data-testid={`tool-${tool.type}`}
    >
      <div className="ToolButton__icon">
        {tool.config.icon}
      </div>
      
      {showLabel && (
        <div className="ToolButton__label">
          {tool.config.name}
        </div>
      )}
      
      {showShortcut && shortcut && (
        <div className="ToolButton__shortcut">
          {shortcut}
        </div>
      )}
    </button>
  );
};

// 工具栏组件
const Toolbar: React.FC<ToolbarProps> = ({
  app,
  activeTool,
  onToolChange,
  tools: customTools,
  orientation = 'horizontal',
  size = 'medium',
  showLabels = false,
  showShortcuts = false,
}) => {
  const toolManager = app.toolManager;
  const allTools = toolManager.getAllTools();
  
  // 过滤要显示的工具
  const displayTools = useMemo(() => {
    if (customTools) {
      return allTools.filter(tool => customTools.includes(tool.type));
    }
    return allTools.filter(tool => 
      tool.config.visible !== false && 
      tool.isEnabled(app.state, app.scene.getElements())
    );
  }, [allTools, customTools, app.state, app.scene]);
  
  // 工具分组
  const toolGroups = useMemo(() => {
    const groups = new Map<string, BaseTool[]>();
    
    displayTools.forEach(tool => {
      const group = tool.config.group || 'default';
      if (!groups.has(group)) {
        groups.set(group, []);
      }
      groups.get(group)!.push(tool);
    });
    
    return groups;
  }, [displayTools]);
  
  const handleToolChange = useCallback((toolType: ToolType) => {
    onToolChange({ type: toolType, customType: null });
  }, [onToolChange]);
  
  return (
    <div
      className={clsx('Toolbar', {
        [`Toolbar--${orientation}`]: orientation,
        [`Toolbar--${size}`]: size,
      })}
      role="toolbar"
      aria-label="Drawing tools"
    >
      {Array.from(toolGroups.entries()).map(([groupName, groupTools]) => (
        <div
          key={groupName}
          className={clsx('Toolbar__group', {
            [`Toolbar__group--${groupName}`]: groupName !== 'default',
          })}
          role="group"
          aria-label={groupName !== 'default' ? `${groupName} tools` : undefined}
        >
          {groupTools.map(tool => (
            <ToolButton
              key={tool.type}
              tool={tool}
              active={
                activeTool.type === tool.type ||
                (activeTool.type === 'custom' && activeTool.customType === tool.type)
              }
              size={size}
              showLabel={showLabels}
              showShortcut={showShortcuts}
              onClick={handleToolChange}
            />
          ))}
        </div>
      ))}
    </div>
  );
};
```

## 自定义工具开发

### 1. 自定义工具示例

```typescript
// 自定义星形工具
class StarTool extends BaseTool {
  constructor() {
    super('custom', {
      type: 'custom' as any,
      name: 'Star',
      icon: <StarIcon />,
      shortcut: 'T',
      cursor: 'crosshair',
      group: 'shapes',
    });
  }
  
  onActivate(appState: AppState): Partial<AppState> {
    return {
      activeToolNonLinearElement: null,
      selectedElementIds: {},
    };
  }
  
  onDeactivate(appState: AppState): Partial<AppState> {
    return {};
  }
  
  onPointerDown(
    event: PointerDownState,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    const { origin } = event;
    
    // 创建自定义星形元素
    const element = this.createStarElement(
      origin.x,
      origin.y,
      0,
      0,
      appState
    );
    
    return {
      elements: [...elements, element],
      appState: {
        activeToolNonLinearElement: element,
        selectedElementIds: { [element.id]: true },
      }
    };
  }
  
  onPointerMove(
    event: PointerMoveState,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    if (!appState.activeToolNonLinearElement) return null;
    
    const { pointer, origin, withShift } = event;
    const element = appState.activeToolNonLinearElement;
    
    let width = pointer.x - origin.x;
    let height = pointer.y - origin.y;
    
    // Shift键保持正比例
    if (withShift) {
      const size = Math.max(Math.abs(width), Math.abs(height));
      width = width > 0 ? size : -size;
      height = height > 0 ? size : -size;
    }
    
    const updatedElement = this.createStarElement(
      origin.x,
      origin.y,
      width,
      height,
      appState,
      element.id
    );
    
    return {
      elements: [...elements.slice(0, -1), updatedElement],
      appState: {
        activeToolNonLinearElement: updatedElement,
      }
    };
  }
  
  onPointerUp(
    event: PointerUpState,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    const element = appState.activeToolNonLinearElement;
    if (!element) return null;
    
    // 检查最小尺寸
    if (Math.abs(element.width) < 10 || Math.abs(element.height) < 10) {
      return {
        elements: elements.slice(0, -1),
        appState: {
          activeToolNonLinearElement: null,
          selectedElementIds: {},
        }
      };
    }
    
    return {
      elements,
      appState: {
        activeToolNonLinearElement: null,
      }
    };
  }
  
  // 创建星形元素
  private createStarElement(
    x: number,
    y: number,
    width: number,
    height: number,
    appState: AppState,
    id?: string
  ): ExcalidrawGenericElement {
    const points = this.generateStarPoints(width, height, 5);
    
    return newElement({
      type: 'draw',
      id,
      x,
      y,
      width: Math.abs(width),
      height: Math.abs(height),
      points,
      strokeColor: appState.currentItemStrokeColor,
      backgroundColor: appState.currentItemBackgroundColor,
      fillStyle: appState.currentItemFillStyle,
      strokeWidth: appState.currentItemStrokeWidth,
      strokeStyle: appState.currentItemStrokeStyle,
      roughness: appState.currentItemRoughness,
      opacity: appState.currentItemOpacity,
    });
  }
  
  // 生成星形路径点
  private generateStarPoints(width: number, height: number, spikes: number): [number, number][] {
    const centerX = width / 2;
    const centerY = height / 2;
    const outerRadius = Math.min(Math.abs(width), Math.abs(height)) / 2;
    const innerRadius = outerRadius * 0.4;
    
    const points: [number, number][] = [];
    const step = Math.PI / spikes;
    
    for (let i = 0; i < spikes * 2; i++) {
      const radius = i % 2 === 0 ? outerRadius : innerRadius;
      const angle = i * step - Math.PI / 2;
      
      const x = centerX + Math.cos(angle) * radius;
      const y = centerY + Math.sin(angle) * radius;
      
      points.push([x, y]);
    }
    
    // 闭合路径
    points.push(points[0]);
    
    return points;
  }
  
  getCursor(appState: AppState): string {
    return 'crosshair';
  }
  
  getTooltip(appState: AppState): string {
    return 'Draw a star (T)';
  }
  
  getShortcuts(): string[] {
    return ['T'];
  }
}

// 注册自定义工具
function registerCustomTool(app: App) {
  const starTool = new StarTool();
  app.toolManager.registerTool(starTool);
}
```

### 2. 工具插件系统

```typescript
// 工具插件接口
interface ToolPlugin {
  name: string;
  version: string;
  tools: BaseTool[];
  actions?: Action[];
  onInstall?: (app: App) => void;
  onUninstall?: (app: App) => void;
}

// 工具插件管理器
class ToolPluginManager {
  private plugins = new Map<string, ToolPlugin>();
  private app: App;
  
  constructor(app: App) {
    this.app = app;
  }
  
  // 安装插件
  installPlugin(plugin: ToolPlugin): void {
    if (this.plugins.has(plugin.name)) {
      throw new Error(`Plugin ${plugin.name} is already installed`);
    }
    
    // 注册工具
    plugin.tools.forEach(tool => {
      this.app.toolManager.registerTool(tool);
    });
    
    // 注册动作
    if (plugin.actions) {
      plugin.actions.forEach(action => {
        this.app.actionManager.registerAction(action);
      });
    }
    
    // 执行安装回调
    if (plugin.onInstall) {
      plugin.onInstall(this.app);
    }
    
    this.plugins.set(plugin.name, plugin);
  }
  
  // 卸载插件
  uninstallPlugin(pluginName: string): void {
    const plugin = this.plugins.get(pluginName);
    if (!plugin) {
      throw new Error(`Plugin ${pluginName} is not installed`);
    }
    
    // 执行卸载回调
    if (plugin.onUninstall) {
      plugin.onUninstall(this.app);
    }
    
    // TODO: 从工具管理器中移除工具和动作
    
    this.plugins.delete(pluginName);
  }
  
  // 获取已安装的插件
  getInstalledPlugins(): ToolPlugin[] {
    return Array.from(this.plugins.values());
  }
  
  // 检查插件是否已安装
  isPluginInstalled(pluginName: string): boolean {
    return this.plugins.has(pluginName);
  }
}

// 示例：几何图形工具包插件
const geometryToolsPlugin: ToolPlugin = {
  name: 'geometry-tools',
  version: '1.0.0',
  tools: [
    new StarTool(),
    new HeartTool(),
    new HexagonTool(),
    new TriangleTool(),
  ],
  actions: [
    {
      name: 'convertToGeometry',
      label: 'Convert to Geometry',
      perform: (elements, appState) => {
        // 转换选中元素为几何图形
        return { elements, appState };
      },
      trackEvent: { category: 'geometry' },
    },
  ],
  onInstall: (app) => {
    console.log('Geometry tools plugin installed');
  },
  onUninstall: (app) => {
    console.log('Geometry tools plugin uninstalled');
  },
};
```

## 实战示例

### 1. 高级标注工具

```typescript
// 标注工具实现
class AnnotationTool extends BaseTool {
  private annotationMode: 'text' | 'arrow' | 'highlight' = 'text';
  
  constructor() {
    super('custom', {
      type: 'custom' as any,
      name: 'Annotation',
      icon: <AnnotationIcon />,
      shortcut: 'N',
      cursor: 'crosshair',
      group: 'annotation',
    });
  }
  
  onActivate(appState: AppState): Partial<AppState> {
    return {
      selectedElementIds: {},
      // 显示标注工具配置面板
      openDialog: {
        name: 'annotationConfig',
        tab: 'mode',
      },
    };
  }
  
  onPointerDown(
    event: PointerDownState,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    const { origin, withShift } = event;
    
    switch (this.annotationMode) {
      case 'text':
        return this.createTextAnnotation(origin, appState, elements);
        
      case 'arrow':
        return this.createArrowAnnotation(origin, appState, elements);
        
      case 'highlight':
        return this.createHighlightAnnotation(origin, appState, elements);
        
      default:
        return null;
    }
  }
  
  private createTextAnnotation(
    origin: Point,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    // 创建文本标注
    const textElement = newTextElement({
      x: origin.x,
      y: origin.y,
      text: '',
      fontSize: 14,
      fontFamily: 1,
      textAlign: 'left' as const,
      verticalAlign: 'top' as const,
      strokeColor: '#1971c2',
      backgroundColor: '#ffffff',
      opacity: 90,
    });
    
    // 创建背景框
    const backgroundElement = newElement({
      type: 'rectangle',
      x: origin.x - 5,
      y: origin.y - 5,
      width: 100,
      height: 25,
      strokeColor: '#1971c2',
      backgroundColor: '#e7f5ff',
      fillStyle: 'solid',
      strokeWidth: 1,
      opacity: 80,
    });
    
    return {
      elements: [...elements, backgroundElement, textElement],
      appState: {
        selectedElementIds: { [textElement.id]: true },
        editingElement: textElement,
      }
    };
  }
  
  private createArrowAnnotation(
    origin: Point,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    // 创建指向性箭头标注
    const arrowElement = newLinearElement({
      type: 'arrow',
      x: origin.x,
      y: origin.y,
      points: [[0, 0], [50, -30]],
      strokeColor: '#d9480f',
      strokeWidth: 2,
      startArrowhead: null,
      endArrowhead: 'arrow',
    });
    
    return {
      elements: [...elements, arrowElement],
      appState: {
        activeToolLinearElement: arrowElement,
        selectedElementIds: { [arrowElement.id]: true },
      }
    };
  }
  
  private createHighlightAnnotation(
    origin: Point,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    // 创建高亮标注
    const highlightElement = newElement({
      type: 'rectangle',
      x: origin.x,
      y: origin.y,
      width: 0,
      height: 20,
      strokeColor: 'transparent',
      backgroundColor: '#ffec99',
      fillStyle: 'solid',
      opacity: 60,
    });
    
    return {
      elements: [...elements, highlightElement],
      appState: {
        activeToolNonLinearElement: highlightElement,
        selectedElementIds: { [highlightElement.id]: true },
      }
    };
  }
  
  // 设置标注模式
  setAnnotationMode(mode: 'text' | 'arrow' | 'highlight'): void {
    this.annotationMode = mode;
  }
  
  // 创建标注配置面板
  createConfigPanel(): React.ReactElement {
    return (
      <div className="annotation-config-panel">
        <h3>Annotation Mode</h3>
        <div className="mode-buttons">
          <button
            className={this.annotationMode === 'text' ? 'active' : ''}
            onClick={() => this.setAnnotationMode('text')}
          >
            Text
          </button>
          <button
            className={this.annotationMode === 'arrow' ? 'active' : ''}
            onClick={() => this.setAnnotationMode('arrow')}
          >
            Arrow
          </button>
          <button
            className={this.annotationMode === 'highlight' ? 'active' : ''}
            onClick={() => this.setAnnotationMode('highlight')}
          >
            Highlight
          </button>
        </div>
      </div>
    );
  }
}
```

### 2. 智能吸附工具

```typescript
// 智能吸附工具
class SmartSnapTool extends BaseTool {
  private snapDistance = 10;
  private snapEnabled = true;
  
  constructor() {
    super('custom', {
      type: 'custom' as any,
      name: 'Smart Snap',
      icon: <SnapIcon />,
      shortcut: 'S',
      cursor: 'default',
      group: 'utility',
    });
  }
  
  onActivate(appState: AppState): Partial<AppState> {
    return {
      snapToGrid: false,
      snapToObjects: this.snapEnabled,
    };
  }
  
  // 重写指针移动处理以添加智能吸附
  onPointerMove(
    event: PointerMoveState,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) {
    if (!this.snapEnabled) return null;
    
    const { pointer } = event;
    const snapPoint = this.findSnapPoint(pointer, elements, appState);
    
    if (snapPoint) {
      // 显示吸附指示器
      this.showSnapIndicator(snapPoint);
      
      // 更新指针位置为吸附位置
      return {
        elements,
        appState: {
          ...appState,
          snapPoint,
        }
      };
    }
    
    return null;
  }
  
  // 查找吸附点
  private findSnapPoint(
    pointer: Point,
    elements: readonly ExcalidrawElement[],
    appState: AppState
  ): Point | null {
    const candidates: Array<{ point: Point; type: string; element?: ExcalidrawElement }> = [];
    
    // 查找元素边界吸附点
    elements.forEach(element => {
      if (element.isDeleted) return;
      
      const bounds = getElementAbsoluteCoords(element);
      const elementSnapPoints = this.getElementSnapPoints(bounds, element);
      
      elementSnapPoints.forEach(snapPoint => {
        const distance = pointDistance(pointer, snapPoint.point);
        if (distance <= this.snapDistance) {
          candidates.push({
            ...snapPoint,
            element,
          });
        }
      });
    });
    
    // 查找网格吸附点
    if (appState.gridSize && appState.gridSize > 0) {
      const gridPoint = this.getGridSnapPoint(pointer, appState.gridSize);
      const distance = pointDistance(pointer, gridPoint);
      if (distance <= this.snapDistance) {
        candidates.push({
          point: gridPoint,
          type: 'grid',
        });
      }
    }
    
    // 选择最近的吸附点
    if (candidates.length === 0) return null;
    
    const closest = candidates.reduce((closest, candidate) => {
      const currentDistance = pointDistance(pointer, candidate.point);
      const closestDistance = pointDistance(pointer, closest.point);
      return currentDistance < closestDistance ? candidate : closest;
    });
    
    return closest.point;
  }
  
  // 获取元素吸附点
  private getElementSnapPoints(
    bounds: Bounds,
    element: ExcalidrawElement
  ): Array<{ point: Point; type: string }> {
    const [x1, y1, x2, y2] = bounds;
    const centerX = (x1 + x2) / 2;
    const centerY = (y1 + y2) / 2;
    
    const snapPoints: Array<{ point: Point; type: string }> = [
      // 角点
      { point: { x: x1, y: y1 }, type: 'corner-tl' },
      { point: { x: x2, y: y1 }, type: 'corner-tr' },
      { point: { x: x1, y: y2 }, type: 'corner-bl' },
      { point: { x: x2, y: y2 }, type: 'corner-br' },
      
      // 边中点
      { point: { x: centerX, y: y1 }, type: 'edge-top' },
      { point: { x: centerX, y: y2 }, type: 'edge-bottom' },
      { point: { x: x1, y: centerY }, type: 'edge-left' },
      { point: { x: x2, y: centerY }, type: 'edge-right' },
      
      // 中心点
      { point: { x: centerX, y: centerY }, type: 'center' },
    ];
    
    // 对于线性元素，添加端点
    if (isLinearElement(element)) {
      const points = LinearElementEditor.getPointsGlobalCoordinates(element);
      points.forEach((point, index) => {
        snapPoints.push({
          point,
          type: `line-point-${index}`,
        });
      });
    }
    
    return snapPoints;
  }
  
  // 获取网格吸附点
  private getGridSnapPoint(pointer: Point, gridSize: number): Point {
    const x = Math.round(pointer.x / gridSize) * gridSize;
    const y = Math.round(pointer.y / gridSize) * gridSize;
    return { x, y };
  }
  
  // 显示吸附指示器
  private showSnapIndicator(snapPoint: Point): void {
    // 创建临时的视觉指示器
    const indicator = document.createElement('div');
    indicator.className = 'snap-indicator';
    indicator.style.position = 'absolute';
    indicator.style.left = `${snapPoint.x - 5}px`;
    indicator.style.top = `${snapPoint.y - 5}px`;
    indicator.style.width = '10px';
    indicator.style.height = '10px';
    indicator.style.borderRadius = '50%';
    indicator.style.backgroundColor = '#1971c2';
    indicator.style.pointerEvents = 'none';
    indicator.style.zIndex = '9999';
    
    document.body.appendChild(indicator);
    
    // 自动移除指示器
    setTimeout(() => {
      document.body.removeChild(indicator);
    }, 100);
  }
  
  // 切换吸附功能
  toggleSnap(): void {
    this.snapEnabled = !this.snapEnabled;
  }
  
  // 设置吸附距离
  setSnapDistance(distance: number): void {
    this.snapDistance = Math.max(5, Math.min(50, distance));
  }
}
```

这个工具系统文档详细介绍了 Excalidraw 的工具架构、内置工具实现、状态管理、工具栏系统、扩展机制以及实际的自定义工具开发示例。这为开发者提供了完整的工具系统理解和扩展指南。