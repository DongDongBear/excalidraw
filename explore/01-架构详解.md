# Excalidraw 架构详解

## 1. 整体架构设计

Excalidraw 采用了分层架构设计，每一层都有明确的职责边界。让我们从源码层面深入理解这个架构。

### 1.1 核心组件结构

```typescript
// packages/excalidraw/index.tsx
// 这是整个应用的入口文件

const ExcalidrawBase = (props: ExcalidrawProps) => {
  // 1. 解构所有的 props
  const {
    onChange,
    initialData,
    excalidrawAPI,
    isCollaborating = false,
    onPointerUpdate,
    renderTopRightUI,
    langCode = defaultLang.code,
    viewModeEnabled,
    zenModeEnabled,
    gridModeEnabled,
    // ... 更多配置项
  } = props;

  // 2. 规范化 UIOptions
  const UIOptions: AppProps["UIOptions"] = {
    ...props.UIOptions,
    canvasActions: {
      ...DEFAULT_UI_OPTIONS.canvasActions,
      ...canvasActions,
    },
    tools: {
      image: props.UIOptions?.tools?.image ?? true,
    },
  };

  // 3. 处理移动端触摸事件
  useEffect(() => {
    const handleTouchMove = (event: TouchEvent) => {
      // 阻止 iOS 上的 pinch-zoom
      if (typeof event.scale === "number" && event.scale !== 1) {
        event.preventDefault();
      }
    };
    document.addEventListener("touchmove", handleTouchMove, { passive: false });
    return () => document.removeEventListener("touchmove", handleTouchMove);
  }, []);

  // 4. 渲染组件树
  return (
    <EditorJotaiProvider store={editorJotaiStore}>
      <InitializeApp langCode={langCode} theme={theme}>
        <App
          onChange={onChange}
          initialData={initialData}
          excalidrawAPI={excalidrawAPI}
          // ... 所有props传递给App
        >
          {children}
        </App>
      </InitializeApp>
    </EditorJotaiProvider>
  );
};

// 使用 React.memo 优化性能
export const Excalidraw = React.memo(ExcalidrawBase, areEqual);
```

### 1.2 Context 架构

Excalidraw 使用多个 Context 来管理不同层面的状态：

```typescript
// packages/excalidraw/components/App.tsx

// 1. App Context - 提供 App 实例的方法和属性
const AppContext = React.createContext<AppClassProperties>(null!);

// 2. Props Context - 传递 props 给子组件
const AppPropsContext = React.createContext<AppProps>(null!);

// 3. Device Context - 设备信息（响应式设计）
const DeviceContext = React.createContext<Device>({
  viewport: {
    isMobile: false,
    isLandscape: false,
  },
  editor: {
    isMobile: false,
    canFitSidebar: false,
  },
  isTouchScreen: false,
});

// 4. Container Context - DOM 容器引用
export const ExcalidrawContainerContext = React.createContext<{
  container: HTMLDivElement | null;
  id: string | null;
}>({ container: null, id: null });
```

## 2. App 组件核心架构

App 组件是整个应用的核心，它管理着所有的状态和业务逻辑。

### 2.1 App 类的设计

```typescript
class App extends React.Component<AppProps, AppState> {
  // === 核心属性 ===
  
  // 场景元素和文件
  private scene: Scene;
  private files: BinaryFiles = {};
  private filesManager: FileManager;
  
  // Canvas 相关
  canvas: AppClassProperties["canvas"];
  private rc: RoughCanvas;
  private renderer: Renderer;
  
  // 历史管理
  private history: History;
  
  // 动作管理器
  private actionManager: ActionManager;
  
  // 动画和性能
  private animationFrameHandler: AnimationFrameHandler;
  
  // 协作相关
  private lastPointerDownEvent: React.PointerEvent<Element> | null = null;
  private lastPointerUpEvent: React.PointerEvent<Element> | PointerEvent | null = null;
  private lastViewportPosition: { x: number; y: number } = { x: 0, y: 0 };
  
  // === 生命周期方法 ===
  
  componentDidMount() {
    // 1. 初始化场景
    this.scene = new Scene();
    
    // 2. 注册全局事件
    this.registerEventListeners();
    
    // 3. 初始化渲染器
    this.initializeRenderer();
    
    // 4. 恢复初始数据
    if (this.props.initialData) {
      this.restoreFromInitialData();
    }
    
    // 5. 设置 API
    if (this.props.excalidrawAPI) {
      this.props.excalidrawAPI.current = this.getExcalidrawAPI();
    }
  }
  
  componentDidUpdate(prevProps: AppProps, prevState: AppState) {
    // 处理各种状态变化
    this.handleStateChanges(prevState);
    
    // 触发 onChange 回调
    if (this.props.onChange && this.hasSceneChanged(prevState)) {
      this.props.onChange(
        this.scene.getElementsIncludingDeleted(),
        this.state,
        this.files
      );
    }
  }
  
  // === 核心方法 ===
  
  private initializeRenderer() {
    this.renderer = new Renderer(this.scene);
    
    // 静态场景渲染
    this.renderer.renderStaticScene({
      canvas: this.canvas.static,
      rc: this.rc,
      elements: this.scene.getNonDeletedElements(),
      appState: this.state,
    });
    
    // 交互场景渲染
    this.renderer.renderInteractiveScene({
      canvas: this.canvas.interactive,
      elements: this.scene.getNonDeletedElements(),
      appState: this.state,
    });
  }
}
```

### 2.2 状态管理架构

```typescript
// AppState 的核心结构
interface AppState {
  // === 视图状态 ===
  viewBackgroundColor: string;
  scrollX: number;
  scrollY: number;
  zoom: Zoom;
  
  // === 工具状态 ===
  activeTool: ToolType;
  selectedElementIds: Record<string, boolean>;
  selectedGroupIds: Record<string, boolean>;
  
  // === 交互状态 ===
  draggingElement: NonDeletedExcalidrawElement | null;
  resizingElement: NonDeletedExcalidrawElement | null;
  editingElement: NonDeletedExcalidrawElement | null;
  
  // === UI 状态 ===
  openMenu: "canvas" | "shape" | null;
  openSidebar: { name: SidebarName; tab?: SidebarTabName } | null;
  openDialog: DialogName | null;
  
  // === 协作状态 ===
  collaborators: Map<string, Collaborator>;
  
  // === 性能优化 ===
  shouldCacheIgnoreZoom: boolean;
  renderInteractiveSceneCallback?: RenderInteractiveSceneCallback;
}
```

## 3. 分层设计原理

### 3.1 数据层（Model）

```typescript
// packages/element/src/types.ts
// 元素是数据层的核心

type _ExcalidrawElementBase = Readonly<{
  id: string;                    // 唯一标识
  x: number;                     // X坐标
  y: number;                     // Y坐标
  width: number;                 // 宽度
  height: number;                // 高度
  angle: Radians;                // 旋转角度
  strokeColor: string;           // 描边颜色
  backgroundColor: string;       // 背景颜色
  fillStyle: FillStyle;          // 填充样式
  strokeWidth: number;           // 描边宽度
  strokeStyle: StrokeStyle;      // 描边样式
  roundness: null | { type: RoundnessType; value?: number };
  roughness: number;             // 粗糙度（RoughJS参数）
  opacity: number;               // 透明度
  seed: number;                  // 随机种子（保证渲染一致性）
  version: number;               // 版本号（协作时使用）
  versionNonce: number;          // 版本随机数
  index: FractionalIndex | null; // 分数索引（排序用）
  isDeleted: boolean;            // 删除标记
  groupIds: readonly GroupId[];  // 所属组
  frameId: string | null;        // 所属框架
  boundElements: readonly BoundElement[] | null; // 绑定元素
  updated: number;               // 更新时间戳
  link: string | null;           // 链接
  locked: boolean;               // 锁定状态
  customData?: Record<string, any>; // 自定义数据
}>;

// 具体元素类型
export type ExcalidrawRectangleElement = _ExcalidrawElementBase & {
  type: "rectangle";
};

export type ExcalidrawEllipseElement = _ExcalidrawElementBase & {
  type: "ellipse";
};

export type ExcalidrawTextElement = _ExcalidrawElementBase & {
  type: "text";
  fontSize: number;
  fontFamily: FontFamilyValues;
  text: string;
  baseline: number;
  textAlign: TextAlign;
  verticalAlign: VerticalAlign;
  containerId: string | null;  // 容器元素ID（文本框）
  originalText: string;
  autoResize: boolean;
  lineHeight: number;
};
```

### 3.2 视图层（View）

```typescript
// packages/excalidraw/components/canvases/
// Canvas 分层渲染架构

// 1. 静态层 - 不经常变化的元素
export const StaticCanvas = React.memo(
  ({ scale, appState, elements }: StaticCanvasProps) => {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    
    useEffect(() => {
      const canvas = canvasRef.current;
      if (!canvas) return;
      
      const context = canvas.getContext("2d");
      if (!context) return;
      
      // 渲染静态元素
      renderStaticScene({
        canvas,
        context,
        elements,
        appState,
        scale,
      });
    }, [elements, appState, scale]);
    
    return <canvas ref={canvasRef} className="excalidraw__canvas--static" />;
  }
);

// 2. 交互层 - 实时交互效果
export const InteractiveCanvas = React.memo(
  ({ appState, elements, onPointerMove, onPointerDown }: InteractiveCanvasProps) => {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    
    // 处理指针事件
    const handlePointerMove = useCallback((event: PointerEvent) => {
      // 渲染选择框、对齐线等
      renderInteractiveElements();
      onPointerMove?.(event);
    }, [onPointerMove]);
    
    return (
      <canvas 
        ref={canvasRef}
        className="excalidraw__canvas--interactive"
        onPointerMove={handlePointerMove}
        onPointerDown={onPointerDown}
      />
    );
  }
);

// 3. SVG层 - 特殊元素（如超链接）
export const SVGLayer = ({ elements, appState }: SVGLayerProps) => {
  return (
    <svg className="excalidraw__canvas--svg">
      {elements.map(element => {
        if (element.link) {
          return <HyperlinkSVG key={element.id} element={element} />;
        }
        return null;
      })}
    </svg>
  );
};
```

### 3.3 控制层（Controller）

```typescript
// packages/excalidraw/actions/
// Action 系统架构

// Action 定义
export interface Action {
  name: ActionName;                    // 动作名称
  label?: string;                      // 显示标签
  keywords?: string[];                 // 搜索关键词
  icon?: React.ReactNode;              // 图标
  viewMode?: boolean;                  // 是否在只读模式可用
  trackEvent?: TrackEventInfo;         // 事件追踪
  perform: (                           // 执行函数
    elements: readonly ExcalidrawElement[],
    appState: AppState,
    formData: any,
    app: AppClassProperties
  ) => ActionResult;
  checked?: (appState: AppState) => boolean;  // 选中状态
  keyPriority?: number;                       // 快捷键优先级
  keyTest?: (                                 // 快捷键测试
    event: KeyboardEvent,
    appState: AppState,
    elements: readonly ExcalidrawElement[]
  ) => boolean;
}

// ActionManager 管理所有 Actions
export class ActionManager {
  private actions: Record<ActionName, Action> = {};
  private shortcuts: Map<string, ActionName> = new Map();
  
  registerAction(action: Action) {
    this.actions[action.name] = action;
    
    // 注册快捷键
    if (action.keyTest) {
      this.registerShortcut(action);
    }
  }
  
  executeAction(
    actionName: ActionName,
    elements: readonly ExcalidrawElement[],
    appState: AppState,
    formData: any,
    app: AppClassProperties
  ): ActionResult {
    const action = this.actions[actionName];
    if (!action) {
      throw new Error(`Action ${actionName} not found`);
    }
    
    // 检查权限
    if (appState.viewModeEnabled && !action.viewMode) {
      return { appState, elements };
    }
    
    // 执行动作
    const result = action.perform(elements, appState, formData, app);
    
    // 记录历史
    if (result.commitToHistory) {
      app.history.record(result.elements, result.appState);
    }
    
    return result;
  }
}

// 具体 Action 示例
export const actionSelectAll: Action = {
  name: "selectAll",
  label: "labels.selectAll",
  icon: selectAllIcon,
  keyTest: (event) => isKey(event, KEYS.CTRL_A),
  
  perform: (elements, appState) => {
    const selectedElementIds = elements.reduce(
      (acc, element) => {
        if (!element.isDeleted && !element.locked) {
          acc[element.id] = true;
        }
        return acc;
      },
      {} as Record<string, boolean>
    );
    
    return {
      appState: {
        ...appState,
        selectedElementIds,
      },
      elements,
      commitToHistory: false,
    };
  },
};
```

## 4. 模块间通信机制

### 4.1 事件系统

```typescript
// 自定义事件发射器
export class Emitter<Events extends Record<string, any>> {
  private listeners = new Map<keyof Events, Set<Function>>();
  
  on<K extends keyof Events>(
    event: K,
    callback: (data: Events[K]) => void
  ): UnsubscribeCallback {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    
    this.listeners.get(event)!.add(callback);
    
    // 返回取消订阅函数
    return () => {
      this.listeners.get(event)?.delete(callback);
    };
  }
  
  emit<K extends keyof Events>(event: K, data: Events[K]) {
    this.listeners.get(event)?.forEach(callback => {
      callback(data);
    });
  }
  
  clear() {
    this.listeners.clear();
  }
}

// 使用示例
const emitter = new Emitter<{
  change: { elements: ExcalidrawElement[] };
  pointerMove: { x: number; y: number };
}>();

// 订阅事件
const unsubscribe = emitter.on("change", ({ elements }) => {
  console.log("Elements changed:", elements);
});

// 发送事件
emitter.emit("change", { elements: updatedElements });
```

### 4.2 Jotai 状态管理

```typescript
// packages/excalidraw/editor-jotai.ts
// 使用 Jotai 进行原子化状态管理

import { atom, createStore } from "jotai";

// 创建全局 store
export const editorJotaiStore = createStore();

// 定义原子状态
export const selectedElementsAtom = atom<ExcalidrawElement[]>([]);
export const appStateAtom = atom<AppState>(getDefaultAppState());
export const collaboratorsAtom = atom<Map<string, Collaborator>>(new Map());

// 派生状态
export const selectedElementIdsAtom = atom((get) => {
  const selectedElements = get(selectedElementsAtom);
  return selectedElements.map(el => el.id);
});

// 在组件中使用
import { useAtom, useAtomValue } from "jotai";

function Component() {
  const [selectedElements, setSelectedElements] = useAtom(selectedElementsAtom);
  const selectedIds = useAtomValue(selectedElementIdsAtom);
  
  const handleSelect = (element: ExcalidrawElement) => {
    setSelectedElements(prev => [...prev, element]);
  };
  
  return <div>{/* UI */}</div>;
}
```

## 5. 性能优化策略

### 5.1 渲染优化

```typescript
// 分层渲染策略
class Renderer {
  // 缓存静态场景
  private staticSceneCache: ImageData | null = null;
  private staticSceneVersion: number = -1;
  
  renderStaticScene(params: RenderStaticSceneParams) {
    const { elements, appState } = params;
    
    // 检查是否需要重新渲染
    const currentVersion = hashElementsVersion(elements);
    if (currentVersion === this.staticSceneVersion) {
      // 使用缓存
      if (this.staticSceneCache) {
        context.putImageData(this.staticSceneCache, 0, 0);
        return;
      }
    }
    
    // 重新渲染并缓存
    this.renderElements(elements, appState);
    this.staticSceneCache = context.getImageData(0, 0, width, height);
    this.staticSceneVersion = currentVersion;
  }
  
  // 只渲染变化的部分
  renderInteractiveScene(params: RenderInteractiveSceneParams) {
    const { selectedElements, hoveredElement } = params;
    
    // 清除画布
    context.clearRect(0, 0, width, height);
    
    // 只渲染需要交互效果的元素
    if (selectedElements.length > 0) {
      this.renderSelectionBorder(selectedElements);
    }
    
    if (hoveredElement) {
      this.renderHoverEffect(hoveredElement);
    }
  }
}
```

### 5.2 批量更新

```typescript
// 使用 React 18 的批量更新
import { flushSync } from "react-dom";

export const withBatchedUpdates = <T extends any[], R>(
  fn: (...args: T) => R
) => {
  return (...args: T): R => {
    // React 18 自动批量更新
    return fn(...args);
  };
};

// 节流批量更新
export const withBatchedUpdatesThrottled = <T extends any[]>(
  fn: (...args: T) => void
) => {
  let lastArgs: T | null = null;
  let rafId: number | null = null;
  
  return (...args: T) => {
    lastArgs = args;
    
    if (rafId === null) {
      rafId = requestAnimationFrame(() => {
        if (lastArgs) {
          fn(...lastArgs);
          lastArgs = null;
        }
        rafId = null;
      });
    }
  };
};
```

## 6. 插件系统架构

```typescript
// 插件接口定义
interface ExcalidrawPlugin {
  name: string;
  version: string;
  
  // 生命周期钩子
  onMount?: (api: ExcalidrawImperativeAPI) => void;
  onUnmount?: () => void;
  
  // 元素钩子
  onElementsChange?: (elements: ExcalidrawElement[]) => void;
  onElementCreate?: (element: ExcalidrawElement) => void;
  onElementUpdate?: (element: ExcalidrawElement) => void;
  onElementDelete?: (element: ExcalidrawElement) => void;
  
  // UI 扩展
  renderTopToolbar?: () => React.ReactNode;
  renderSidebar?: () => React.ReactNode;
  
  // 自定义动作
  actions?: Action[];
  
  // 自定义工具
  tools?: Tool[];
}

// 插件管理器
class PluginManager {
  private plugins: Map<string, ExcalidrawPlugin> = new Map();
  
  register(plugin: ExcalidrawPlugin) {
    if (this.plugins.has(plugin.name)) {
      console.warn(`Plugin ${plugin.name} already registered`);
      return;
    }
    
    this.plugins.set(plugin.name, plugin);
    
    // 注册动作
    plugin.actions?.forEach(action => {
      this.actionManager.registerAction(action);
    });
    
    // 注册工具
    plugin.tools?.forEach(tool => {
      this.toolManager.registerTool(tool);
    });
    
    // 调用挂载钩子
    plugin.onMount?.(this.api);
  }
  
  unregister(pluginName: string) {
    const plugin = this.plugins.get(pluginName);
    if (!plugin) return;
    
    // 调用卸载钩子
    plugin.onUnmount?.();
    
    this.plugins.delete(pluginName);
  }
  
  // 触发插件钩子
  triggerHook(hookName: string, ...args: any[]) {
    this.plugins.forEach(plugin => {
      const hook = plugin[hookName as keyof ExcalidrawPlugin];
      if (typeof hook === "function") {
        hook(...args);
      }
    });
  }
}
```

## 总结

Excalidraw 的架构设计体现了以下优秀实践：

1. **清晰的分层设计** - Model、View、Controller 职责分明
2. **组件化架构** - 每个功能模块都是独立的组件
3. **Context + Jotai** - 混合状态管理策略
4. **性能优先** - 分层渲染、缓存、批量更新
5. **可扩展性** - 插件系统、Action 系统
6. **TypeScript 类型安全** - 完整的类型定义

这种架构使得 Excalidraw 既能保持高性能，又能方便地进行功能扩展和二次开发。