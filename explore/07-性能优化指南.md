# Excalidraw 性能优化指南

## 目录
- [概述](#概述)
- [渲染性能优化](#渲染性能优化)
- [内存管理优化](#内存管理优化)
- [交互响应优化](#交互响应优化)
- [大规模数据处理](#大规模数据处理)
- [网络和协作优化](#网络和协作优化)
- [移动端优化](#移动端优化)
- [调试和监控工具](#调试和监控工具)
- [最佳实践总结](#最佳实践总结)

## 概述

Excalidraw 作为一个高性能的在线绘图应用，在处理大量图形元素、实时协作和复杂交互时面临诸多性能挑战。本指南详细介绍了 Excalidraw 中使用的各种性能优化技术和策略。

### 性能关键指标
- **渲染帧率 (FPS)**：目标 60fps 的流畅绘制体验
- **首屏加载时间**：< 2s 应用启动时间
- **交互延迟**：< 50ms 工具响应时间  
- **内存使用**：合理的内存占用和垃圾回收
- **网络延迟**：< 200ms 协作同步延迟

## 渲染性能优化

### 1. Canvas 分层渲染

```typescript
// 多层 Canvas 架构
interface CanvasLayers {
  static: HTMLCanvasElement;      // 静态元素层
  interactive: HTMLCanvasElement; // 交互元素层
  ui: HTMLCanvasElement;         // UI 控件层
  preview: HTMLCanvasElement;     // 预览层
}

class LayeredRenderer {
  private layers: CanvasLayers;
  private contexts: {
    static: CanvasRenderingContext2D;
    interactive: CanvasRenderingContext2D;
    ui: CanvasRenderingContext2D;
    preview: CanvasRenderingContext2D;
  };
  
  private staticNeedsRedraw = true;
  private interactiveNeedsRedraw = true;
  private uiNeedsRedraw = true;
  private previewNeedsRedraw = true;
  
  constructor(container: HTMLElement) {
    this.layers = this.createLayers(container);
    this.contexts = this.getContexts();
    this.setupLayerStyles();
  }
  
  private createLayers(container: HTMLElement): CanvasLayers {
    const createCanvas = (zIndex: number): HTMLCanvasElement => {
      const canvas = document.createElement('canvas');
      canvas.style.position = 'absolute';
      canvas.style.zIndex = zIndex.toString();
      canvas.style.pointerEvents = 'none';
      container.appendChild(canvas);
      return canvas;
    };
    
    return {
      static: createCanvas(1),
      interactive: createCanvas(2),
      ui: createCanvas(3),
      preview: createCanvas(4),
    };
  }
  
  // 渲染主循环
  render(
    elements: readonly ExcalidrawElement[],
    appState: AppState,
    renderConfig: RenderConfig
  ): void {
    // 只重绘需要更新的层
    if (this.staticNeedsRedraw) {
      this.renderStaticLayer(elements, appState, renderConfig);
      this.staticNeedsRedraw = false;
    }
    
    if (this.interactiveNeedsRedraw) {
      this.renderInteractiveLayer(elements, appState, renderConfig);
      this.interactiveNeedsRedraw = false;
    }
    
    if (this.uiNeedsRedraw) {
      this.renderUILayer(appState, renderConfig);
      this.uiNeedsRedraw = false;
    }
    
    if (this.previewNeedsRedraw) {
      this.renderPreviewLayer(appState, renderConfig);
      this.previewNeedsRedraw = false;
    }
  }
  
  // 渲染静态元素层
  private renderStaticLayer(
    elements: readonly ExcalidrawElement[],
    appState: AppState,
    renderConfig: RenderConfig
  ): void {
    const ctx = this.contexts.static;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    // 只渲染静态元素
    const staticElements = elements.filter(el => 
      !el.isDeleted && 
      !appState.selectedElementIds[el.id] &&
      !this.isElementAnimating(el)
    );
    
    this.renderElements(ctx, staticElements, appState, renderConfig);
  }
  
  // 渲染交互元素层
  private renderInteractiveLayer(
    elements: readonly ExcalidrawElement[],
    appState: AppState,
    renderConfig: RenderConfig
  ): void {
    const ctx = this.contexts.interactive;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    // 渲染选中和正在编辑的元素
    const interactiveElements = elements.filter(el =>
      !el.isDeleted && (
        appState.selectedElementIds[el.id] ||
        appState.editingElement?.id === el.id ||
        this.isElementAnimating(el)
      )
    );
    
    this.renderElements(ctx, interactiveElements, appState, renderConfig);
    this.renderSelectionHandles(ctx, appState);
  }
  
  // 标记层需要重绘
  markStaticLayerDirty(): void { this.staticNeedsRedraw = true; }
  markInteractiveLayerDirty(): void { this.interactiveNeedsRedraw = true; }
  markUILayerDirty(): void { this.uiNeedsRedraw = true; }
  markPreviewLayerDirty(): void { this.previewNeedsRedraw = true; }
}
```

### 2. 视口裁剪和虚拟化

```typescript
// 视口裁剪优化
class ViewportCulling {
  private static CULLING_MARGIN = 100; // 额外渲染区域
  
  static getVisibleElements(
    elements: readonly ExcalidrawElement[],
    viewport: {
      x: number;
      y: number;
      width: number;
      height: number;
      zoom: number;
    }
  ): readonly ExcalidrawElement[] {
    const viewBounds = this.getViewportBounds(viewport);
    
    return elements.filter(element => {
      if (element.isDeleted) return false;
      
      const elementBounds = getElementAbsoluteCoords(element);
      return this.boundsIntersect(viewBounds, elementBounds);
    });
  }
  
  private static getViewportBounds(viewport: any): Bounds {
    const margin = this.CULLING_MARGIN;
    return [
      viewport.x - margin,
      viewport.y - margin,
      viewport.x + viewport.width / viewport.zoom + margin,
      viewport.y + viewport.height / viewport.zoom + margin,
    ];
  }
  
  private static boundsIntersect(bounds1: Bounds, bounds2: Bounds): boolean {
    const [x1, y1, x1_2, y1_2] = bounds1;
    const [x2, y2, x2_2, y2_2] = bounds2;
    
    return !(x1_2 < x2 || x2_2 < x1 || y1_2 < y2 || y2_2 < y1);
  }
}

// 虚拟滚动实现
class VirtualScrollManager {
  private visibleItems = new Set<string>();
  private itemPool = new Map<string, HTMLElement>();
  
  updateVisibleItems(
    items: readonly { id: string; bounds: Bounds }[],
    viewport: Bounds
  ): void {
    const newVisibleItems = new Set<string>();
    
    items.forEach(item => {
      if (ViewportCulling['boundsIntersect'](viewport, item.bounds)) {
        newVisibleItems.add(item.id);
      }
    });
    
    // 移除不可见的元素
    this.visibleItems.forEach(id => {
      if (!newVisibleItems.has(id)) {
        this.recycleItem(id);
      }
    });
    
    // 添加新可见的元素
    newVisibleItems.forEach(id => {
      if (!this.visibleItems.has(id)) {
        this.createItem(id);
      }
    });
    
    this.visibleItems = newVisibleItems;
  }
  
  private createItem(id: string): void {
    // 从池中获取或创建新元素
    let element = this.itemPool.get(id);
    if (!element) {
      element = this.createElement(id);
      this.itemPool.set(id, element);
    }
    
    // 显示元素
    element.style.display = 'block';
  }
  
  private recycleItem(id: string): void {
    const element = this.itemPool.get(id);
    if (element) {
      element.style.display = 'none';
    }
  }
  
  private createElement(id: string): HTMLElement {
    // 实现元素创建逻辑
    const element = document.createElement('div');
    element.className = 'virtual-item';
    return element;
  }
}
```

### 3. 渲染缓存和批处理

```typescript
// 渲染缓存系统
class RenderCache {
  private cache = new Map<string, {
    canvas: HTMLCanvasElement;
    timestamp: number;
    hash: string;
  }>();
  
  private maxCacheSize = 1000;
  private cacheTimeout = 30000; // 30秒缓存过期
  
  // 获取元素缓存
  getElementCache(
    element: ExcalidrawElement,
    renderConfig: RenderConfig
  ): HTMLCanvasElement | null {
    const cacheKey = this.getCacheKey(element, renderConfig);
    const cached = this.cache.get(cacheKey);
    
    if (cached && this.isCacheValid(cached, element)) {
      // 更新访问时间
      cached.timestamp = Date.now();
      return cached.canvas;
    }
    
    return null;
  }
  
  // 设置元素缓存
  setElementCache(
    element: ExcalidrawElement,
    renderConfig: RenderConfig,
    canvas: HTMLCanvasElement
  ): void {
    const cacheKey = this.getCacheKey(element, renderConfig);
    const hash = this.getElementHash(element);
    
    // 清理过期缓存
    this.cleanupExpiredCache();
    
    // 限制缓存大小
    if (this.cache.size >= this.maxCacheSize) {
      this.evictOldestCache();
    }
    
    this.cache.set(cacheKey, {
      canvas: this.cloneCanvas(canvas),
      timestamp: Date.now(),
      hash,
    });
  }
  
  private getCacheKey(element: ExcalidrawElement, config: RenderConfig): string {
    return `${element.id}-${config.zoom}-${config.devicePixelRatio}`;
  }
  
  private getElementHash(element: ExcalidrawElement): string {
    // 基于元素关键属性生成哈希
    const keyProps = {
      version: element.version,
      x: element.x,
      y: element.y,
      width: element.width,
      height: element.height,
      angle: element.angle,
      strokeColor: element.strokeColor,
      backgroundColor: element.backgroundColor,
      // ... 其他相关属性
    };
    
    return hashObject(keyProps);
  }
  
  private isCacheValid(cached: any, element: ExcalidrawElement): boolean {
    const now = Date.now();
    const isExpired = now - cached.timestamp > this.cacheTimeout;
    const hashChanged = cached.hash !== this.getElementHash(element);
    
    return !isExpired && !hashChanged;
  }
  
  private cleanupExpiredCache(): void {
    const now = Date.now();
    const expired: string[] = [];
    
    this.cache.forEach((cached, key) => {
      if (now - cached.timestamp > this.cacheTimeout) {
        expired.push(key);
      }
    });
    
    expired.forEach(key => this.cache.delete(key));
  }
  
  private evictOldestCache(): void {
    let oldestKey: string | null = null;
    let oldestTime = Infinity;
    
    this.cache.forEach((cached, key) => {
      if (cached.timestamp < oldestTime) {
        oldestTime = cached.timestamp;
        oldestKey = key;
      }
    });
    
    if (oldestKey) {
      this.cache.delete(oldestKey);
    }
  }
  
  private cloneCanvas(source: HTMLCanvasElement): HTMLCanvasElement {
    const clone = document.createElement('canvas');
    clone.width = source.width;
    clone.height = source.height;
    
    const ctx = clone.getContext('2d')!;
    ctx.drawImage(source, 0, 0);
    
    return clone;
  }
}

// 渲染批处理
class BatchRenderer {
  private renderQueue: Array<{
    element: ExcalidrawElement;
    priority: number;
    timestamp: number;
  }> = [];
  
  private isRendering = false;
  
  // 添加到渲染队列
  queueRender(element: ExcalidrawElement, priority = 0): void {
    const existingIndex = this.renderQueue.findIndex(
      item => item.element.id === element.id
    );
    
    const renderItem = {
      element,
      priority,
      timestamp: Date.now(),
    };
    
    if (existingIndex !== -1) {
      // 更新现有项目
      this.renderQueue[existingIndex] = renderItem;
    } else {
      // 添加新项目
      this.renderQueue.push(renderItem);
    }
    
    // 触发渲染
    this.scheduleRender();
  }
  
  private scheduleRender(): void {
    if (this.isRendering) return;
    
    requestAnimationFrame(() => {
      this.processRenderQueue();
    });
  }
  
  private processRenderQueue(): void {
    this.isRendering = true;
    
    try {
      // 按优先级和时间戳排序
      this.renderQueue.sort((a, b) => {
        if (a.priority !== b.priority) {
          return b.priority - a.priority; // 高优先级优先
        }
        return a.timestamp - b.timestamp; // 早提交的优先
      });
      
      // 批量处理渲染
      const batchSize = 10; // 每帧处理的元素数量
      const batch = this.renderQueue.splice(0, batchSize);
      
      batch.forEach(item => {
        this.renderElement(item.element);
      });
      
      // 如果还有待处理的元素，继续下一帧
      if (this.renderQueue.length > 0) {
        this.scheduleRender();
      }
    } finally {
      this.isRendering = false;
    }
  }
  
  private renderElement(element: ExcalidrawElement): void {
    // 实际的元素渲染逻辑
    console.log(`Rendering element ${element.id}`);
  }
}
```

## 内存管理优化

### 1. 对象池和内存复用

```typescript
// 通用对象池
class ObjectPool<T> {
  private pool: T[] = [];
  private createFn: () => T;
  private resetFn: (obj: T) => void;
  private maxSize: number;
  
  constructor(
    createFn: () => T,
    resetFn: (obj: T) => void,
    maxSize = 100
  ) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    this.maxSize = maxSize;
  }
  
  acquire(): T {
    if (this.pool.length > 0) {
      return this.pool.pop()!;
    }
    return this.createFn();
  }
  
  release(obj: T): void {
    if (this.pool.length < this.maxSize) {
      this.resetFn(obj);
      this.pool.push(obj);
    }
  }
  
  clear(): void {
    this.pool.length = 0;
  }
  
  size(): number {
    return this.pool.length;
  }
}

// 点对象池
const pointPool = new ObjectPool<Point>(
  () => ({ x: 0, y: 0 }),
  (point) => {
    point.x = 0;
    point.y = 0;
  },
  1000
);

// 边界对象池
const boundsPool = new ObjectPool<Bounds>(
  () => [0, 0, 0, 0],
  (bounds) => {
    bounds[0] = bounds[1] = bounds[2] = bounds[3] = 0;
  },
  500
);

// 内存优化的几何计算
class OptimizedGeometry {
  // 重用点对象进行计算
  static getElementBounds(element: ExcalidrawElement): Bounds {
    const bounds = boundsPool.acquire();
    
    try {
      // 计算边界
      bounds[0] = element.x;
      bounds[1] = element.y;
      bounds[2] = element.x + element.width;
      bounds[3] = element.y + element.height;
      
      // 返回拷贝的边界（避免返回池对象）
      return [bounds[0], bounds[1], bounds[2], bounds[3]];
    } finally {
      boundsPool.release(bounds);
    }
  }
  
  // 重用点对象进行变换
  static transformPoint(
    point: Point,
    transform: Transform,
    result?: Point
  ): Point {
    const workPoint = result || pointPool.acquire();
    
    try {
      workPoint.x = point.x * transform.scaleX + transform.translateX;
      workPoint.y = point.y * transform.scaleY + transform.translateY;
      
      if (!result) {
        // 如果没有提供结果对象，返回新对象并释放工作对象
        const returnPoint = { x: workPoint.x, y: workPoint.y };
        pointPool.release(workPoint);
        return returnPoint;
      }
      
      return workPoint;
    } catch (error) {
      if (!result) {
        pointPool.release(workPoint);
      }
      throw error;
    }
  }
}
```

### 2. 内存监控和垃圾回收

```typescript
// 内存监控器
class MemoryMonitor {
  private memoryThreshold = 50 * 1024 * 1024; // 50MB
  private checkInterval = 5000; // 5秒检查一次
  private timer: number | null = null;
  
  private callbacks: Array<(memoryInfo: any) => void> = [];
  
  start(): void {
    if (this.timer) return;
    
    this.timer = window.setInterval(() => {
      this.checkMemoryUsage();
    }, this.checkInterval);
  }
  
  stop(): void {
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }
  }
  
  onMemoryWarning(callback: (memoryInfo: any) => void): () => void {
    this.callbacks.push(callback);
    return () => {
      const index = this.callbacks.indexOf(callback);
      if (index !== -1) {
        this.callbacks.splice(index, 1);
      }
    };
  }
  
  private checkMemoryUsage(): void {
    if ('memory' in performance) {
      const memoryInfo = (performance as any).memory;
      
      if (memoryInfo.usedJSHeapSize > this.memoryThreshold) {
        this.callbacks.forEach(callback => {
          try {
            callback(memoryInfo);
          } catch (error) {
            console.error('Memory warning callback error:', error);
          }
        });
      }
    }
  }
  
  // 获取当前内存使用情况
  getMemoryInfo(): any {
    if ('memory' in performance) {
      return (performance as any).memory;
    }
    return null;
  }
}

// 智能垃圾回收
class GarbageCollector {
  private weakRefs = new Set<WeakRef<any>>();
  private cleanupCallbacks = new Map<any, () => void>();
  
  // 注册对象进行自动清理
  register<T extends object>(
    target: T,
    cleanup?: () => void
  ): WeakRef<T> {
    const weakRef = new WeakRef(target);
    this.weakRefs.add(weakRef);
    
    if (cleanup) {
      this.cleanupCallbacks.set(target, cleanup);
    }
    
    return weakRef;
  }
  
  // 执行清理
  cleanup(): void {
    const deadRefs: WeakRef<any>[] = [];
    
    this.weakRefs.forEach(ref => {
      const target = ref.deref();
      if (target === undefined) {
        deadRefs.push(ref);
      }
    });
    
    // 移除死引用
    deadRefs.forEach(ref => {
      this.weakRefs.delete(ref);
    });
    
    // 执行清理回调
    this.cleanupCallbacks.forEach((cleanup, target) => {
      if (target === null || target === undefined) {
        cleanup();
        this.cleanupCallbacks.delete(target);
      }
    });
    
    console.log(`Cleaned up ${deadRefs.length} dead references`);
  }
  
  // 强制垃圾回收（如果可用）
  forceGC(): void {
    if ('gc' in window && typeof window.gc === 'function') {
      window.gc();
    }
  }
}

// 内存泄漏检测器
class MemoryLeakDetector {
  private snapshots: Array<{
    timestamp: number;
    elementCount: number;
    memoryUsage?: number;
  }> = [];
  
  takeSnapshot(elementCount: number): void {
    const snapshot = {
      timestamp: Date.now(),
      elementCount,
      memoryUsage: this.getMemoryUsage(),
    };
    
    this.snapshots.push(snapshot);
    
    // 只保留最近的20个快照
    if (this.snapshots.length > 20) {
      this.snapshots.shift();
    }
  }
  
  detectLeaks(): {
    hasLeak: boolean;
    reason?: string;
    recommendation?: string;
  } {
    if (this.snapshots.length < 5) {
      return { hasLeak: false };
    }
    
    const recent = this.snapshots.slice(-5);
    const memoryGrowth = this.analyzeMemoryGrowth(recent);
    const elementGrowth = this.analyzeElementGrowth(recent);
    
    // 检测内存持续增长
    if (memoryGrowth.trend === 'increasing' && memoryGrowth.rate > 0.1) {
      return {
        hasLeak: true,
        reason: 'Memory usage continuously increasing',
        recommendation: 'Check for unreleased event listeners or cached objects',
      };
    }
    
    // 检测元素数量与内存使用不成比例增长
    if (elementGrowth.trend === 'stable' && memoryGrowth.trend === 'increasing') {
      return {
        hasLeak: true,
        reason: 'Memory growing without element count increase',
        recommendation: 'Check for memory leaks in rendering or event handling',
      };
    }
    
    return { hasLeak: false };
  }
  
  private getMemoryUsage(): number | undefined {
    if ('memory' in performance) {
      return (performance as any).memory.usedJSHeapSize;
    }
    return undefined;
  }
  
  private analyzeMemoryGrowth(snapshots: any[]): {
    trend: 'increasing' | 'decreasing' | 'stable';
    rate: number;
  } {
    if (snapshots.length < 2) {
      return { trend: 'stable', rate: 0 };
    }
    
    const first = snapshots[0];
    const last = snapshots[snapshots.length - 1];
    
    if (!first.memoryUsage || !last.memoryUsage) {
      return { trend: 'stable', rate: 0 };
    }
    
    const growthRate = (last.memoryUsage - first.memoryUsage) / first.memoryUsage;
    
    if (growthRate > 0.05) {
      return { trend: 'increasing', rate: growthRate };
    } else if (growthRate < -0.05) {
      return { trend: 'decreasing', rate: Math.abs(growthRate) };
    } else {
      return { trend: 'stable', rate: Math.abs(growthRate) };
    }
  }
  
  private analyzeElementGrowth(snapshots: any[]): {
    trend: 'increasing' | 'decreasing' | 'stable';
    rate: number;
  } {
    if (snapshots.length < 2) {
      return { trend: 'stable', rate: 0 };
    }
    
    const first = snapshots[0];
    const last = snapshots[snapshots.length - 1];
    
    const growthRate = (last.elementCount - first.elementCount) / (first.elementCount || 1);
    
    if (growthRate > 0.1) {
      return { trend: 'increasing', rate: growthRate };
    } else if (growthRate < -0.1) {
      return { trend: 'decreasing', rate: Math.abs(growthRate) };
    } else {
      return { trend: 'stable', rate: Math.abs(growthRate) };
    }
  }
}
```

## 交互响应优化

### 1. 事件节流和防抖

```typescript
// 高级节流器
class AdvancedThrottler {
  private timers = new Map<string, number>();
  private lastExecution = new Map<string, number>();
  
  // 自适应节流
  throttleAdaptive<T extends (...args: any[]) => void>(
    key: string,
    fn: T,
    minDelay: number,
    maxDelay: number,
    load: () => number // 返回0-1之间的负载值
  ): T {
    return ((...args: any[]) => {
      const now = Date.now();
      const lastTime = this.lastExecution.get(key) || 0;
      const currentLoad = Math.max(0, Math.min(1, load()));
      
      // 根据负载动态调整延迟
      const delay = minDelay + (maxDelay - minDelay) * currentLoad;
      
      if (now - lastTime >= delay) {
        this.lastExecution.set(key, now);
        fn.apply(this, args);
      } else {
        // 更新定时器
        const existingTimer = this.timers.get(key);
        if (existingTimer) {
          clearTimeout(existingTimer);
        }
        
        const timer = window.setTimeout(() => {
          this.lastExecution.set(key, Date.now());
          fn.apply(this, args);
          this.timers.delete(key);
        }, delay - (now - lastTime));
        
        this.timers.set(key, timer);
      }
    }) as T;
  }
  
  // 基于帧率的节流
  throttleByFrameRate<T extends (...args: any[]) => void>(
    key: string,
    fn: T,
    targetFPS = 60
  ): T {
    const frameTime = 1000 / targetFPS;
    
    return this.throttleAdaptive(
      key,
      fn,
      frameTime,
      frameTime * 2,
      () => this.getCurrentLoad()
    );
  }
  
  private getCurrentLoad(): number {
    // 简单的负载估算，可以基于更复杂的指标
    const now = performance.now();
    const recentExecutions = Array.from(this.lastExecution.values())
      .filter(time => now - time < 1000);
    
    return Math.min(1, recentExecutions.length / 60);
  }
}

// 智能防抖
class SmartDebouncer {
  private timers = new Map<string, number>();
  private callCounts = new Map<string, number>();
  
  // 自适应防抖 - 频繁调用时增加延迟
  debounceAdaptive<T extends (...args: any[]) => void>(
    key: string,
    fn: T,
    baseDelay: number,
    maxDelay: number = baseDelay * 5
  ): T {
    return ((...args: any[]) => {
      const existingTimer = this.timers.get(key);
      if (existingTimer) {
        clearTimeout(existingTimer);
      }
      
      // 增加调用计数
      const currentCount = (this.callCounts.get(key) || 0) + 1;
      this.callCounts.set(key, currentCount);
      
      // 根据调用频率调整延迟
      const delay = Math.min(
        maxDelay,
        baseDelay * Math.log(currentCount + 1)
      );
      
      const timer = window.setTimeout(() => {
        fn.apply(this, args);
        this.timers.delete(key);
        this.callCounts.set(key, 0);
      }, delay);
      
      this.timers.set(key, timer);
    }) as T;
  }
  
  // 立即执行 + 防抖
  debounceImmediate<T extends (...args: any[]) => void>(
    key: string,
    fn: T,
    delay: number
  ): T {
    return ((...args: any[]) => {
      const existingTimer = this.timers.get(key);
      
      if (!existingTimer) {
        // 立即执行第一次
        fn.apply(this, args);
      } else {
        clearTimeout(existingTimer);
      }
      
      const timer = window.setTimeout(() => {
        this.timers.delete(key);
      }, delay);
      
      this.timers.set(key, timer);
    }) as T;
  }
}
```

### 2. 交互状态机优化

```typescript
// 高性能状态机
class PerformantStateMachine<TState extends string, TEvent> {
  private currentState: TState;
  private transitions: Map<string, (event: TEvent) => TState | null>;
  private stateActions: Map<TState, {
    onEnter?: (event?: TEvent) => void;
    onExit?: (event?: TEvent) => void;
  }>;
  private eventQueue: TEvent[] = [];
  private isProcessing = false;
  
  constructor(initialState: TState) {
    this.currentState = initialState;
    this.transitions = new Map();
    this.stateActions = new Map();
  }
  
  // 批量处理事件
  processEvent(event: TEvent): void {
    this.eventQueue.push(event);
    
    if (!this.isProcessing) {
      this.scheduleProcessing();
    }
  }
  
  private scheduleProcessing(): void {
    this.isProcessing = true;
    
    requestAnimationFrame(() => {
      this.processBatch();
    });
  }
  
  private processBatch(): void {
    const batchSize = 10; // 每帧处理的事件数量
    let processed = 0;
    
    while (this.eventQueue.length > 0 && processed < batchSize) {
      const event = this.eventQueue.shift()!;
      this.processEventSync(event);
      processed++;
    }
    
    if (this.eventQueue.length > 0) {
      // 还有事件要处理，继续下一帧
      this.scheduleProcessing();
    } else {
      this.isProcessing = false;
    }
  }
  
  private processEventSync(event: TEvent): void {
    const key = `${this.currentState}`;
    const transitionFn = this.transitions.get(key);
    
    if (!transitionFn) return;
    
    const nextState = transitionFn(event);
    if (nextState && nextState !== this.currentState) {
      this.transitionTo(nextState, event);
    }
  }
  
  private transitionTo(nextState: TState, event: TEvent): void {
    const currentActions = this.stateActions.get(this.currentState);
    const nextActions = this.stateActions.get(nextState);
    
    // 执行退出动作
    if (currentActions?.onExit) {
      currentActions.onExit(event);
    }
    
    const prevState = this.currentState;
    this.currentState = nextState;
    
    // 执行进入动作
    if (nextActions?.onEnter) {
      nextActions.onEnter(event);
    }
  }
  
  getCurrentState(): TState {
    return this.currentState;
  }
}

// 工具切换状态机
type ToolState = 'idle' | 'selecting' | 'drawing' | 'dragging' | 'resizing';
type ToolEvent = 
  | { type: 'POINTER_DOWN'; pointer: Point; element?: ExcalidrawElement }
  | { type: 'POINTER_MOVE'; pointer: Point }
  | { type: 'POINTER_UP'; pointer: Point }
  | { type: 'KEY_DOWN'; key: string }
  | { type: 'TOOL_CHANGE'; tool: ToolType };

class ToolStateMachine extends PerformantStateMachine<ToolState, ToolEvent> {
  constructor(private app: App) {
    super('idle');
    this.setupTransitions();
  }
  
  private setupTransitions(): void {
    // idle -> selecting
    this.addTransition('idle', (event) => {
      if (event.type === 'POINTER_DOWN' && event.element) {
        return 'selecting';
      }
      return null;
    });
    
    // idle -> drawing
    this.addTransition('idle', (event) => {
      if (event.type === 'POINTER_DOWN' && !event.element) {
        const tool = this.app.state.activeTool;
        if (tool.type !== 'selection') {
          return 'drawing';
        }
      }
      return null;
    });
    
    // selecting -> dragging
    this.addTransition('selecting', (event) => {
      if (event.type === 'POINTER_MOVE') {
        return 'dragging';
      }
      return null;
    });
    
    // ... 其他转换规则
  }
  
  private addTransition(
    fromState: ToolState,
    transitionFn: (event: ToolEvent) => ToolState | null
  ): void {
    this.transitions.set(fromState, transitionFn);
  }
}
```

## 大规模数据处理

### 1. 数据结构优化

```typescript
// 空间索引 - 四叉树
class QuadTree {
  private static MAX_OBJECTS = 10;
  private static MAX_LEVELS = 5;
  
  private level: number;
  private bounds: Bounds;
  private objects: Array<{ id: string; bounds: Bounds }> = [];
  private nodes: QuadTree[] = [];
  
  constructor(bounds: Bounds, level = 0) {
    this.bounds = bounds;
    this.level = level;
  }
  
  // 插入对象
  insert(object: { id: string; bounds: Bounds }): void {
    if (this.nodes.length > 0) {
      const index = this.getIndex(object.bounds);
      if (index !== -1) {
        this.nodes[index].insert(object);
        return;
      }
    }
    
    this.objects.push(object);
    
    if (this.objects.length > QuadTree.MAX_OBJECTS && 
        this.level < QuadTree.MAX_LEVELS) {
      if (this.nodes.length === 0) {
        this.split();
      }
      
      let i = 0;
      while (i < this.objects.length) {
        const index = this.getIndex(this.objects[i].bounds);
        if (index !== -1) {
          const obj = this.objects.splice(i, 1)[0];
          this.nodes[index].insert(obj);
        } else {
          i++;
        }
      }
    }
  }
  
  // 查询区域内的对象
  query(bounds: Bounds): Array<{ id: string; bounds: Bounds }> {
    const result: Array<{ id: string; bounds: Bounds }> = [];
    
    // 检查当前节点的对象
    for (const obj of this.objects) {
      if (this.intersects(bounds, obj.bounds)) {
        result.push(obj);
      }
    }
    
    // 递归检查子节点
    if (this.nodes.length > 0) {
      const index = this.getIndex(bounds);
      if (index !== -1) {
        result.push(...this.nodes[index].query(bounds));
      } else {
        // 跨越多个象限，检查所有子节点
        for (const node of this.nodes) {
          if (this.intersects(bounds, node.bounds)) {
            result.push(...node.query(bounds));
          }
        }
      }
    }
    
    return result;
  }
  
  private split(): void {
    const subWidth = (this.bounds[2] - this.bounds[0]) / 2;
    const subHeight = (this.bounds[3] - this.bounds[1]) / 2;
    const x = this.bounds[0];
    const y = this.bounds[1];
    
    // 创建四个子节点
    this.nodes = [
      new QuadTree([x + subWidth, y, x + subWidth * 2, y + subHeight], this.level + 1),
      new QuadTree([x, y, x + subWidth, y + subHeight], this.level + 1),
      new QuadTree([x, y + subHeight, x + subWidth, y + subHeight * 2], this.level + 1),
      new QuadTree([x + subWidth, y + subHeight, x + subWidth * 2, y + subHeight * 2], this.level + 1)
    ];
  }
  
  private getIndex(bounds: Bounds): number {
    const [x1, y1, x2, y2] = bounds;
    const midX = (this.bounds[0] + this.bounds[2]) / 2;
    const midY = (this.bounds[1] + this.bounds[3]) / 2;
    
    const topQuadrant = y1 < midY && y2 < midY;
    const bottomQuadrant = y1 > midY;
    
    if (x1 < midX && x2 < midX) {
      if (topQuadrant) return 1;
      if (bottomQuadrant) return 2;
    } else if (x1 > midX) {
      if (topQuadrant) return 0;
      if (bottomQuadrant) return 3;
    }
    
    return -1; // 跨越多个象限
  }
  
  private intersects(bounds1: Bounds, bounds2: Bounds): boolean {
    const [x1, y1, x1_2, y1_2] = bounds1;
    const [x2, y2, x2_2, y2_2] = bounds2;
    
    return !(x1_2 < x2 || x2_2 < x1 || y1_2 < y2 || y2_2 < y1);
  }
  
  // 清空四叉树
  clear(): void {
    this.objects.length = 0;
    this.nodes.length = 0;
  }
  
  // 获取统计信息
  getStats(): {
    totalObjects: number;
    totalNodes: number;
    maxDepth: number;
  } {
    let totalObjects = this.objects.length;
    let totalNodes = 1;
    let maxDepth = this.level;
    
    for (const node of this.nodes) {
      const stats = node.getStats();
      totalObjects += stats.totalObjects;
      totalNodes += stats.totalNodes;
      maxDepth = Math.max(maxDepth, stats.maxDepth);
    }
    
    return { totalObjects, totalNodes, maxDepth };
  }
}

// 优化的元素管理器
class OptimizedElementManager {
  private elements: Map<string, ExcalidrawElement> = new Map();
  private spatialIndex: QuadTree;
  private dirtyElements = new Set<string>();
  
  constructor(canvasBounds: Bounds) {
    this.spatialIndex = new QuadTree(canvasBounds);
  }
  
  // 添加元素
  addElement(element: ExcalidrawElement): void {
    this.elements.set(element.id, element);
    this.spatialIndex.insert({
      id: element.id,
      bounds: getElementAbsoluteCoords(element)
    });
  }
  
  // 更新元素
  updateElement(element: ExcalidrawElement): void {
    if (this.elements.has(element.id)) {
      this.elements.set(element.id, element);
      this.dirtyElements.add(element.id);
    }
  }
  
  // 批量更新空间索引
  updateSpatialIndex(): void {
    if (this.dirtyElements.size === 0) return;
    
    // 重建空间索引（对于大量更新更高效）
    if (this.dirtyElements.size > this.elements.size * 0.5) {
      this.rebuildSpatialIndex();
    } else {
      // 增量更新
      for (const elementId of this.dirtyElements) {
        const element = this.elements.get(elementId);
        if (element) {
          // 简化：直接重插入
          // 实际实现中应该先删除旧的位置
          this.spatialIndex.insert({
            id: element.id,
            bounds: getElementAbsoluteCoords(element)
          });
        }
      }
    }
    
    this.dirtyElements.clear();
  }
  
  private rebuildSpatialIndex(): void {
    this.spatialIndex.clear();
    
    for (const element of this.elements.values()) {
      if (!element.isDeleted) {
        this.spatialIndex.insert({
          id: element.id,
          bounds: getElementAbsoluteCoords(element)
        });
      }
    }
  }
  
  // 查询指定区域的元素
  getElementsInBounds(bounds: Bounds): ExcalidrawElement[] {
    const candidates = this.spatialIndex.query(bounds);
    const result: ExcalidrawElement[] = [];
    
    for (const candidate of candidates) {
      const element = this.elements.get(candidate.id);
      if (element && !element.isDeleted) {
        result.push(element);
      }
    }
    
    return result;
  }
  
  // 获取所有元素
  getAllElements(): ExcalidrawElement[] {
    return Array.from(this.elements.values()).filter(el => !el.isDeleted);
  }
  
  // 删除元素
  deleteElement(elementId: string): void {
    const element = this.elements.get(elementId);
    if (element) {
      this.elements.set(elementId, { ...element, isDeleted: true });
      this.dirtyElements.add(elementId);
    }
  }
  
  // 获取统计信息
  getStats() {
    return {
      totalElements: this.elements.size,
      activeElements: this.getAllElements().length,
      dirtyElements: this.dirtyElements.size,
      spatialIndexStats: this.spatialIndex.getStats(),
    };
  }
}
```

### 2. 数据分块和流式处理

```typescript
// 数据分块处理器
class ChunkedDataProcessor {
  private chunkSize: number;
  private processingQueue: Array<{
    data: any[];
    processor: (chunk: any[]) => Promise<any>;
    resolve: (result: any[]) => void;
    reject: (error: Error) => void;
  }> = [];
  private isProcessing = false;
  
  constructor(chunkSize = 100) {
    this.chunkSize = chunkSize;
  }
  
  // 分块处理数据
  async processInChunks<T, R>(
    data: T[],
    processor: (chunk: T[]) => Promise<R>
  ): Promise<R[]> {
    return new Promise((resolve, reject) => {
      this.processingQueue.push({
        data,
        processor,
        resolve,
        reject,
      });
      
      this.scheduleProcessing();
    });
  }
  
  private scheduleProcessing(): void {
    if (this.isProcessing || this.processingQueue.length === 0) {
      return;
    }
    
    this.isProcessing = true;
    requestAnimationFrame(() => {
      this.processNextBatch();
    });
  }
  
  private async processNextBatch(): Promise<void> {
    if (this.processingQueue.length === 0) {
      this.isProcessing = false;
      return;
    }
    
    const task = this.processingQueue.shift()!;
    const { data, processor, resolve, reject } = task;
    
    try {
      const results: any[] = [];
      let index = 0;
      
      const processChunk = async (): Promise<void> => {
        if (index >= data.length) {
          resolve(results);
          this.scheduleProcessing(); // 处理下一个任务
          return;
        }
        
        const chunk = data.slice(index, index + this.chunkSize);
        const result = await processor(chunk);
        results.push(result);
        
        index += this.chunkSize;
        
        // 在下一帧继续处理
        requestAnimationFrame(processChunk);
      };
      
      await processChunk();
    } catch (error) {
      reject(error instanceof Error ? error : new Error(String(error)));
      this.scheduleProcessing();
    }
  }
}

// 流式数据加载器
class StreamingDataLoader {
  private loadedChunks = new Map<string, any>();
  private loadingPromises = new Map<string, Promise<any>>();
  
  // 流式加载大文件
  async loadLargeFile(
    file: File,
    chunkSize = 1024 * 1024 // 1MB chunks
  ): Promise<{
    metadata: any;
    getChunk: (index: number) => Promise<ArrayBuffer>;
    totalChunks: number;
  }> {
    const totalChunks = Math.ceil(file.size / chunkSize);
    
    // 加载元数据（第一个块）
    const firstChunk = await this.loadChunk(file, 0, Math.min(chunkSize, file.size));
    const metadata = this.parseMetadata(firstChunk);
    
    return {
      metadata,
      totalChunks,
      getChunk: (index: number) => this.loadChunk(file, index * chunkSize, chunkSize),
    };
  }
  
  private async loadChunk(
    file: File,
    offset: number,
    size: number
  ): Promise<ArrayBuffer> {
    const chunkKey = `${file.name}-${offset}-${size}`;
    
    // 检查缓存
    if (this.loadedChunks.has(chunkKey)) {
      return this.loadedChunks.get(chunkKey);
    }
    
    // 检查正在加载的请求
    if (this.loadingPromises.has(chunkKey)) {
      return this.loadingPromises.get(chunkKey);
    }
    
    // 创建加载Promise
    const loadPromise = this.loadChunkFromFile(file, offset, size);
    this.loadingPromises.set(chunkKey, loadPromise);
    
    try {
      const data = await loadPromise;
      this.loadedChunks.set(chunkKey, data);
      return data;
    } finally {
      this.loadingPromises.delete(chunkKey);
    }
  }
  
  private loadChunkFromFile(
    file: File,
    offset: number,
    size: number
  ): Promise<ArrayBuffer> {
    return new Promise((resolve, reject) => {
      const slice = file.slice(offset, offset + size);
      const reader = new FileReader();
      
      reader.onload = () => {
        resolve(reader.result as ArrayBuffer);
      };
      
      reader.onerror = () => {
        reject(new Error('Failed to read file chunk'));
      };
      
      reader.readAsArrayBuffer(slice);
    });
  }
  
  private parseMetadata(firstChunk: ArrayBuffer): any {
    // 根据文件格式解析元数据
    try {
      const text = new TextDecoder().decode(firstChunk);
      // 简化的 JSON 元数据解析
      const lines = text.split('\n');
      const metadataLine = lines.find(line => line.startsWith('// metadata:'));
      if (metadataLine) {
        return JSON.parse(metadataLine.substring(12));
      }
    } catch (error) {
      console.warn('Failed to parse metadata:', error);
    }
    
    return {};
  }
  
  // 清理缓存
  clearCache(maxAge = 300000): void { // 5分钟
    const now = Date.now();
    const keysToDelete: string[] = [];
    
    this.loadedChunks.forEach((chunk, key) => {
      if (chunk.timestamp && now - chunk.timestamp > maxAge) {
        keysToDelete.push(key);
      }
    });
    
    keysToDelete.forEach(key => {
      this.loadedChunks.delete(key);
    });
  }
}
```

## 网络和协作优化

### 1. 增量同步和压缩

```typescript
// 增量同步管理器
class IncrementalSyncManager {
  private lastKnownVersion = 0;
  private pendingChanges: Map<string, ElementChange> = new Map();
  private compressionEnabled = true;
  
  // 计算增量变更
  computeIncrementalChanges(
    oldElements: readonly ExcalidrawElement[],
    newElements: readonly ExcalidrawElement[]
  ): IncrementalUpdate {
    const changes: ElementChange[] = [];
    const oldElementsMap = new Map(oldElements.map(el => [el.id, el]));
    const newElementsMap = new Map(newElements.map(el => [el.id, el]));
    
    // 检查新增和修改的元素
    for (const newElement of newElements) {
      const oldElement = oldElementsMap.get(newElement.id);
      
      if (!oldElement) {
        // 新增元素
        changes.push({
          type: 'create',
          elementId: newElement.id,
          element: newElement,
        });
      } else if (newElement.versionNonce !== oldElement.versionNonce) {
        // 修改元素 - 只发送变更的属性
        const delta = this.computeElementDelta(oldElement, newElement);
        if (Object.keys(delta).length > 0) {
          changes.push({
            type: 'update',
            elementId: newElement.id,
            delta,
            versionNonce: newElement.versionNonce,
          });
        }
      }
    }
    
    // 检查删除的元素
    for (const oldElement of oldElements) {
      if (!newElementsMap.has(oldElement.id)) {
        changes.push({
          type: 'delete',
          elementId: oldElement.id,
        });
      }
    }
    
    return {
      version: this.lastKnownVersion + 1,
      changes: this.compressChanges(changes),
      timestamp: Date.now(),
    };
  }
  
  private computeElementDelta(
    oldElement: ExcalidrawElement,
    newElement: ExcalidrawElement
  ): Partial<ExcalidrawElement> {
    const delta: Partial<ExcalidrawElement> = {};
    
    // 比较所有可能变更的属性
    const compareProps: (keyof ExcalidrawElement)[] = [
      'x', 'y', 'width', 'height', 'angle', 'strokeColor',
      'backgroundColor', 'fillStyle', 'strokeWidth', 'strokeStyle',
      'roughness', 'opacity', 'locked', 'link'
    ];
    
    for (const prop of compareProps) {
      if (oldElement[prop] !== newElement[prop]) {
        (delta as any)[prop] = newElement[prop];
      }
    }
    
    // 特殊处理复杂属性
    if (oldElement.type === 'text' && newElement.type === 'text') {
      if (oldElement.text !== newElement.text) {
        delta.text = newElement.text;
      }
    }
    
    if (isLinearElement(oldElement) && isLinearElement(newElement)) {
      if (!this.arraysEqual(oldElement.points, newElement.points)) {
        delta.points = newElement.points;
      }
    }
    
    return delta;
  }
  
  private compressChanges(changes: ElementChange[]): ElementChange[] {
    if (!this.compressionEnabled) {
      return changes;
    }
    
    // 合并同一元素的多次变更
    const changesByElement = new Map<string, ElementChange[]>();
    
    for (const change of changes) {
      if (!changesByElement.has(change.elementId)) {
        changesByElement.set(change.elementId, []);
      }
      changesByElement.get(change.elementId)!.push(change);
    }
    
    const compressedChanges: ElementChange[] = [];
    
    for (const [elementId, elementChanges] of changesByElement) {
      if (elementChanges.length === 1) {
        compressedChanges.push(elementChanges[0]);
      } else {
        // 合并多个变更
        const merged = this.mergeElementChanges(elementChanges);
        compressedChanges.push(merged);
      }
    }
    
    return compressedChanges;
  }
  
  private mergeElementChanges(changes: ElementChange[]): ElementChange {
    // 如果最后是删除，直接返回删除操作
    const lastChange = changes[changes.length - 1];
    if (lastChange.type === 'delete') {
      return lastChange;
    }
    
    // 如果第一个是创建，合并所有更新到创建操作中
    const firstChange = changes[0];
    if (firstChange.type === 'create') {
      let mergedElement = { ...firstChange.element! };
      
      for (let i = 1; i < changes.length; i++) {
        const change = changes[i];
        if (change.type === 'update' && change.delta) {
          mergedElement = { ...mergedElement, ...change.delta };
        }
      }
      
      return {
        type: 'create',
        elementId: firstChange.elementId,
        element: mergedElement,
      };
    }
    
    // 合并多个更新操作
    const mergedDelta: any = {};
    let latestVersion = 0;
    
    for (const change of changes) {
      if (change.type === 'update' && change.delta) {
        Object.assign(mergedDelta, change.delta);
        if (change.versionNonce) {
          latestVersion = Math.max(latestVersion, change.versionNonce);
        }
      }
    }
    
    return {
      type: 'update',
      elementId: firstChange.elementId,
      delta: mergedDelta,
      versionNonce: latestVersion,
    };
  }
  
  private arraysEqual<T>(a: T[], b: T[]): boolean {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
}

// 数据压缩工具
class DataCompressor {
  // 使用 LZ4 风格的压缩算法
  compress(data: string): string {
    try {
      // 简化的字符串压缩
      const compressed = this.lz4Compress(data);
      return btoa(compressed); // Base64 编码
    } catch (error) {
      console.warn('Compression failed, sending uncompressed:', error);
      return data;
    }
  }
  
  decompress(compressedData: string): string {
    try {
      const decoded = atob(compressedData);
      return this.lz4Decompress(decoded);
    } catch (error) {
      console.warn('Decompression failed:', error);
      return compressedData;
    }
  }
  
  private lz4Compress(input: string): string {
    // 简化的压缩实现
    // 实际应用中应使用专业的压缩库如 fflate
    const dictionary = new Map<string, number>();
    const result: string[] = [];
    let dictIndex = 0;
    
    for (let i = 0; i < input.length; ) {
      let bestMatch = '';
      let bestLength = 0;
      
      // 查找最长匹配
      for (let j = Math.min(i + 1, input.length); j >= i + 1; j--) {
        const substr = input.substring(i, j);
        if (dictionary.has(substr) && substr.length > bestLength) {
          bestMatch = substr;
          bestLength = substr.length;
        }
      }
      
      if (bestLength > 3) {
        // 使用字典引用
        result.push(`@${dictionary.get(bestMatch)}`);
        i += bestLength;
      } else {
        // 直接字符
        const char = input[i];
        result.push(char);
        
        // 更新字典
        for (let len = 1; len <= Math.min(8, input.length - i); len++) {
          const substr = input.substring(i, i + len);
          if (!dictionary.has(substr)) {
            dictionary.set(substr, dictIndex++);
          }
        }
        
        i++;
      }
    }
    
    return result.join('');
  }
  
  private lz4Decompress(compressed: string): string {
    // 简化的解压缩实现
    const dictionary: string[] = [];
    const result: string[] = [];
    
    for (let i = 0; i < compressed.length; i++) {
      if (compressed[i] === '@') {
        // 字典引用
        let refStr = '';
        i++;
        while (i < compressed.length && /\d/.test(compressed[i])) {
          refStr += compressed[i];
          i++;
        }
        i--; // 回退一位
        
        const refIndex = parseInt(refStr);
        if (dictionary[refIndex]) {
          result.push(dictionary[refIndex]);
        }
      } else {
        // 直接字符
        result.push(compressed[i]);
      }
    }
    
    return result.join('');
  }
  
  // 估算压缩比
  getCompressionRatio(original: string, compressed: string): number {
    return compressed.length / original.length;
  }
}

// 数据类型定义
interface ElementChange {
  type: 'create' | 'update' | 'delete';
  elementId: string;
  element?: ExcalidrawElement;
  delta?: Partial<ExcalidrawElement>;
  versionNonce?: number;
}

interface IncrementalUpdate {
  version: number;
  changes: ElementChange[];
  timestamp: number;
}
```

这个性能优化指南涵盖了 Excalidraw 中的主要性能优化技术，包括渲染优化、内存管理、交互响应、大规模数据处理和网络优化。每个部分都提供了具体的实现示例和最佳实践，为开发者提供了完整的性能优化指南。

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "Create detailed event system documentation", "status": "completed", "activeForm": "Creating detailed event system documentation"}, {"content": "Create comprehensive tools system documentation", "status": "completed", "activeForm": "Creating comprehensive tools system documentation"}, {"content": "Create performance optimization guide", "status": "completed", "activeForm": "Creating performance optimization guide"}, {"content": "Create plugin development guide", "status": "in_progress", "activeForm": "Creating plugin development guide"}, {"content": "Create collaboration system documentation", "status": "pending", "activeForm": "Creating collaboration system documentation"}]