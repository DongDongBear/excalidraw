# Excalidraw 事件系统详解

## 目录
- [概述](#概述)
- [事件架构](#事件架构)
- [动作系统（Action System）](#动作系统action-system)
- [事件处理流程](#事件处理流程)
- [键盘事件](#键盘事件)
- [鼠标和触摸事件](#鼠标和触摸事件)
- [自定义事件系统](#自定义事件系统)
- [事件优化和性能](#事件优化和性能)
- [实战示例](#实战示例)

## 概述

Excalidraw 的事件系统是一个高度优化的、分层的架构，负责处理用户交互、工具切换、元素操作等核心功能。它基于 React 事件系统，但增加了大量自定义逻辑来支持复杂的画板操作。

### 核心特性
- **分层事件处理**：从原生事件到应用级动作的多层转换
- **动作系统**：统一的命令模式实现
- **手势支持**：支持触摸、手势和多点触控
- **性能优化**：事件节流、防抖和批处理
- **可扩展性**：插件和自定义工具支持

## 事件架构

### 1. 事件分层结构

```typescript
// 原生浏览器事件
DOM Events (MouseEvent, KeyboardEvent, TouchEvent, WheelEvent)
    ↓
// React 事件包装层
React SyntheticEvents
    ↓
// Excalidraw 事件处理层
App Event Handlers (onPointerDown, onKeyDown, onWheel)
    ↓
// 工具特定处理
Tool-specific Handlers
    ↓
// 动作系统
Action System (ActionManager)
    ↓
// 状态更新
State Updates & Re-render
```

### 2. 事件管理器架构

```typescript
// 核心事件管理接口
interface EventManager {
  // 事件监听器注册
  addEventListener<K extends keyof EventMap>(
    type: K,
    listener: (event: EventMap[K]) => void,
    options?: EventListenerOptions
  ): void;
  
  // 事件移除
  removeEventListener<K extends keyof EventMap>(
    type: K,
    listener: (event: EventMap[K]) => void
  ): void;
  
  // 事件触发
  dispatchEvent<K extends keyof EventMap>(
    type: K,
    event: EventMap[K]
  ): void;
  
  // 事件委托
  delegate(selector: string, eventType: string, handler: Function): void;
}

// 事件映射类型定义
interface EventMap {
  'element:create': ElementCreateEvent;
  'element:update': ElementUpdateEvent;
  'element:delete': ElementDeleteEvent;
  'element:select': ElementSelectEvent;
  'tool:change': ToolChangeEvent;
  'viewport:change': ViewportChangeEvent;
  'canvas:render': CanvasRenderEvent;
  'history:change': HistoryChangeEvent;
  'collaboration:update': CollaborationEvent;
}
```

## 动作系统（Action System）

### 1. 动作接口定义

```typescript
// 动作定义接口
export interface Action {
  name: ActionName;                    // 动作唯一标识
  label: string | ((elements, appState, app) => string);  // 显示标签
  keywords?: string[];                 // 搜索关键词
  icon?: React.ReactNode;             // 图标组件
  PanelComponent?: React.FC;          // 配置面板组件
  perform: ActionFn;                  // 执行函数
  keyPriority?: number;               // 快捷键优先级
  keyTest?: KeyTestFn;               // 快捷键匹配函数
  predicate?: PredicateFn;           // 可用性判断
  checked?: CheckedFn;               // 选中状态判断
  trackEvent: TrackEventConfig;      // 分析跟踪配置
  viewMode?: boolean;                // 是否在查看模式可用
}

// 动作执行函数类型
type ActionFn = (
  elements: readonly OrderedExcalidrawElement[],
  appState: Readonly<AppState>,
  formData: any,
  app: AppClassProperties,
) => ActionResult | Promise<ActionResult>;

// 动作结果类型
type ActionResult = {
  elements?: readonly ExcalidrawElement[] | null;
  appState?: Partial<AppState> | null;
  files?: BinaryFiles | null;
  captureUpdate: CaptureUpdateActionType;
  replaceFiles?: boolean;
} | false;
```

### 2. 动作管理器实现

```typescript
class ActionManager {
  private actions = new Map<ActionName, Action>();
  private shortcuts = new Map<string, Action>();
  
  constructor(
    private updateData: (result: ActionResult) => void,
    private getAppState: () => AppState,
    private getElements: () => readonly ExcalidrawElement[]
  ) {
    this.registerBuiltinActions();
  }
  
  // 注册动作
  registerAction(action: Action): void {
    this.actions.set(action.name, action);
    
    // 注册快捷键
    if (action.keyTest) {
      const shortcut = this.getShortcutString(action);
      this.shortcuts.set(shortcut, action);
    }
  }
  
  // 执行动作
  async executeAction(
    actionOrName: Action | ActionName,
    source: ActionSource = 'api',
    event?: Event,
    formData?: any
  ): Promise<void> {
    const action = typeof actionOrName === 'string' 
      ? this.actions.get(actionOrName)
      : actionOrName;
      
    if (!action) {
      console.warn(`Action not found: ${actionOrName}`);
      return;
    }
    
    const elements = this.getElements();
    const appState = this.getAppState();
    
    // 检查动作可用性
    if (action.predicate && !action.predicate(elements, appState, {}, {})) {
      return;
    }
    
    try {
      // 执行动作
      const result = await action.perform(elements, appState, formData, {});
      
      if (result !== false) {
        // 更新状态
        this.updateData(result);
        
        // 跟踪事件
        if (action.trackEvent !== false) {
          this.trackActionExecution(action, source, result);
        }
      }
    } catch (error) {
      console.error(`Action execution failed: ${action.name}`, error);
    }
  }
  
  // 处理快捷键
  handleKeyDown(event: KeyboardEvent): boolean {
    const shortcut = this.getShortcutFromEvent(event);
    const action = this.shortcuts.get(shortcut);
    
    if (action && action.keyTest) {
      const elements = this.getElements();
      const appState = this.getAppState();
      
      if (action.keyTest(event, appState, elements, {})) {
        this.executeAction(action, 'keyboard', event);
        return true;
      }
    }
    
    return false;
  }
  
  // 获取快捷键字符串
  private getShortcutFromEvent(event: KeyboardEvent): string {
    const parts: string[] = [];
    if (event.ctrlKey || event.metaKey) parts.push('cmd');
    if (event.shiftKey) parts.push('shift');
    if (event.altKey) parts.push('alt');
    parts.push(event.key.toLowerCase());
    return parts.join('+');
  }
  
  // 跟踪动作执行
  private trackActionExecution(
    action: Action, 
    source: ActionSource, 
    result: ActionResult
  ): void {
    if (action.trackEvent === false) return;
    
    const trackConfig = action.trackEvent;
    const elements = this.getElements();
    const appState = this.getAppState();
    
    // 检查跟踪条件
    if (trackConfig.predicate && 
        !trackConfig.predicate(appState, elements, result)) {
      return;
    }
    
    // 发送跟踪事件
    const eventData = {
      category: trackConfig.category,
      action: trackConfig.action || action.name,
      source,
      timestamp: Date.now(),
      metadata: {
        elementCount: elements.length,
        selectedCount: Object.keys(appState.selectedElementIds).length,
      }
    };
    
    this.sendTrackingEvent(eventData);
  }
}
```

## 事件处理流程

### 1. 指针事件处理

```typescript
class PointerEventHandler {
  private isPointerDown = false;
  private pointerDownState: PointerDownState | null = null;
  private gesture = new Gesture();
  
  // 指针按下
  onPointerDown = (event: React.PointerEvent<HTMLCanvasElement>): void => {
    const { clientX, clientY, pointerId, button } = event;
    
    // 记录指针状态
    this.isPointerDown = true;
    this.pointerDownState = {
      origin: { x: clientX, y: clientY },
      withCmdOrCtrl: event.ctrlKey || event.metaKey,
      withShift: event.shiftKey,
      withAlt: event.altKey,
      pointerId,
      button,
      timestamp: Date.now(),
    };
    
    // 设置指针捕获
    (event.target as Element).setPointerCapture(pointerId);
    
    // 更新手势状态
    this.gesture.pointers.set(pointerId, {
      x: clientX,
      y: clientY,
      timestamp: Date.now(),
    });
    
    // 处理工具特定逻辑
    this.handleToolPointerDown(event);
    
    // 阻止默认行为
    event.preventDefault();
  };
  
  // 指针移动
  onPointerMove = (event: React.PointerEvent<HTMLCanvasElement>): void => {
    const { clientX, clientY, pointerId } = event;
    
    // 更新手势状态
    this.gesture.pointers.set(pointerId, {
      x: clientX,
      y: clientY,
      timestamp: Date.now(),
    });
    
    // 处理拖拽
    if (this.isPointerDown && this.pointerDownState) {
      this.handleDragging(event);
    } else {
      // 处理悬停
      this.handleHovering(event);
    }
    
    event.preventDefault();
  };
  
  // 指针抬起
  onPointerUp = (event: React.PointerEvent<HTMLCanvasElement>): void => {
    const { pointerId } = event;
    
    if (this.isPointerDown && this.pointerDownState?.pointerId === pointerId) {
      // 处理点击或拖拽结束
      this.handlePointerUpAction(event);
      
      // 重置状态
      this.isPointerDown = false;
      this.pointerDownState = null;
    }
    
    // 清除指针状态
    this.gesture.pointers.delete(pointerId);
    (event.target as Element).releasePointerCapture(pointerId);
    
    event.preventDefault();
  };
  
  // 处理工具特定的指针按下逻辑
  private handleToolPointerDown(event: React.PointerEvent): void {
    const tool = this.app.state.activeTool;
    const scenePointer = this.getScenePointer(event);
    
    switch (tool.type) {
      case 'selection':
        this.handleSelectionPointerDown(scenePointer, event);
        break;
        
      case 'rectangle':
      case 'ellipse':
      case 'diamond':
      case 'triangle':
        this.handleShapePointerDown(tool.type, scenePointer, event);
        break;
        
      case 'arrow':
      case 'line':
        this.handleLinearElementPointerDown(tool.type, scenePointer, event);
        break;
        
      case 'draw':
        this.handleFreeDrawPointerDown(scenePointer, event);
        break;
        
      case 'text':
        this.handleTextPointerDown(scenePointer, event);
        break;
        
      case 'eraser':
        this.handleEraserPointerDown(scenePointer, event);
        break;
        
      default:
        console.warn(`Unhandled tool type: ${tool.type}`);
    }
  }
  
  // 场景坐标转换
  private getScenePointer(event: React.PointerEvent): Point {
    return viewportCoordsToSceneCoords(
      { clientX: event.clientX, clientY: event.clientY },
      this.app.state
    );
  }
}
```

### 2. 键盘事件处理

```typescript
class KeyboardEventHandler {
  private pressedKeys = new Set<string>();
  
  // 键盘按下
  onKeyDown = (event: KeyboardEvent): void => {
    const key = event.key.toLowerCase();
    this.pressedKeys.add(key);
    
    // 优先处理动作管理器
    if (this.app.actionManager.handleKeyDown(event)) {
      return;
    }
    
    // 处理工具切换快捷键
    if (this.handleToolSwitchShortcuts(event)) {
      return;
    }
    
    // 处理导航快捷键
    if (this.handleNavigationShortcuts(event)) {
      return;
    }
    
    // 处理元素操作快捷键
    if (this.handleElementOperationShortcuts(event)) {
      return;
    }
    
    // 处理文本编辑快捷键
    if (this.handleTextEditingShortcuts(event)) {
      return;
    }
  };
  
  // 键盘抬起
  onKeyUp = (event: KeyboardEvent): void => {
    const key = event.key.toLowerCase();
    this.pressedKeys.delete(key);
    
    // 处理临时工具切换
    this.handleTemporaryToolSwitch(event);
  };
  
  // 处理工具切换快捷键
  private handleToolSwitchShortcuts(event: KeyboardEvent): boolean {
    if (isWritableElement(event.target)) {
      return false;
    }
    
    const toolShortcuts: Record<string, ToolType> = {
      'v': TOOL_TYPE.selection,
      'r': TOOL_TYPE.rectangle,
      'o': TOOL_TYPE.ellipse,
      'd': TOOL_TYPE.diamond,
      't': TOOL_TYPE.triangle,
      'a': TOOL_TYPE.arrow,
      'l': TOOL_TYPE.line,
      'p': TOOL_TYPE.draw,
      'x': TOOL_TYPE.text,
      'e': TOOL_TYPE.eraser,
    };
    
    const tool = toolShortcuts[event.key.toLowerCase()];
    if (tool) {
      this.app.setActiveTool({ type: tool });
      event.preventDefault();
      return true;
    }
    
    return false;
  }
  
  // 处理导航快捷键
  private handleNavigationShortcuts(event: KeyboardEvent): boolean {
    if (event.ctrlKey || event.metaKey) {
      switch (event.key.toLowerCase()) {
        case '0':
          // 重置缩放
          this.app.actionManager.executeAction('resetZoom', 'keyboard', event);
          return true;
          
        case '=':
        case '+':
          // 放大
          this.app.actionManager.executeAction('zoomIn', 'keyboard', event);
          return true;
          
        case '-':
          // 缩小
          this.app.actionManager.executeAction('zoomOut', 'keyboard', event);
          return true;
          
        case '1':
          // 适应画布
          this.app.actionManager.executeAction('zoomToFit', 'keyboard', event);
          return true;
          
        case '2':
          // 适应选择
          this.app.actionManager.executeAction('zoomToFitSelection', 'keyboard', event);
          return true;
      }
    }
    
    // 方向键导航
    if (isArrowKey(event.key)) {
      this.handleArrowKeyNavigation(event);
      return true;
    }
    
    return false;
  }
  
  // 处理方向键导航
  private handleArrowKeyNavigation(event: KeyboardEvent): void {
    const selectedElements = this.app.scene.getSelectedElements(this.app.state);
    
    if (selectedElements.length > 0) {
      // 移动选中元素
      const step = event.shiftKey 
        ? ELEMENT_SHIFT_TRANSLATE_AMOUNT 
        : ELEMENT_TRANSLATE_AMOUNT;
        
      const delta = this.getArrowKeyDelta(event.key, step);
      
      this.app.actionManager.executeAction('moveElements', 'keyboard', event, {
        delta,
        elements: selectedElements,
      });
    } else {
      // 移动视口
      const step = event.shiftKey ? 50 : 10;
      const delta = this.getArrowKeyDelta(event.key, step);
      
      this.app.updateState({
        scrollX: this.app.state.scrollX - delta.x,
        scrollY: this.app.state.scrollY - delta.y,
      });
    }
    
    event.preventDefault();
  }
  
  // 获取方向键增量
  private getArrowKeyDelta(key: string, step: number): Point {
    switch (key) {
      case KEYS.ARROW_LEFT: return { x: -step, y: 0 };
      case KEYS.ARROW_RIGHT: return { x: step, y: 0 };
      case KEYS.ARROW_UP: return { x: 0, y: -step };
      case KEYS.ARROW_DOWN: return { x: 0, y: step };
      default: return { x: 0, y: 0 };
    }
  }
}
```

## 自定义事件系统

### 1. 事件发射器实现

```typescript
class EventEmitter<T extends Record<string, any> = Record<string, any>> {
  private listeners = new Map<keyof T, Set<Function>>();
  
  // 添加事件监听器
  on<K extends keyof T>(event: K, listener: (data: T[K]) => void): () => void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    
    this.listeners.get(event)!.add(listener);
    
    // 返回移除监听器的函数
    return () => this.off(event, listener);
  }
  
  // 移除事件监听器
  off<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {
    const eventListeners = this.listeners.get(event);
    if (eventListeners) {
      eventListeners.delete(listener);
      if (eventListeners.size === 0) {
        this.listeners.delete(event);
      }
    }
  }
  
  // 触发事件
  emit<K extends keyof T>(event: K, data: T[K]): void {
    const eventListeners = this.listeners.get(event);
    if (eventListeners) {
      for (const listener of eventListeners) {
        try {
          listener(data);
        } catch (error) {
          console.error(`Event listener error for ${String(event)}:`, error);
        }
      }
    }
  }
  
  // 一次性事件监听器
  once<K extends keyof T>(event: K, listener: (data: T[K]) => void): () => void {
    const onceListener = (data: T[K]) => {
      listener(data);
      this.off(event, onceListener);
    };
    
    return this.on(event, onceListener);
  }
  
  // 移除所有监听器
  removeAllListeners(): void {
    this.listeners.clear();
  }
}
```

### 2. 应用级事件系统

```typescript
// 应用事件类型定义
interface AppEvents {
  'canvas:mount': { canvas: HTMLCanvasElement };
  'canvas:unmount': { canvas: HTMLCanvasElement };
  'element:create': { element: ExcalidrawElement };
  'element:update': { 
    element: ExcalidrawElement; 
    previousElement: ExcalidrawElement 
  };
  'element:delete': { element: ExcalidrawElement };
  'elements:change': { 
    elements: readonly ExcalidrawElement[];
    reason: 'create' | 'update' | 'delete' | 'reorder';
  };
  'selection:change': {
    selectedElements: readonly ExcalidrawElement[];
    previousSelection: readonly ExcalidrawElement[];
  };
  'tool:change': {
    tool: ToolType;
    previousTool: ToolType;
  };
  'viewport:change': {
    viewport: {
      x: number;
      y: number;
      width: number;
      height: number;
      zoom: number;
    };
  };
  'history:change': {
    canUndo: boolean;
    canRedo: boolean;
    historySize: number;
  };
}

// 应用事件管理器
class AppEventManager {
  private emitter = new EventEmitter<AppEvents>();
  
  // 公开的事件接口
  on = this.emitter.on.bind(this.emitter);
  off = this.emitter.off.bind(this.emitter);
  once = this.emitter.once.bind(this.emitter);
  emit = this.emitter.emit.bind(this.emitter);
  
  // 批量事件处理
  private eventQueue: Array<{ event: keyof AppEvents; data: any }> = [];
  private flushTimeout: number | null = null;
  
  // 批量触发事件
  emitBatch<K extends keyof AppEvents>(event: K, data: AppEvents[K]): void {
    this.eventQueue.push({ event, data });
    
    if (!this.flushTimeout) {
      this.flushTimeout = window.setTimeout(() => {
        this.flushEventQueue();
      }, 0);
    }
  }
  
  // 清空事件队列
  private flushEventQueue(): void {
    if (this.eventQueue.length === 0) return;
    
    const events = [...this.eventQueue];
    this.eventQueue = [];
    this.flushTimeout = null;
    
    // 按类型分组事件
    const eventGroups = new Map<keyof AppEvents, any[]>();
    for (const { event, data } of events) {
      if (!eventGroups.has(event)) {
        eventGroups.set(event, []);
      }
      eventGroups.get(event)!.push(data);
    }
    
    // 触发分组事件
    for (const [event, dataArray] of eventGroups) {
      if (dataArray.length === 1) {
        this.emit(event, dataArray[0]);
      } else {
        // 对于批量事件，合并数据
        this.emit(event, this.mergeEventData(event, dataArray));
      }
    }
  }
  
  // 合并事件数据
  private mergeEventData(event: keyof AppEvents, dataArray: any[]): any {
    switch (event) {
      case 'elements:change':
        return {
          elements: dataArray[dataArray.length - 1].elements,
          reason: 'batch' as const,
        };
        
      default:
        return dataArray[dataArray.length - 1];
    }
  }
}
```

## 事件优化和性能

### 1. 事件节流和防抖

```typescript
class EventThrottler {
  private throttledFunctions = new Map<string, Function>();
  private debouncedFunctions = new Map<string, Function>();
  
  // 节流函数
  throttle<T extends (...args: any[]) => void>(
    key: string,
    func: T,
    delay: number
  ): T {
    if (!this.throttledFunctions.has(key)) {
      let lastCall = 0;
      let timeout: number | null = null;
      
      const throttledFunc = (...args: Parameters<T>) => {
        const now = Date.now();
        
        if (now - lastCall >= delay) {
          lastCall = now;
          func.apply(this, args);
        } else if (!timeout) {
          timeout = window.setTimeout(() => {
            lastCall = Date.now();
            func.apply(this, args);
            timeout = null;
          }, delay - (now - lastCall));
        }
      };
      
      this.throttledFunctions.set(key, throttledFunc);
    }
    
    return this.throttledFunctions.get(key) as T;
  }
  
  // 防抖函数
  debounce<T extends (...args: any[]) => void>(
    key: string,
    func: T,
    delay: number
  ): T {
    if (!this.debouncedFunctions.has(key)) {
      let timeout: number | null = null;
      
      const debouncedFunc = (...args: Parameters<T>) => {
        if (timeout) {
          clearTimeout(timeout);
        }
        
        timeout = window.setTimeout(() => {
          func.apply(this, args);
          timeout = null;
        }, delay);
      };
      
      this.debouncedFunctions.set(key, debouncedFunc);
    }
    
    return this.debouncedFunctions.get(key) as T;
  }
  
  // 清理函数
  clear(): void {
    this.throttledFunctions.clear();
    this.debouncedFunctions.clear();
  }
}

// 在应用中使用
class OptimizedEventHandler {
  private throttler = new EventThrottler();
  
  constructor(private app: App) {
    // 节流的鼠标移动处理
    this.onPointerMove = this.throttler.throttle(
      'pointer-move',
      this.handlePointerMove.bind(this),
      16 // ~60fps
    );
    
    // 防抖的窗口大小调整处理
    this.onWindowResize = this.throttler.debounce(
      'window-resize',
      this.handleWindowResize.bind(this),
      100
    );
    
    // 防抖的状态保存
    this.saveState = this.throttler.debounce(
      'save-state',
      this.handleSaveState.bind(this),
      500
    );
  }
  
  private handlePointerMove(event: PointerEvent): void {
    // 处理鼠标移动逻辑
  }
  
  private handleWindowResize(): void {
    // 处理窗口大小调整逻辑
  }
  
  private handleSaveState(): void {
    // 处理状态保存逻辑
  }
}
```

### 2. 事件池和内存优化

```typescript
class EventPool<T> {
  private pool: T[] = [];
  private createFn: () => T;
  private resetFn: (obj: T) => void;
  
  constructor(
    createFn: () => T,
    resetFn: (obj: T) => void,
    initialSize = 10
  ) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    
    // 预填充池
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(createFn());
    }
  }
  
  // 获取对象
  acquire(): T {
    return this.pool.pop() || this.createFn();
  }
  
  // 释放对象
  release(obj: T): void {
    this.resetFn(obj);
    this.pool.push(obj);
  }
  
  // 清空池
  clear(): void {
    this.pool.length = 0;
  }
}

// 事件对象池
interface PooledPointerEvent {
  x: number;
  y: number;
  pressure: number;
  pointerId: number;
  timestamp: number;
}

const pointerEventPool = new EventPool<PooledPointerEvent>(
  () => ({
    x: 0,
    y: 0,
    pressure: 0,
    pointerId: 0,
    timestamp: 0,
  }),
  (event) => {
    event.x = 0;
    event.y = 0;
    event.pressure = 0;
    event.pointerId = 0;
    event.timestamp = 0;
  },
  100
);

class MemoryOptimizedEventHandler {
  private processedEvents = new WeakMap<Event, boolean>();
  
  handlePointerEvent(nativeEvent: PointerEvent): void {
    // 避免重复处理
    if (this.processedEvents.has(nativeEvent)) {
      return;
    }
    this.processedEvents.set(nativeEvent, true);
    
    // 从池中获取事件对象
    const pooledEvent = pointerEventPool.acquire();
    
    try {
      // 设置事件数据
      pooledEvent.x = nativeEvent.clientX;
      pooledEvent.y = nativeEvent.clientY;
      pooledEvent.pressure = nativeEvent.pressure;
      pooledEvent.pointerId = nativeEvent.pointerId;
      pooledEvent.timestamp = Date.now();
      
      // 处理事件
      this.processPointerEvent(pooledEvent);
    } finally {
      // 释放回池中
      pointerEventPool.release(pooledEvent);
    }
  }
  
  private processPointerEvent(event: PooledPointerEvent): void {
    // 实际的事件处理逻辑
  }
}
```

## 实战示例

### 1. 自定义工具事件处理

```typescript
// 自定义画刷工具
class CustomBrushTool {
  private isDrawing = false;
  private currentStroke: Point[] = [];
  private strokeHistory: Point[][] = [];
  
  constructor(private app: App) {
    this.registerEventHandlers();
  }
  
  private registerEventHandlers(): void {
    // 注册指针事件处理器
    this.app.canvas.addEventListener('pointerdown', this.onPointerDown);
    this.app.canvas.addEventListener('pointermove', this.onPointerMove);
    this.app.canvas.addEventListener('pointerup', this.onPointerUp);
    
    // 注册键盘快捷键
    this.app.actionManager.registerAction({
      name: 'customBrush',
      label: 'Custom Brush',
      keyTest: (event) => event.key === 'b' && !event.ctrlKey,
      perform: () => {
        this.app.setActiveTool({ type: 'customBrush' });
        return { appState: { activeTool: { type: 'customBrush' } } };
      },
      trackEvent: { category: 'toolbar' }
    });
  }
  
  private onPointerDown = (event: PointerEvent): void => {
    if (this.app.state.activeTool.type !== 'customBrush') return;
    
    this.isDrawing = true;
    this.currentStroke = [];
    
    const point = this.getScenePoint(event);
    this.currentStroke.push(point);
    
    // 开始新的绘制元素
    this.startDrawingElement(point);
  };
  
  private onPointerMove = (event: PointerEvent): void => {
    if (!this.isDrawing || this.app.state.activeTool.type !== 'customBrush') {
      return;
    }
    
    const point = this.getScenePoint(event);
    this.currentStroke.push(point);
    
    // 更新当前绘制元素
    this.updateDrawingElement(point);
  };
  
  private onPointerUp = (event: PointerEvent): void => {
    if (!this.isDrawing || this.app.state.activeTool.type !== 'customBrush') {
      return;
    }
    
    this.isDrawing = false;
    
    // 完成绘制元素
    this.finishDrawingElement();
    
    // 保存到历史记录
    this.strokeHistory.push([...this.currentStroke]);
    this.currentStroke = [];
  };
  
  private getScenePoint(event: PointerEvent): Point {
    return viewportCoordsToSceneCoords(
      { clientX: event.clientX, clientY: event.clientY },
      this.app.state
    );
  }
  
  private startDrawingElement(startPoint: Point): void {
    const element = newFreeDrawElement({
      type: 'draw',
      x: startPoint.x,
      y: startPoint.y,
      points: [[0, 0]],
      pressures: [1],
      simulatePressure: true,
      strokeColor: this.app.state.currentItemStrokeColor,
      strokeWidth: this.app.state.currentItemStrokeWidth,
      strokeStyle: this.app.state.currentItemStrokeStyle,
      roughness: this.app.state.currentItemRoughness,
    });
    
    this.app.scene.replaceAllElements([
      ...this.app.scene.getElements(),
      element
    ]);
  }
  
  private updateDrawingElement(currentPoint: Point): void {
    const elements = this.app.scene.getElements();
    const lastElement = elements[elements.length - 1];
    
    if (lastElement && lastElement.type === 'draw') {
      const points = this.currentStroke.map((point, index) => {
        if (index === 0) return [0, 0];
        const prev = this.currentStroke[0];
        return [point.x - prev.x, point.y - prev.y];
      });
      
      const updatedElement = newElementWith(lastElement, {
        points: points as [number, number][],
      });
      
      this.app.scene.replaceAllElements([
        ...elements.slice(0, -1),
        updatedElement
      ]);
    }
  }
  
  private finishDrawingElement(): void {
    // 触发历史记录保存
    this.app.history.pushToHistory(this.app.scene.getElements());
    
    // 触发自定义事件
    this.app.events.emit('custom:brush-stroke-complete', {
      stroke: [...this.currentStroke],
      element: this.app.scene.getElements().slice(-1)[0]
    });
  }
}
```

### 2. 协作事件处理

```typescript
// 协作事件管理器
class CollaborationEventManager {
  private websocket: WebSocket | null = null;
  private eventQueue: CollabEvent[] = [];
  private isConnected = false;
  
  constructor(private app: App) {
    this.setupEventHandlers();
  }
  
  private setupEventHandlers(): void {
    // 监听本地元素变化
    this.app.events.on('elements:change', (data) => {
      if (this.isConnected) {
        this.sendElementsUpdate(data.elements);
      }
    });
    
    // 监听选择变化
    this.app.events.on('selection:change', (data) => {
      if (this.isConnected) {
        this.sendSelectionUpdate(data.selectedElements);
      }
    });
    
    // 监听指针位置变化
    this.app.events.on('pointer:move', throttle((data) => {
      if (this.isConnected) {
        this.sendPointerUpdate(data.pointer);
      }
    }, 100));
  }
  
  // 连接到协作服务器
  connect(roomId: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const ws = new WebSocket(`ws://collab-server.com/room/${roomId}`);
      
      ws.onopen = () => {
        this.websocket = ws;
        this.isConnected = true;
        this.flushEventQueue();
        resolve();
      };
      
      ws.onclose = () => {
        this.isConnected = false;
        this.websocket = null;
      };
      
      ws.onerror = reject;
      
      ws.onmessage = (event) => {
        const data = JSON.parse(event.data) as CollabEvent;
        this.handleRemoteEvent(data);
      };
    });
  }
  
  // 处理远程事件
  private handleRemoteEvent(event: CollabEvent): void {
    switch (event.type) {
      case 'elements:update':
        this.handleRemoteElementsUpdate(event.data);
        break;
        
      case 'selection:update':
        this.handleRemoteSelectionUpdate(event.data);
        break;
        
      case 'pointer:update':
        this.handleRemotePointerUpdate(event.data);
        break;
        
      case 'user:join':
        this.handleUserJoin(event.data);
        break;
        
      case 'user:leave':
        this.handleUserLeave(event.data);
        break;
    }
  }
  
  // 发送元素更新
  private sendElementsUpdate(elements: readonly ExcalidrawElement[]): void {
    this.sendEvent({
      type: 'elements:update',
      data: {
        elements: elements.map(element => ({
          ...element,
          // 只发送必要的数据以减少网络负载
          id: element.id,
          type: element.type,
          x: element.x,
          y: element.y,
          width: element.width,
          height: element.height,
          angle: element.angle,
          versionNonce: element.versionNonce,
        })),
        userId: this.app.collaboration.userId,
        timestamp: Date.now(),
      }
    });
  }
  
  // 处理远程元素更新
  private handleRemoteElementsUpdate(data: any): void {
    const { elements, userId, timestamp } = data;
    
    // 避免处理自己的更新
    if (userId === this.app.collaboration.userId) {
      return;
    }
    
    // 合并远程元素
    const mergedElements = this.mergeRemoteElements(
      this.app.scene.getElements(),
      elements
    );
    
    this.app.scene.replaceAllElements(mergedElements);
    
    // 触发协作更新事件
    this.app.events.emit('collaboration:elements-updated', {
      userId,
      timestamp,
      elements: mergedElements,
    });
  }
  
  // 合并远程元素
  private mergeRemoteElements(
    localElements: readonly ExcalidrawElement[],
    remoteElements: ExcalidrawElement[]
  ): ExcalidrawElement[] {
    const elementMap = new Map(localElements.map(el => [el.id, el]));
    
    // 更新或添加远程元素
    for (const remoteElement of remoteElements) {
      const localElement = elementMap.get(remoteElement.id);
      
      if (!localElement || localElement.versionNonce < remoteElement.versionNonce) {
        elementMap.set(remoteElement.id, remoteElement);
      }
    }
    
    return Array.from(elementMap.values());
  }
  
  // 发送事件
  private sendEvent(event: CollabEvent): void {
    if (this.isConnected && this.websocket) {
      this.websocket.send(JSON.stringify(event));
    } else {
      // 队列事件直到连接建立
      this.eventQueue.push(event);
    }
  }
  
  // 清空事件队列
  private flushEventQueue(): void {
    while (this.eventQueue.length > 0) {
      const event = this.eventQueue.shift();
      if (event && this.websocket) {
        this.websocket.send(JSON.stringify(event));
      }
    }
  }
}

// 协作事件类型定义
interface CollabEvent {
  type: 'elements:update' | 'selection:update' | 'pointer:update' | 'user:join' | 'user:leave';
  data: any;
}
```

这个事件系统文档详细介绍了 Excalidraw 的事件处理架构，包括动作系统、键盘和指针事件处理、自定义事件系统、性能优化策略，以及实际的工具和协作实现示例。这为开发者提供了完整的事件系统理解和扩展指南。