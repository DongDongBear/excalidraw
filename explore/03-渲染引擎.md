# Excalidraw 渲染引擎详解

## 1. 渲染架构概述

Excalidraw 采用了分层渲染架构，通过多个 Canvas 层来实现高性能的绘图体验。这种设计将静态内容和动态交互分离，最大化渲染性能。

### 1.1 多层 Canvas 架构

```typescript
// 三层 Canvas 设计
const CanvasLayers = {
  static: HTMLCanvasElement,      // 静态场景层 - 不经常变化的元素
  interactive: HTMLCanvasElement,  // 交互层 - 选择框、变换控制点等
  svg: SVGElement,                // SVG层 - 超链接、特殊元素
} as const;

// packages/excalidraw/components/canvases/
// 1. 静态层组件
export const StaticCanvas = React.memo(
  ({ elements, appState, scale }: StaticCanvasProps) => {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    
    useEffect(() => {
      const canvas = canvasRef.current;
      if (!canvas) return;
      
      // 渲染静态场景
      renderStaticScene({
        canvas,
        elements,
        appState,
        scale,
        renderConfig: {
          isExporting: false,
          renderScrollbars: false,
          renderSelection: false,
        },
      });
    }, [elements, appState, scale]);
    
    return (
      <canvas
        ref={canvasRef}
        className="excalidraw__canvas--static"
        width={width * scale}
        height={height * scale}
        style={{
          width,
          height,
          zIndex: 1, // 最底层
        }}
      />
    );
  }
);

// 2. 交互层组件
export const InteractiveCanvas = React.memo(
  ({ appState, elements, onPointerMove }: InteractiveCanvasProps) => {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    
    const renderCallback = useCallback(() => {
      const canvas = canvasRef.current;
      if (!canvas) return;
      
      // 渲染交互元素
      renderInteractiveScene({
        canvas,
        elements,
        appState,
        renderConfig: {
          renderSelection: true,
          renderBindings: true,
        },
      });
    }, [elements, appState]);
    
    // 使用 requestAnimationFrame 优化渲染
    useLayoutEffect(() => {
      renderCallback();
    });
    
    return (
      <canvas
        ref={canvasRef}
        className="excalidraw__canvas--interactive"
        style={{
          zIndex: 2, // 中间层
        }}
        onPointerMove={onPointerMove}
      />
    );
  }
);

// 3. SVG层组件  
export const SVGLayer = ({ elements, appState }: SVGLayerProps) => {
  return (
    <svg
      className="excalidraw__canvas--svg"
      style={{
        position: "absolute",
        zIndex: 3, // 最顶层
      }}
    >
      {elements.map(element => {
        // 渲染超链接图标
        if (element.link) {
          return <HyperlinkSVGElement key={element.id} element={element} />;
        }
        return null;
      })}
    </svg>
  );
};
```

### 1.2 渲染器核心类

```typescript
// packages/excalidraw/scene/Renderer.ts
export class Renderer {
  private scene: Scene;

  constructor(scene: Scene) {
    this.scene = scene;
  }

  // 获取可渲染元素的核心逻辑
  public getRenderableElements = (() => {
    // 可见性检测 - 只渲染视口内的元素
    const getVisibleCanvasElements = ({
      elementsMap,
      zoom,
      scrollX,
      scrollY,
      width,
      height,
    }: ViewportParams): readonly NonDeletedExcalidrawElement[] => {
      const visibleElements: NonDeletedExcalidrawElement[] = [];
      
      for (const element of elementsMap.values()) {
        // 检查元素是否在视口内
        if (isElementInViewport(
          element,
          width,
          height,
          { zoom, scrollX, scrollY },
          elementsMap
        )) {
          visibleElements.push(element);
        }
      }
      
      return visibleElements;
    };

    // 过滤可渲染元素
    const getRenderableElements = ({
      elements,
      editingTextElement,
      newElementId,
    }: {
      elements: readonly NonDeletedExcalidrawElement[];
      editingTextElement: AppState["editingTextElement"];
      newElementId: ExcalidrawElement["id"] | undefined;
    }) => {
      const elementsMap = new Map();

      for (const element of elements) {
        // 跳过新建但未确认的元素
        if (newElementId === element.id) {
          continue;
        }

        // 跳过正在编辑的文本元素（避免闪烁）
        if (
          editingTextElement?.type === "text" &&
          element.id === editingTextElement.id
        ) {
          continue;
        }

        elementsMap.set(element.id, element);
      }
      
      return elementsMap;
    };

    // 使用 memoization 优化性能
    return memoize(({
      zoom,
      scrollX,
      scrollY,
      width,
      height,
      editingTextElement,
      newElementId,
      sceneNonce, // 缓存失效标识
    }) => {
      const elements = this.scene.getNonDeletedElements();

      const elementsMap = getRenderableElements({
        elements,
        editingTextElement,
        newElementId,
      });

      const visibleElements = getVisibleCanvasElements({
        elementsMap,
        zoom,
        scrollX,
        scrollY,
        width,
        height,
      });

      return { elementsMap, visibleElements };
    });
  })();
}
```

## 2. 静态场景渲染

静态场景渲染处理不经常变化的内容，包括所有绘图元素的基本形状。

### 2.1 静态渲染核心流程

```typescript
// packages/excalidraw/renderer/staticScene.ts

export const renderStaticScene = ({
  canvas,
  elementsMap,
  appState,
  scale,
  renderConfig,
}: StaticSceneRenderConfig) => {
  const [normalizedWidth, normalizedHeight] = getNormalizedCanvasDimensions(
    canvas,
    scale
  );

  const context = bootstrapCanvas({
    canvas,
    scale,
    normalizedWidth,
    normalizedHeight,
    theme: appState.theme,
    isExporting: renderConfig.isExporting,
    viewBackgroundColor: appState.viewBackgroundColor,
  });

  // 1. 设置坐标系变换
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  context.scale(appState.zoom.value, appState.zoom.value);

  // 2. 渲染网格（如果启用）
  if (appState.gridSize && !renderConfig.isExporting) {
    renderGrid({
      context,
      gridSize: appState.gridSize,
      scrollX: appState.scrollX,
      scrollY: appState.scrollY,
      zoom: appState.zoom,
      width: normalizedWidth,
      height: normalizedHeight,
    });
  }

  // 3. 按层次渲染元素
  const visibleElements = getVisibleElements(elementsMap, appState);
  
  // 按 frameId 分组渲染（支持图层裁剪）
  const elementsInFrames = new Map<string | null, ExcalidrawElement[]>();
  
  for (const element of visibleElements) {
    const frameId = element.frameId || null;
    if (!elementsInFrames.has(frameId)) {
      elementsInFrames.set(frameId, []);
    }
    elementsInFrames.get(frameId)!.push(element);
  }

  // 渲染每个图层组
  for (const [frameId, elements] of elementsInFrames) {
    if (frameId) {
      // 应用框架裁剪
      const frame = elementsMap.get(frameId) as ExcalidrawFrameLikeElement;
      if (shouldApplyFrameClip(frame, appState)) {
        context.save();
        frameClip(frame, context, renderConfig, appState);
      }
    }

    // 渲染元素
    for (const element of elements) {
      renderElementToCanvas({
        element,
        context,
        appState,
        renderConfig,
        elementsMap,
      });
    }

    if (frameId) {
      context.restore();
    }
  }

  context.restore();
};

// 网格渲染
const renderGrid = ({
  context,
  gridSize,
  scrollX,
  scrollY,
  zoom,
  width,
  height,
}: GridRenderParams) => {
  const GridLineColor = {
    Bold: "#dddddd",
    Regular: "#e5e5e5",
  };

  const actualGridSize = gridSize * zoom.value;
  const offsetX = (scrollX % gridSize) - gridSize;
  const offsetY = (scrollY % gridSize) - gridSize;

  context.save();
  
  // 在100%缩放时偏移0.5px确保线条清晰
  if (zoom.value === 1) {
    context.translate(
      offsetX % 1 ? 0 : 0.5,
      offsetY % 1 ? 0 : 0.5
    );
  }

  // 渲染垂直网格线
  for (let x = offsetX; x < offsetX + width + gridSize * 2; x += gridSize) {
    const isBold = Math.round(x - scrollX) % (10 * gridSize) === 0;
    
    // 优化：缩放过小时不渲染细线
    if (!isBold && actualGridSize < 10) {
      continue;
    }

    context.beginPath();
    context.strokeStyle = isBold ? GridLineColor.Bold : GridLineColor.Regular;
    context.lineWidth = isBold ? 2 : 1;
    context.setLineDash(isBold ? [] : [3, 3]);
    context.moveTo(x, offsetY - gridSize);
    context.lineTo(x, offsetY + height + gridSize * 2);
    context.stroke();
  }

  // 渲染水平网格线（类似逻辑）
  // ...

  context.restore();
};
```

### 2.2 元素渲染核心

```typescript
// packages/element/src/renderElement.ts

export const renderElement = (
  element: NonDeletedExcalidrawElement,
  context: CanvasRenderingContext2D,
  appState: StaticCanvasAppState,
  renderConfig: StaticCanvasRenderConfig
) => {
  context.save();

  // 1. 应用元素变换
  const { x, y, angle } = element;
  context.translate(x, y);
  
  if (angle !== 0) {
    const centerX = element.width / 2;
    const centerY = element.height / 2;
    context.translate(centerX, centerY);
    context.rotate(angle);
    context.translate(-centerX, -centerY);
  }

  // 2. 设置绘制样式
  context.globalAlpha = element.opacity / 100;
  context.strokeStyle = element.strokeColor;
  context.fillStyle = element.backgroundColor;
  context.lineWidth = element.strokeWidth;
  
  // 设置线条样式
  switch (element.strokeStyle) {
    case "dashed":
      context.setLineDash([8, 6]);
      break;
    case "dotted":
      context.setLineDash([2, 6]);
      break;
    default:
      context.setLineDash([]);
  }

  // 3. 根据元素类型渲染
  switch (element.type) {
    case "rectangle":
      renderRectangle(element, context, renderConfig);
      break;
    case "ellipse":
      renderEllipse(element, context, renderConfig);
      break;
    case "diamond":
      renderDiamond(element, context, renderConfig);
      break;
    case "arrow":
    case "line":
      renderLinearElement(element, context, renderConfig);
      break;
    case "text":
      renderTextElement(element, context, appState, renderConfig);
      break;
    case "image":
      renderImageElement(element, context, appState, renderConfig);
      break;
    case "freedraw":
      renderFreedrawElement(element, context, renderConfig);
      break;
  }

  context.restore();
};

// RoughJS 集成渲染
const renderWithRoughJS = (
  element: ExcalidrawElement,
  context: CanvasRenderingContext2D,
  shape: Drawable
) => {
  // 检查缓存
  let drawable = ShapeCache.get(element, {
    roughness: element.roughness,
    strokeWidth: element.strokeWidth,
    seed: element.seed,
  });

  if (!drawable) {
    // 创建 RoughJS 形状
    const generator = rough.generator();
    
    switch (element.type) {
      case "rectangle":
        drawable = generator.rectangle(0, 0, element.width, element.height, {
          roughness: element.roughness,
          strokeWidth: element.strokeWidth,
          stroke: element.strokeColor,
          fill: element.backgroundColor,
          fillStyle: element.fillStyle,
          seed: element.seed,
        });
        break;
      case "ellipse":
        drawable = generator.ellipse(
          element.width / 2,
          element.height / 2,
          element.width,
          element.height,
          {
            roughness: element.roughness,
            strokeWidth: element.strokeWidth,
            stroke: element.strokeColor,
            fill: element.backgroundColor,
            fillStyle: element.fillStyle,
            seed: element.seed,
          }
        );
        break;
      // ... 其他形状
    }

    // 缓存形状
    ShapeCache.set(element, {
      roughness: element.roughness,
      strokeWidth: element.strokeWidth,
      seed: element.seed,
    }, drawable);
  }

  // 渲染形状
  const roughCanvas = rough.canvas(context.canvas);
  roughCanvas.draw(drawable);
};
```

## 3. 交互场景渲染

交互场景渲染处理所有动态的UI元素，如选择框、变换控制点、对齐线等。

### 3.1 交互渲染核心

```typescript
// packages/excalidraw/renderer/interactiveScene.ts

export const renderInteractiveScene = ({
  canvas,
  elementsMap,
  visibleElements,
  appState,
  renderConfig,
}: InteractiveSceneRenderConfig) => {
  const context = canvas.getContext("2d")!;
  const [width, height] = getNormalizedCanvasDimensions(canvas, appState.zoom.value);

  // 清除画布
  context.clearRect(0, 0, width, height);
  context.save();

  // 应用变换
  context.translate(appState.scrollX, appState.scrollY);
  context.scale(appState.zoom.value, appState.zoom.value);

  // 1. 渲染选择状态
  if (renderConfig.renderSelection) {
    renderSelectionElements({
      elements: visibleElements,
      appState,
      context,
      elementsMap,
    });
  }

  // 2. 渲染变换控制点
  renderTransformHandles({
    elements: visibleElements,
    appState,
    context,
    elementsMap,
  });

  // 3. 渲染绑定指示器
  if (renderConfig.renderBindings) {
    renderBindingIndicators({
      elements: visibleElements,
      appState,
      context,
      elementsMap,
    });
  }

  // 4. 渲染对齐线
  if (appState.snapLines) {
    renderSnapLines({
      snapLines: appState.snapLines,
      context,
      appState,
    });
  }

  // 5. 渲染协作者光标
  if (appState.collaborators.size > 0) {
    renderRemoteCursors({
      collaborators: appState.collaborators,
      context,
      appState,
    });
  }

  context.restore();
};

// 选择框渲染
const renderSelectionElements = ({
  elements,
  appState,
  context,
  elementsMap,
}: SelectionRenderParams) => {
  const selectedElements = getSelectedElements(elements, appState);
  
  if (selectedElements.length === 0) return;

  // 渲染多选时的边界框
  if (selectedElements.length > 1) {
    const [x1, y1, x2, y2] = getCommonBounds(selectedElements);
    
    context.save();
    context.strokeStyle = "#4285f4"; // Google Blue
    context.lineWidth = 1 / appState.zoom.value; // 保持1px宽度
    context.setLineDash([4 / appState.zoom.value, 4 / appState.zoom.value]);
    context.strokeRect(x1, y1, x2 - x1, y2 - y1);
    context.restore();
  }

  // 渲染每个选中元素的边界
  for (const element of selectedElements) {
    renderSelectionBorder({
      element,
      context,
      appState,
      elementsMap,
    });
  }
};

// 单个元素选择边界
const renderSelectionBorder = ({
  element,
  context,
  appState,
}: {
  element: ExcalidrawElement;
  context: CanvasRenderingContext2D;
  appState: InteractiveCanvasAppState;
}) => {
  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);
  const width = x2 - x1;
  const height = y2 - y1;

  context.save();
  context.translate(x1, y1);

  // 如果元素有旋转，需要考虑旋转
  if (element.angle !== 0) {
    const centerX = width / 2;
    const centerY = height / 2;
    context.translate(centerX, centerY);
    context.rotate(element.angle);
    context.translate(-centerX, -centerY);
  }

  // 绘制选择边界
  context.strokeStyle = "#4285f4";
  context.lineWidth = 1 / appState.zoom.value;
  context.setLineDash([]);
  
  if (element.type === "freedraw") {
    // 自由绘制使用虚线边界
    context.setLineDash([4 / appState.zoom.value, 4 / appState.zoom.value]);
  }

  context.strokeRect(0, 0, width, height);
  context.restore();
};
```

### 3.2 变换控制点渲染

```typescript
// 变换控制点渲染
const renderTransformHandles = ({
  elements,
  appState,
  context,
}: TransformHandlesRenderParams) => {
  const selectedElements = getSelectedElements(elements, appState);
  
  if (selectedElements.length === 0) return;
  
  // 获取变换控制点位置
  const transformHandles = getTransformHandles(selectedElements, appState.zoom);
  if (!transformHandles) return;

  const handleSize = 8 / appState.zoom.value; // 保持固定像素大小
  const handleStroke = 1 / appState.zoom.value;

  context.save();
  context.fillStyle = "#ffffff";
  context.strokeStyle = "#4285f4";
  context.lineWidth = handleStroke;

  // 渲染8个变换控制点
  const handles: TransformHandleType[] = [
    "nw", "n", "ne",
    "w",        "e",
    "sw", "s", "se"
  ];

  handles.forEach(handleType => {
    const handle = transformHandles[handleType];
    if (!handle) return;

    const [x, y] = handle;
    
    // 绘制控制点
    context.fillRect(
      x - handleSize / 2,
      y - handleSize / 2,
      handleSize,
      handleSize
    );
    context.strokeRect(
      x - handleSize / 2,
      y - handleSize / 2,
      handleSize,
      handleSize
    );
  });

  // 渲染旋转控制点（如果适用）
  if (transformHandles.rotation) {
    const [x, y] = transformHandles.rotation;
    const rotationHandleSize = 6 / appState.zoom.value;
    
    // 绘制圆形旋转控制点
    context.beginPath();
    context.arc(x, y, rotationHandleSize, 0, 2 * Math.PI);
    context.fill();
    context.stroke();
  }

  context.restore();
};
```

### 3.3 对齐线渲染

```typescript
// packages/excalidraw/renderer/renderSnaps.ts

export const renderSnapLines = ({
  snapLines,
  context,
  appState,
}: {
  snapLines: SnapLine[];
  context: CanvasRenderingContext2D;
  appState: InteractiveCanvasAppState;
}) => {
  if (snapLines.length === 0) return;

  context.save();
  context.strokeStyle = "#e91e63"; // Pink
  context.lineWidth = 1 / appState.zoom.value;
  context.setLineDash([4 / appState.zoom.value, 4 / appState.zoom.value]);

  snapLines.forEach(snapLine => {
    context.beginPath();
    
    if (snapLine.direction === "vertical") {
      // 垂直对齐线
      const x = snapLine.offset;
      context.moveTo(x, snapLine.start);
      context.lineTo(x, snapLine.end);
    } else {
      // 水平对齐线
      const y = snapLine.offset;
      context.moveTo(snapLine.start, y);
      context.lineTo(snapLine.end, y);
    }
    
    context.stroke();
  });

  context.restore();
};

// 绑定指示器渲染
const renderBindingIndicators = ({
  elements,
  appState,
  context,
  elementsMap,
}: BindingIndicatorsRenderParams) => {
  // 渲染箭头绑定点
  elements.forEach(element => {
    if (element.type === "arrow" && (element.startBinding || element.endBinding)) {
      renderArrowBindings({
        element: element as ExcalidrawArrowElement,
        context,
        appState,
        elementsMap,
      });
    }
  });

  // 渲染文本绑定指示器
  const editingTextElement = appState.editingTextElement;
  if (editingTextElement && editingTextElement.containerId) {
    const container = elementsMap.get(editingTextElement.containerId);
    if (container) {
      renderTextBinding({
        textElement: editingTextElement,
        container,
        context,
        appState,
      });
    }
  }
};

// 箭头绑定点渲染
const renderArrowBindings = ({
  element,
  context,
  appState,
  elementsMap,
}: {
  element: ExcalidrawArrowElement;
  context: CanvasRenderingContext2D;
  appState: InteractiveCanvasAppState;
  elementsMap: ElementsMap;
}) => {
  const bindingRadius = 4 / appState.zoom.value;
  
  context.save();
  context.fillStyle = "#4285f4";
  context.strokeStyle = "#ffffff";
  context.lineWidth = 1 / appState.zoom.value;

  // 起始绑定点
  if (element.startBinding) {
    const point = element.points[0];
    const x = element.x + point[0];
    const y = element.y + point[1];
    
    context.beginPath();
    context.arc(x, y, bindingRadius, 0, 2 * Math.PI);
    context.fill();
    context.stroke();
  }

  // 结束绑定点
  if (element.endBinding) {
    const point = element.points[element.points.length - 1];
    const x = element.x + point[0];
    const y = element.y + point[1];
    
    context.beginPath();
    context.arc(x, y, bindingRadius, 0, 2 * Math.PI);
    context.fill();
    context.stroke();
  }

  context.restore();
};
```

## 4. RoughJS 集成

Excalidraw 使用 RoughJS 库来实现手绘风格的渲染效果。

### 4.1 RoughJS 封装

```typescript
// packages/excalidraw/rough.ts

export class RoughRenderer {
  private generator: RoughGenerator;
  private canvas: RoughCanvas;

  constructor(canvas: HTMLCanvasElement) {
    this.generator = rough.generator();
    this.canvas = rough.canvas(canvas);
  }

  // 渲染矩形
  renderRectangle(
    element: ExcalidrawRectangleElement,
    context: CanvasRenderingContext2D
  ) {
    const shape = this.generator.rectangle(
      0, 0,
      element.width,
      element.height,
      this.getDrawOptions(element)
    );
    
    this.canvas.draw(shape);
  }

  // 渲染椭圆
  renderEllipse(
    element: ExcalidrawEllipseElement,
    context: CanvasRenderingContext2D
  ) {
    const shape = this.generator.ellipse(
      element.width / 2,
      element.height / 2,
      element.width,
      element.height,
      this.getDrawOptions(element)
    );
    
    this.canvas.draw(shape);
  }

  // 渲染菱形
  renderDiamond(
    element: ExcalidrawDiamondElement,
    context: CanvasRenderingContext2D
  ) {
    const points = getDiamondPoints(element);
    const shape = this.generator.polygon(
      points.map(([x, y]) => [x, y]),
      this.getDrawOptions(element)
    );
    
    this.canvas.draw(shape);
  }

  // 渲染线条
  renderLine(
    element: ExcalidrawLinearElement,
    context: CanvasRenderingContext2D
  ) {
    const points = element.points;
    
    if (points.length < 2) return;

    // 单线段
    if (points.length === 2) {
      const shape = this.generator.line(
        points[0][0], points[0][1],
        points[1][0], points[1][1],
        this.getDrawOptions(element)
      );
      this.canvas.draw(shape);
      return;
    }

    // 多线段路径
    const path = this.generatePath(points);
    const shape = this.generator.path(path, this.getDrawOptions(element));
    this.canvas.draw(shape);
  }

  // 获取 RoughJS 绘制选项
  private getDrawOptions(element: ExcalidrawElement): Options {
    return {
      seed: element.seed,              // 随机种子
      roughness: element.roughness,    // 粗糙度
      strokeWidth: element.strokeWidth, // 线宽
      stroke: element.strokeColor,     // 描边色
      fill: element.backgroundColor === "transparent" ? undefined : element.backgroundColor,
      fillStyle: element.fillStyle,   // 填充样式
      hachureAngle: element.seed % 180, // 填充角度
      hachureGap: element.strokeWidth * 2, // 填充间隙
    };
  }

  // 生成SVG路径字符串
  private generatePath(points: readonly LocalPoint[]): string {
    let path = `M ${points[0][0]} ${points[0][1]}`;
    
    for (let i = 1; i < points.length; i++) {
      path += ` L ${points[i][0]} ${points[i][1]}`;
    }
    
    return path;
  }
}
```

### 4.2 性能优化策略

```typescript
// 形状缓存系统
export class ShapeCache {
  private static cache = new Map<string, Drawable>();
  private static maxCacheSize = 1000;

  // 生成缓存键
  static generateKey(
    element: ExcalidrawElement,
    renderConfig: RenderConfig
  ): string {
    // 基于元素属性和渲染配置生成键
    return `${element.id}-${element.version}-${renderConfig.roughness}-${renderConfig.strokeWidth}-${element.seed}`;
  }

  // 获取缓存的形状
  static get(element: ExcalidrawElement, renderConfig: RenderConfig): Drawable | undefined {
    const key = this.generateKey(element, renderConfig);
    const cached = this.cache.get(key);
    
    if (cached) {
      // 更新访问时间（LRU策略）
      this.cache.delete(key);
      this.cache.set(key, cached);
      return cached;
    }
    
    return undefined;
  }

  // 设置缓存
  static set(
    element: ExcalidrawElement,
    renderConfig: RenderConfig,
    shape: Drawable
  ): void {
    // 检查缓存大小限制
    if (this.cache.size >= this.maxCacheSize) {
      // 删除最老的条目（LRU）
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }

    const key = this.generateKey(element, renderConfig);
    this.cache.set(key, shape);
  }

  // 清理特定元素的缓存
  static deleteElement(elementId: string): void {
    const keysToDelete: string[] = [];
    
    for (const key of this.cache.keys()) {
      if (key.startsWith(`${elementId}-`)) {
        keysToDelete.push(key);
      }
    }
    
    keysToDelete.forEach(key => this.cache.delete(key));
  }

  // 清空所有缓存
  static clear(): void {
    this.cache.clear();
  }
}

// 使用形状缓存的渲染流程
const renderElementWithCache = (
  element: ExcalidrawElement,
  context: CanvasRenderingContext2D,
  renderConfig: RenderConfig
) => {
  // 尝试从缓存获取
  let shape = ShapeCache.get(element, renderConfig);

  if (!shape) {
    // 缓存未命中，生成新形状
    const generator = rough.generator();
    
    switch (element.type) {
      case "rectangle":
        shape = generator.rectangle(/* ... */);
        break;
      case "ellipse":
        shape = generator.ellipse(/* ... */);
        break;
      // ... 其他形状
    }

    // 保存到缓存
    if (shape) {
      ShapeCache.set(element, renderConfig, shape);
    }
  }

  // 渲染形状
  if (shape) {
    const roughCanvas = rough.canvas(context.canvas);
    roughCanvas.draw(shape);
  }
};
```

## 5. 视口优化

### 5.1 视口裁剪

```typescript
// packages/excalidraw/scene/viewport.ts

// 视口边界检测
export const isElementInViewport = (
  element: ExcalidrawElement,
  canvasWidth: number,
  canvasHeight: number,
  viewportParams: {
    zoom: Zoom;
    scrollX: number;
    scrollY: number;
  },
  elementsMap?: ElementsMap
): boolean => {
  // 计算视口边界（场景坐标系）
  const viewportBounds = {
    x1: -viewportParams.scrollX,
    y1: -viewportParams.scrollY,
    x2: -viewportParams.scrollX + canvasWidth / viewportParams.zoom.value,
    y2: -viewportParams.scrollY + canvasHeight / viewportParams.zoom.value,
  };

  // 获取元素边界
  const [elementX1, elementY1, elementX2, elementY2] = getElementAbsoluteCoords(
    element,
    elementsMap
  );

  // AABB碰撞检测
  return !(
    elementX2 < viewportBounds.x1 ||
    elementX1 > viewportBounds.x2 ||
    elementY2 < viewportBounds.y1 ||
    elementY1 > viewportBounds.y2
  );
};

// 获取可见元素（带边距）
export const getVisibleElements = (
  elements: readonly ExcalidrawElement[],
  canvasWidth: number,
  canvasHeight: number,
  viewportParams: ViewportParams,
  padding: number = 100 // 边距，提前渲染即将进入视口的元素
): ExcalidrawElement[] => {
  const paddedViewport = {
    ...viewportParams,
    scrollX: viewportParams.scrollX - padding,
    scrollY: viewportParams.scrollY - padding,
  };

  const paddedWidth = canvasWidth + padding * 2;
  const paddedHeight = canvasHeight + padding * 2;

  return elements.filter(element =>
    !element.isDeleted &&
    isElementInViewport(element, paddedWidth, paddedHeight, paddedViewport)
  );
};
```

### 5.2 渲染优化

```typescript
// 分层渲染优化
class LayeredRenderer {
  private layers: Map<string, HTMLCanvasElement> = new Map();
  private dirtyLayers: Set<string> = new Set();

  // 根据元素类型分层
  private getElementLayer(element: ExcalidrawElement): string {
    if (element.type === "text") return "text";
    if (element.type === "image") return "image"; 
    if (element.type === "freedraw") return "freedraw";
    return "shapes";
  }

  // 标记图层为脏
  markLayerDirty(layerName: string): void {
    this.dirtyLayers.add(layerName);
  }

  // 渲染所有脏图层
  renderDirtyLayers(
    elements: readonly ExcalidrawElement[],
    appState: AppState
  ): void {
    // 按图层分组元素
    const elementsByLayer = new Map<string, ExcalidrawElement[]>();

    elements.forEach(element => {
      const layer = this.getElementLayer(element);
      if (!elementsByLayer.has(layer)) {
        elementsByLayer.set(layer, []);
      }
      elementsByLayer.get(layer)!.push(element);
    });

    // 只重绘脏图层
    for (const layerName of this.dirtyLayers) {
      const canvas = this.layers.get(layerName);
      const layerElements = elementsByLayer.get(layerName) || [];

      if (canvas && layerElements.length > 0) {
        this.renderLayer(canvas, layerElements, appState);
      }
    }

    this.dirtyLayers.clear();
  }

  private renderLayer(
    canvas: HTMLCanvasElement,
    elements: ExcalidrawElement[],
    appState: AppState
  ): void {
    const context = canvas.getContext("2d")!;
    context.clearRect(0, 0, canvas.width, canvas.height);

    // 渲染图层元素
    elements.forEach(element => {
      renderElement(element, context, appState, {
        isExporting: false,
        canvasBackgroundColor: appState.viewBackgroundColor,
      });
    });
  }
}

// 渐进式渲染
class ProgressiveRenderer {
  private renderQueue: ExcalidrawElement[] = [];
  private rendering = false;

  // 添加元素到渲染队列
  queueElements(elements: ExcalidrawElement[]): void {
    this.renderQueue.push(...elements);
    
    if (!this.rendering) {
      this.startRendering();
    }
  }

  private async startRendering(): Promise<void> {
    this.rendering = true;

    while (this.renderQueue.length > 0) {
      // 每帧渲染固定数量的元素
      const batchSize = 10;
      const batch = this.renderQueue.splice(0, batchSize);

      // 渲染批次
      batch.forEach(element => {
        this.renderElement(element);
      });

      // 让出控制权给浏览器
      await new Promise(resolve => requestAnimationFrame(resolve));
    }

    this.rendering = false;
  }

  private renderElement(element: ExcalidrawElement): void {
    // 实际渲染逻辑
    // ...
  }
}
```

## 6. 性能监控和调试

```typescript
// 渲染性能监控
class RenderProfiler {
  private metrics = new Map<string, number[]>();

  // 开始计时
  startTiming(label: string): () => void {
    const start = performance.now();
    
    return () => {
      const duration = performance.now() - start;
      this.recordMetric(label, duration);
    };
  }

  // 记录指标
  private recordMetric(label: string, duration: number): void {
    if (!this.metrics.has(label)) {
      this.metrics.set(label, []);
    }

    const measurements = this.metrics.get(label)!;
    measurements.push(duration);

    // 保持最近100次测量
    if (measurements.length > 100) {
      measurements.shift();
    }
  }

  // 获取性能报告
  getReport(): Record<string, PerformanceMetrics> {
    const report: Record<string, PerformanceMetrics> = {};

    this.metrics.forEach((measurements, label) => {
      const sorted = [...measurements].sort((a, b) => a - b);
      const len = sorted.length;

      report[label] = {
        count: len,
        min: sorted[0],
        max: sorted[len - 1],
        avg: measurements.reduce((a, b) => a + b, 0) / len,
        p50: sorted[Math.floor(len * 0.5)],
        p90: sorted[Math.floor(len * 0.9)],
        p99: sorted[Math.floor(len * 0.99)],
      };
    });

    return report;
  }
}

// 使用示例
const profiler = new RenderProfiler();

const renderWithProfiling = (elements: ExcalidrawElement[], appState: AppState) => {
  const endTiming = profiler.startTiming("total-render");
  
  try {
    const staticEndTiming = profiler.startTiming("static-render");
    renderStaticScene(/* ... */);
    staticEndTiming();

    const interactiveEndTiming = profiler.startTiming("interactive-render");
    renderInteractiveScene(/* ... */);
    interactiveEndTiming();

  } finally {
    endTiming();
  }

  // 定期输出性能报告
  if (Math.random() < 0.01) { // 1%几率
    console.table(profiler.getReport());
  }
};
```

## 总结

Excalidraw 的渲染引擎体现了以下优秀的设计原则：

1. **分层架构** - 静态/交互/SVG三层分离，最优化渲染性能
2. **视口优化** - 只渲染可见元素，大幅减少不必要的计算
3. **缓存策略** - RoughJS形状缓存，避免重复生成图形
4. **渐进渲染** - 大量元素时分批渲染，保持UI响应
5. **性能监控** - 内建性能测量，便于优化和调试

这种架构设计使得 Excalidraw 即使在处理大量复杂图形时，依然能保持流畅的用户体验。对于二次开发，理解这套渲染机制将帮助你更好地扩展功能和优化性能。