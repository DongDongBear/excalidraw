# Excalidraw 元素系统详解

## 1. 元素架构概述

Excalidraw 的元素系统是整个绘图引擎的核心。它采用了类型安全的设计，通过 TypeScript 严格的类型系统确保数据的一致性和可靠性。

### 1.1 元素基础结构

所有元素都继承自基础元素类型：

```typescript
// packages/element/src/types.ts
type _ExcalidrawElementBase = Readonly<{
  // === 身份信息 ===
  id: string;                          // 唯一标识符
  type: string;                        // 元素类型
  
  // === 几何信息 ===
  x: number;                          // X坐标
  y: number;                          // Y坐标  
  width: number;                      // 宽度
  height: number;                     // 高度
  angle: Radians;                     // 旋转角度（弧度）
  
  // === 视觉样式 ===
  strokeColor: string;                // 描边颜色
  backgroundColor: string;            // 背景颜色
  fillStyle: FillStyle;              // 填充样式 ("hachure" | "cross-hatch" | "solid" | "zigzag")
  strokeWidth: number;               // 描边宽度
  strokeStyle: StrokeStyle;          // 描边样式 ("solid" | "dashed" | "dotted")
  roughness: number;                 // 粗糙度 (0-10, 控制手绘感)
  opacity: number;                   // 透明度 (0-100)
  roundness: null | { type: RoundnessType; value?: number }; // 圆角
  
  // === 版本控制（协作用）===
  seed: number;                      // 随机种子（确保渲染一致性）
  version: number;                   // 版本号（递增）
  versionNonce: number;              // 版本随机数（冲突解决）
  updated: number;                   // 更新时间戳
  
  // === 层次结构 ===
  index: FractionalIndex | null;     // 分数索引（用于排序）
  isDeleted: boolean;                // 软删除标记
  groupIds: readonly GroupId[];      // 所属的组ID列表
  frameId: string | null;            // 所属的框架ID
  
  // === 关系绑定 ===
  boundElements: readonly BoundElement[] | null;  // 绑定的其他元素
  
  // === 扩展功能 ===
  link: string | null;               // 超链接
  locked: boolean;                   // 锁定状态（不可编辑）
  customData?: Record<string, any>;  // 自定义数据（扩展用）
}>;
```

### 1.2 具体元素类型

基于基础类型，Excalidraw 定义了各种具体的元素类型：

```typescript
// 基础图形元素
export type ExcalidrawRectangleElement = _ExcalidrawElementBase & {
  type: "rectangle";
};

export type ExcalidrawEllipseElement = _ExcalidrawElementBase & {
  type: "ellipse";
};

export type ExcalidrawDiamondElement = _ExcalidrawElementBase & {
  type: "diamond";
};

// 文本元素 - 扩展了文本相关属性
export type ExcalidrawTextElement = _ExcalidrawElementBase & {
  type: "text";
  fontSize: number;                    // 字体大小
  fontFamily: FontFamilyValues;        // 字体家族 (1=Virgil, 2=Helvetica, 3=Cascadia)
  text: string;                        // 文本内容
  textAlign: TextAlign;                // 水平对齐 ("left" | "center" | "right")
  verticalAlign: VerticalAlign;        // 垂直对齐 ("top" | "middle")
  containerId: string | null;          // 容器元素ID（文本框）
  originalText: string;                // 原始文本（换行处理前）
  autoResize: boolean;                 // 自动调整大小
  baseline: number;                    // 基线
  lineHeight: number;                  // 行高
};

// 线性元素 - 具有点集合的元素
export type ExcalidrawLinearElement = _ExcalidrawElementBase & {
  type: "arrow" | "line" | "freedraw";
  points: readonly LocalPoint[];        // 点集合
  lastCommittedPoint?: LocalPoint | null; // 最后确定的点（编辑时用）
  startBinding?: PointBinding | null;     // 起始绑定
  endBinding?: PointBinding | null;       // 结束绑定
  startArrowhead?: Arrowhead | null;      // 起始箭头
  endArrowhead?: Arrowhead | null;        // 结束箭头
};

// 图片元素
export type ExcalidrawImageElement = _ExcalidrawElementBase & {
  type: "image";
  fileId: FileId | null;               // 文件ID
  status: "pending" | "saved" | "error"; // 状态
  scale: [number, number];             // 缩放比例 [x, y]
  crop?: ImageCrop;                    // 裁剪信息
};

// 嵌入式元素（iframe等）
export type ExcalidrawEmbeddableElement = _ExcalidrawElementBase & {
  type: "embeddable";
  validated: boolean;                  // 是否已验证
  intrinsicSize?: { w: number; h: number }; // 固有尺寸
};

// 框架元素（用于分组和布局）
export type ExcalidrawFrameElement = _ExcalidrawElementBase & {
  type: "frame";
  name: string | null;                 // 框架名称
};
```

## 2. 元素创建机制

### 2.1 核心创建函数

```typescript
// packages/element/src/newElement.ts

// 基础创建函数 - 所有元素的创建都基于此函数
const _newElementBase = <T extends ExcalidrawElement>(
  type: T["type"],
  {
    x,
    y,
    strokeColor = DEFAULT_ELEMENT_PROPS.strokeColor,        // "#000000"
    backgroundColor = DEFAULT_ELEMENT_PROPS.backgroundColor, // "transparent" 
    fillStyle = DEFAULT_ELEMENT_PROPS.fillStyle,            // "hachure"
    strokeWidth = DEFAULT_ELEMENT_PROPS.strokeWidth,        // 1
    strokeStyle = DEFAULT_ELEMENT_PROPS.strokeStyle,        // "solid"
    roughness = DEFAULT_ELEMENT_PROPS.roughness,            // 1
    opacity = DEFAULT_ELEMENT_PROPS.opacity,                // 100
    width = 0,
    height = 0,
    angle = 0 as Radians,
    groupIds = [],
    frameId = null,
    index = null,
    roundness = null,
    boundElements = null,
    link = null,
    locked = DEFAULT_ELEMENT_PROPS.locked,                  // false
    ...rest
  }: ElementConstructorOpts
) => {
  // 防止极大值导致渲染问题
  if (x < -1e6 || x > 1e6 || y < -1e6 || y > 1e6 || 
      width < -1e6 || width > 1e6 || height < -1e6 || height > 1e6) {
    console.error("New element size or position is too large", {
      x, y, width, height
    });
  }

  // 创建完整的元素对象
  const element = {
    id: rest.id || randomId(),           // 生成唯一ID
    type,
    x, y, width, height, angle,
    strokeColor, backgroundColor, fillStyle,
    strokeWidth, strokeStyle, roughness, opacity,
    groupIds, frameId, index, roundness,
    seed: rest.seed ?? randomInteger(),   // 随机种子确保渲染一致性
    version: rest.version || 1,          // 初始版本
    versionNonce: rest.versionNonce ?? 0, // 版本随机数
    isDeleted: false,
    boundElements,
    updated: getUpdatedTimestamp(),      // 当前时间戳
    link, locked,
    customData: rest.customData,
  };
  
  return element;
};

// 通用元素创建
export const newElement = (
  opts: { type: ExcalidrawGenericElement["type"] } & ElementConstructorOpts
): NonDeleted<ExcalidrawGenericElement> =>
  _newElementBase<ExcalidrawGenericElement>(opts.type, opts);
```

### 2.2 特定元素创建函数

```typescript
// 文本元素创建 - 复杂的计算逻辑
export const newTextElement = (
  opts: {
    text: string;
    originalText?: string;
    fontSize?: number;
    fontFamily?: FontFamilyValues;
    textAlign?: TextAlign;
    verticalAlign?: VerticalAlign;
    containerId?: ExcalidrawTextContainer["id"] | null;
    lineHeight?: ExcalidrawTextElement["lineHeight"];
    autoResize?: ExcalidrawTextElement["autoResize"];
  } & ElementConstructorOpts
): NonDeleted<ExcalidrawTextElement> => {
  const fontFamily = opts.fontFamily || DEFAULT_FONT_FAMILY; // 1 (Virgil)
  const fontSize = opts.fontSize || DEFAULT_FONT_SIZE;       // 20
  const lineHeight = opts.lineHeight || getLineHeight(fontFamily); // 1.25
  
  // 文本标准化（处理换行等）
  const text = normalizeText(opts.text);
  
  // 测量文本尺寸
  const metrics = measureText(
    text,
    getFontString({ fontFamily, fontSize }), // "20px Virgil"
    lineHeight
  );
  
  const textAlign = opts.textAlign || DEFAULT_TEXT_ALIGN;         // "left"
  const verticalAlign = opts.verticalAlign || DEFAULT_VERTICAL_ALIGN; // "top"
  
  // 根据对齐方式计算位置偏移
  const offsets = getTextElementPositionOffsets(
    { textAlign, verticalAlign },
    metrics
  );

  const textElementProps: ExcalidrawTextElement = {
    ..._newElementBase<ExcalidrawTextElement>("text", opts),
    text,
    fontSize,
    fontFamily,
    textAlign,
    verticalAlign,
    x: opts.x - offsets.x,    // 调整X坐标以匹配对齐
    y: opts.y - offsets.y,    // 调整Y坐标以匹配对齐
    width: metrics.width,     // 使用测量的宽度
    height: metrics.height,   // 使用测量的高度
    containerId: opts.containerId || null,
    originalText: opts.originalText ?? text,
    autoResize: opts.autoResize ?? true,
    lineHeight,
  };

  // 使用 newElementWith 创建最终元素（可能触发额外处理）
  return newElementWith(textElementProps, {});
};

// 线性元素创建（箭头、线条等）
export const newLinearElement = (
  opts: {
    type: ExcalidrawLinearElement["type"];
    startArrowhead?: Arrowhead | null;
    endArrowhead?: Arrowhead | null;
    points?: readonly LocalPoint[];
  } & ElementConstructorOpts
): NonDeleted<ExcalidrawLinearElement> => {
  const { type, startArrowhead = null, endArrowhead = null, ...rest } = opts;
  
  // 默认两点：起点和终点
  const points = opts.points || [[0, 0], [100, 100] as LocalPoint];
  
  // 根据点计算边界框
  const { width, height } = getSizeFromPoints(points);
  
  return {
    ..._newElementBase<ExcalidrawLinearElement>(type, { ...rest, width, height }),
    points,
    lastCommittedPoint: null,
    startBinding: null,
    endBinding: null,
    startArrowhead,
    endArrowhead,
  };
};

// 箭头元素创建
export const newArrowElement = (
  opts: ElementConstructorOpts
): NonDeleted<ExcalidrawArrowElement> =>
  newLinearElement({
    type: "arrow",
    startArrowhead: null,        // 起始无箭头
    endArrowhead: "arrow",       // 结尾有箭头
    ...opts,
  });

// 自由绘制元素创建
export const newFreeDrawElement = (
  opts: {
    type: "freedraw";
    points: ExcalidrawFreeDrawElement["points"];
    simulatePressure?: ExcalidrawFreeDrawElement["simulatePressure"];
    pressures?: ExcalidrawFreeDrawElement["pressures"];
  } & ElementConstructorOpts
): NonDeleted<ExcalidrawFreeDrawElement> => {
  return {
    ..._newElementBase<ExcalidrawFreeDrawElement>("freedraw", opts),
    points: opts.points,
    lastCommittedPoint: null,
    simulatePressure: opts.simulatePressure ?? false,
    pressures: opts.pressures || [],
  };
};
```

## 3. 元素变更机制

### 3.1 不可变更新模式

Excalidraw 采用不可变数据模式，所有元素更新都创建新对象：

```typescript
// packages/element/src/mutateElement.ts

// 元素更新的核心函数
export const mutateElement = <TElement extends Mutable<ExcalidrawElement>>(
  element: TElement,
  elementsMap: ElementsMap,
  updates: ElementUpdate<TElement>,
  options?: { isDragging?: boolean }
) => {
  let didChange = false;

  // 特殊处理：肘形箭头的点更新
  if (isElbowArrow(element) && /* 需要更新点位 */) {
    updates = {
      ...updates,
      angle: 0 as Radians,
      ...updateElbowArrowPoints(element, elementsMap, updates, options),
    };
  } 
  // 特殊处理：普通线性元素的点更新
  else if (typeof updates.points !== "undefined") {
    // 根据点重新计算尺寸
    updates = { 
      ...getSizeFromPoints(updates.points), 
      ...updates 
    };
  }

  // 逐一应用更新
  for (const key in updates) {
    const value = updates[key];
    
    if (typeof value === "undefined") continue;

    // 值未变化则跳过（对象类型除外）
    if (element[key] === value && 
        (typeof value !== "object" || value === null || 
         key === "groupIds" || key === "scale")) {
      continue;
    }

    // 特殊比较：scale 数组
    if (key === "scale") {
      const prevScale = element[key];
      const nextScale = value;
      if (prevScale[0] === nextScale[0] && prevScale[1] === nextScale[1]) {
        continue;
      }
    }

    // 特殊比较：points 数组
    if (key === "points") {
      const prevPoints = element[key];
      if (prevPoints && JSON.stringify(prevPoints) === JSON.stringify(value)) {
        continue;
      }
    }

    // 应用更新
    (element as any)[key] = value;
    didChange = true;
  }

  // 如果有变化，更新版本信息
  if (didChange) {
    element.version++;
    element.updated = getUpdatedTimestamp();
    
    // 清除形状缓存（重新渲染）
    ShapeCache.delete(element);
    
    // 特殊处理：清除文本元素的边界缓存
    if (element.type === "text") {
      ShapeCache.deleteWithBoundTextCache(element.id);
    }
  }

  return didChange;
};

// 高级更新函数 - 创建新元素而不是修改现有元素
export const newElementWith = <TElement extends ExcalidrawElement>(
  element: TElement,
  updates: ElementUpdate<TElement>
): TElement => {
  let didChange = false;
  
  // 处理特殊更新逻辑（与 mutateElement 类似）
  // ...

  // 如果有变化，创建新元素
  if (didChange || Object.keys(updates).length > 0) {
    const newElement = {
      ...element,
      ...updates,
      version: element.version + 1,
      updated: getUpdatedTimestamp(),
    };

    return newElement;
  }

  return element;
};
```

### 3.2 批量更新操作

```typescript
// 批量更新多个元素
export const updateElements = (
  elements: readonly ExcalidrawElement[],
  updates: Map<string, ElementUpdate<any>>
): ExcalidrawElement[] => {
  return elements.map(element => {
    const update = updates.get(element.id);
    if (update) {
      return newElementWith(element, update);
    }
    return element;
  });
};

// 软删除元素
export const deleteElements = (
  elements: readonly ExcalidrawElement[],
  elementIds: Set<string>
): ExcalidrawElement[] => {
  return elements.map(element => {
    if (elementIds.has(element.id)) {
      return newElementWith(element, { isDeleted: true });
    }
    return element;
  });
};
```

## 4. 元素操作系统

### 4.1 几何操作

```typescript
// packages/element/src/bounds.ts

// 获取元素的绝对坐标边界
export const getElementAbsoluteCoords = (
  element: ExcalidrawElement
): [number, number, number, number] => {
  // 对于线性元素，需要考虑所有点的位置
  if (isLinearElement(element)) {
    const points = element.points;
    let minX = Infinity, minY = Infinity;
    let maxX = -Infinity, maxY = -Infinity;

    points.forEach(([x, y]) => {
      minX = Math.min(minX, element.x + x);
      minY = Math.min(minY, element.y + y);
      maxX = Math.max(maxX, element.x + x);
      maxY = Math.max(maxY, element.y + y);
    });

    return [minX, minY, maxX, maxY];
  }

  // 对于矩形元素，需要考虑旋转
  if (element.angle !== 0) {
    const corners = getElementCorners(element);
    let minX = Infinity, minY = Infinity;
    let maxX = -Infinity, maxY = -Infinity;

    corners.forEach(([x, y]) => {
      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x);
      maxY = Math.max(maxY, y);
    });

    return [minX, minY, maxX, maxY];
  }

  // 简单情况：无旋转的矩形
  return [
    element.x,
    element.y,
    element.x + element.width,
    element.y + element.height,
  ];
};

// 获取多个元素的共同边界
export const getCommonBounds = (
  elements: readonly ExcalidrawElement[]
): [number, number, number, number] => {
  if (elements.length === 0) {
    return [0, 0, 0, 0];
  }

  let minX = Infinity, minY = Infinity;
  let maxX = -Infinity, maxY = -Infinity;

  elements.forEach(element => {
    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);
    minX = Math.min(minX, x1);
    minY = Math.min(minY, y1);
    maxX = Math.max(maxX, x2);
    maxY = Math.max(maxY, y2);
  });

  return [minX, minY, maxX, maxY];
};
```

### 4.2 碰撞检测

```typescript
// packages/element/src/collision.ts

// 点与元素的碰撞检测
export const hitTest = (
  element: NonDeletedExcalidrawElement,
  x: number,
  y: number,
  shape?: Drawable
): boolean => {
  // 快速边界框检测
  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);
  if (x < x1 || x > x2 || y < y1 || y > y2) {
    return false;
  }

  // 根据元素类型进行精确检测
  switch (element.type) {
    case "rectangle":
    case "diamond":
    case "ellipse": {
      return hitTestRectangularShape(element, x, y, shape);
    }
    case "arrow":
    case "line":
    case "freedraw": {
      return hitTestLinearElement(element, x, y);
    }
    case "text": {
      return hitTestText(element, x, y);
    }
    case "image":
    case "embeddable":
    case "frame": {
      return hitTestRectangularShape(element, x, y, shape);
    }
  }
  
  return false;
};

// 线性元素的碰撞检测
const hitTestLinearElement = (
  element: ExcalidrawLinearElement,
  x: number,
  y: number
): boolean => {
  const points = element.points;
  const threshold = Math.max(element.strokeWidth / 2, 4); // 最小4px的点击区域

  for (let i = 0; i < points.length - 1; i++) {
    const [x1, y1] = points[i];
    const [x2, y2] = points[i + 1];
    
    // 计算点到线段的距离
    const distance = distanceToLine(
      x - element.x, y - element.y,  // 转换为元素本地坐标
      x1, y1, x2, y2
    );
    
    if (distance <= threshold) {
      return true;
    }
  }
  
  return false;
};

// 点到线段的距离计算
const distanceToLine = (
  px: number, py: number,
  x1: number, y1: number,
  x2: number, y2: number
): number => {
  const A = px - x1;
  const B = py - y1;
  const C = x2 - x1;
  const D = y2 - y1;

  const dot = A * C + B * D;
  const lenSq = C * C + D * D;
  let param = -1;
  
  if (lenSq !== 0) {
    param = dot / lenSq;
  }

  let xx, yy;
  if (param < 0) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x2;
    yy = y2;
  } else {
    xx = x1 + param * C;
    yy = y1 + param * D;
  }

  const dx = px - xx;
  const dy = py - yy;
  
  return Math.sqrt(dx * dx + dy * dy);
};
```

### 4.3 元素变换操作

```typescript
// packages/element/src/transform.ts

// 旋转元素
export const rotateElement = (
  element: ExcalidrawElement,
  angle: Radians,
  center?: { x: number; y: number }
): ExcalidrawElement => {
  if (angle === 0) return element;

  const rotationCenter = center || {
    x: element.x + element.width / 2,
    y: element.y + element.height / 2,
  };

  // 计算元素中心到旋转中心的偏移
  const elementCenter = {
    x: element.x + element.width / 2,
    y: element.y + element.height / 2,
  };

  // 旋转元素中心点
  const rotatedCenter = rotatePoint(elementCenter, rotationCenter, angle);

  return newElementWith(element, {
    x: rotatedCenter.x - element.width / 2,
    y: rotatedCenter.y - element.height / 2,
    angle: (element.angle + angle) as Radians,
  });
};

// 缩放元素
export const resizeElement = (
  element: ExcalidrawElement,
  direction: ResizeDirection,
  deltaX: number,
  deltaY: number,
  keepAspectRatio: boolean = false
): ExcalidrawElement => {
  let newWidth = element.width;
  let newHeight = element.height;
  let newX = element.x;
  let newY = element.y;

  // 根据缩放方向调整尺寸和位置
  switch (direction) {
    case "nw": {
      newWidth -= deltaX;
      newHeight -= deltaY;
      newX += deltaX;
      newY += deltaY;
      break;
    }
    case "ne": {
      newWidth += deltaX;
      newHeight -= deltaY;
      newY += deltaY;
      break;
    }
    case "sw": {
      newWidth -= deltaX;
      newHeight += deltaY;
      newX += deltaX;
      break;
    }
    case "se": {
      newWidth += deltaX;
      newHeight += deltaY;
      break;
    }
    // ... 其他方向
  }

  // 保持长宽比
  if (keepAspectRatio) {
    const aspectRatio = element.width / element.height;
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
      newHeight = newWidth / aspectRatio;
    } else {
      newWidth = newHeight * aspectRatio;
    }
  }

  // 最小尺寸限制
  newWidth = Math.max(newWidth, 1);
  newHeight = Math.max(newHeight, 1);

  return newElementWith(element, {
    x: newX,
    y: newY,
    width: newWidth,
    height: newHeight,
  });
};
```

## 5. 元素绑定系统

### 5.1 文本绑定

```typescript
// packages/element/src/binding.ts

// 文本元素与容器的绑定
export const bindTextToContainer = (
  textElement: ExcalidrawTextElement,
  container: ExcalidrawElement
): void => {
  // 将文本元素放置在容器中心
  const containerCenter = {
    x: container.x + container.width / 2,
    y: container.y + container.height / 2,
  };

  // 计算文本位置
  const textX = containerCenter.x - textElement.width / 2;
  const textY = containerCenter.y - textElement.height / 2;

  // 更新文本元素
  mutateElement(textElement, {
    x: textX,
    y: textY,
    containerId: container.id,
  });

  // 更新容器元素的绑定关系
  const boundElements = container.boundElements || [];
  const newBoundElements = [
    ...boundElements.filter(be => be.id !== textElement.id),
    { id: textElement.id, type: "text" }
  ];

  mutateElement(container, {
    boundElements: newBoundElements,
  });
};

// 解除文本绑定
export const unbindTextFromContainer = (
  textElement: ExcalidrawTextElement,
  container: ExcalidrawElement
): void => {
  mutateElement(textElement, {
    containerId: null,
  });

  const boundElements = container.boundElements || [];
  const newBoundElements = boundElements.filter(be => be.id !== textElement.id);

  mutateElement(container, {
    boundElements: newBoundElements.length > 0 ? newBoundElements : null,
  });
};
```

### 5.2 箭头绑定

```typescript
// 箭头与元素的绑定
export const bindArrowToElement = (
  arrow: ExcalidrawArrowElement,
  element: ExcalidrawElement,
  bindingType: "start" | "end"
): void => {
  const bindingPoint = bindingType === "start" ? arrow.points[0] : arrow.points[arrow.points.length - 1];
  
  // 计算绑定点在目标元素上的位置
  const bindingPosition = getBindingPosition(element, {
    x: arrow.x + bindingPoint[0],
    y: arrow.y + bindingPoint[1],
  });

  const binding: PointBinding = {
    elementId: element.id,
    focus: bindingPosition.focus,    // 焦点位置（0-1范围）
    gap: bindingPosition.gap,        // 与边界的间隙
  };

  // 更新箭头的绑定信息
  const bindingKey = bindingType === "start" ? "startBinding" : "endBinding";
  mutateElement(arrow, {
    [bindingKey]: binding,
  });

  // 更新目标元素的绑定关系
  const boundElements = element.boundElements || [];
  const existingBinding = boundElements.find(be => be.id === arrow.id);
  
  if (!existingBinding) {
    mutateElement(element, {
      boundElements: [...boundElements, { id: arrow.id, type: "arrow" }],
    });
  }
};

// 计算绑定位置
const getBindingPosition = (
  element: ExcalidrawElement,
  point: { x: number; y: number }
): { focus: number; gap: number } => {
  // 找到点在元素边界上的最近位置
  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);
  
  // 计算焦点（在边界上的相对位置，0-1）
  let focus: number;
  let gap: number;

  if (element.type === "rectangle" || element.type === "text") {
    // 对于矩形元素，找到最近的边
    const distances = [
      Math.abs(point.y - y1), // 上边
      Math.abs(point.x - x2), // 右边  
      Math.abs(point.y - y2), // 下边
      Math.abs(point.x - x1), // 左边
    ];
    
    const minIndex = distances.indexOf(Math.min(...distances));
    
    switch (minIndex) {
      case 0: // 上边
        focus = (point.x - x1) / (x2 - x1);
        gap = Math.abs(point.y - y1);
        break;
      case 1: // 右边
        focus = (point.y - y1) / (y2 - y1);
        gap = Math.abs(point.x - x2);
        break;
      case 2: // 下边
        focus = (point.x - x1) / (x2 - x1);
        gap = Math.abs(point.y - y2);
        break;
      case 3: // 左边
        focus = (point.y - y1) / (y2 - y1);
        gap = Math.abs(point.x - x1);
        break;
    }
  } else if (element.type === "ellipse") {
    // 对于椭圆，计算角度
    const centerX = (x1 + x2) / 2;
    const centerY = (y1 + y2) / 2;
    const angle = Math.atan2(point.y - centerY, point.x - centerX);
    focus = (angle + Math.PI) / (2 * Math.PI); // 转换为0-1范围
    gap = 5; // 椭圆的默认间隙
  }

  return { focus, gap };
};
```

## 6. 性能优化策略

### 6.1 形状缓存

```typescript
// packages/element/src/shape.ts

// 形状缓存系统 - 避免重复计算RoughJS路径
export class ShapeCache {
  private static cache = new Map<string, Drawable>();
  private static boundTextCache = new Map<string, Drawable>();

  // 获取缓存的形状
  static get<T extends ExcalidrawElement>(
    element: T,
    renderConfig: {
      roughness: number;
      strokeWidth: number;
      seed: number;
    }
  ): Drawable | undefined {
    const key = this.generateKey(element, renderConfig);
    return this.cache.get(key);
  }

  // 设置形状缓存
  static set<T extends ExcalidrawElement>(
    element: T,
    renderConfig: {
      roughness: number;
      strokeWidth: number;
      seed: number;
    },
    drawable: Drawable
  ): void {
    const key = this.generateKey(element, renderConfig);
    this.cache.set(key, drawable);
  }

  // 删除元素的缓存
  static delete(element: ExcalidrawElement): void {
    const keysToDelete: string[] = [];
    
    for (const key of this.cache.keys()) {
      if (key.startsWith(element.id)) {
        keysToDelete.push(key);
      }
    }
    
    keysToDelete.forEach(key => {
      this.cache.delete(key);
    });
  }

  // 生成缓存键
  private static generateKey<T extends ExcalidrawElement>(
    element: T,
    renderConfig: {
      roughness: number;
      strokeWidth: number;
      seed: number;
    }
  ): string {
    return `${element.id}:${element.version}:${renderConfig.roughness}:${renderConfig.strokeWidth}:${renderConfig.seed}`;
  }

  // 清理所有缓存
  static clear(): void {
    this.cache.clear();
    this.boundTextCache.clear();
  }
}
```

### 6.2 增量更新

```typescript
// 增量更新系统 - 只更新变化的元素
export class ElementUpdateTracker {
  private previousElements = new Map<string, ExcalidrawElement>();
  private changedElementIds = new Set<string>();

  // 检测变化的元素
  updateElements(elements: readonly ExcalidrawElement[]): Set<string> {
    this.changedElementIds.clear();

    elements.forEach(element => {
      const previousElement = this.previousElements.get(element.id);
      
      if (!previousElement) {
        // 新元素
        this.changedElementIds.add(element.id);
        this.previousElements.set(element.id, element);
      } else if (element.version !== previousElement.version) {
        // 版本变化
        this.changedElementIds.add(element.id);
        this.previousElements.set(element.id, element);
      }
    });

    // 检查删除的元素
    for (const [elementId] of this.previousElements) {
      const stillExists = elements.some(el => el.id === elementId);
      if (!stillExists) {
        this.changedElementIds.add(elementId);
        this.previousElements.delete(elementId);
      }
    }

    return new Set(this.changedElementIds);
  }

  // 获取变化的元素
  getChangedElements(elements: readonly ExcalidrawElement[]): ExcalidrawElement[] {
    return elements.filter(element => 
      this.changedElementIds.has(element.id)
    );
  }
}
```

## 总结

Excalidraw 的元素系统设计体现了以下优秀实践：

1. **类型安全** - 完整的TypeScript类型定义，编译时错误检查
2. **不可变性** - 所有更新都创建新对象，便于状态管理和回滚
3. **版本控制** - 内建版本系统支持协作和冲突解决
4. **性能优化** - 形状缓存、增量更新、边界框快速检测
5. **扩展性** - 清晰的继承体系，容易添加新元素类型
6. **一致性** - 统一的创建、更新、删除接口

这种设计使得 Excalidraw 既能高效处理复杂的绘图操作，又能保持代码的清晰和可维护性。