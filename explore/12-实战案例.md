# Excalidraw å®æˆ˜æ¡ˆä¾‹é›†

æœ¬æ–‡æ¡£æä¾›äº†å¤šä¸ªçœŸå®åœºæ™¯çš„å®Œæ•´å®ç°æ¡ˆä¾‹ï¼Œå¸®åŠ©ä½ å­¦ä¹ å¦‚ä½•åœ¨å®é™…é¡¹ç›®ä¸­ä½¿ç”¨å’Œæ‰©å±• Excalidrawã€‚

## æ¡ˆä¾‹1ï¼šåœ¨çº¿åä½œç™½æ¿ç³»ç»Ÿ

è¿™æ˜¯ä¸€ä¸ªå®Œæ•´çš„åœ¨çº¿åä½œç™½æ¿ç³»ç»Ÿï¼Œæ”¯æŒå®æ—¶å¤šäººåä½œã€æˆ¿é—´ç®¡ç†ã€æ•°æ®æŒä¹…åŒ–ã€‚

### 1.1 æŠ€æœ¯æ ˆ

```json
{
  "frontend": {
    "react": "^18.2.0",
    "@excalidraw/excalidraw": "^0.18.0",
    "socket.io-client": "^4.7.2",
    "uuid": "^9.0.0"
  },
  "backend": {
    "express": "^4.18.2",
    "socket.io": "^4.7.2",
    "redis": "^4.6.7",
    "mongodb": "^5.7.0"
  }
}
```

### 1.2 å‰ç«¯å®ç°

```typescript
// CollaborativeWhiteboard.tsx
import React, { useRef, useEffect, useState, useCallback } from "react";
import { Excalidraw, serializeAsJSON } from "@excalidraw/excalidraw";
import { io, Socket } from "socket.io-client";
import { v4 as uuidv4 } from "uuid";
import type { 
  ExcalidrawElement, 
  ExcalidrawImperativeAPI,
  Collaborator,
  AppState 
} from "@excalidraw/excalidraw/types";

interface RoomData {
  id: string;
  name: string;
  elements: ExcalidrawElement[];
  participants: number;
}

interface CollaborativeWhiteboardProps {
  roomId: string;
  userName: string;
}

export const CollaborativeWhiteboard: React.FC<CollaborativeWhiteboardProps> = ({
  roomId,
  userName,
}) => {
  const excalidrawRef = useRef<ExcalidrawImperativeAPI>(null);
  const socketRef = useRef<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [collaborators, setCollaborators] = useState<Map<string, Collaborator>>(new Map());
  const [roomData, setRoomData] = useState<RoomData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const userIdRef = useRef<string>(uuidv4());
  const lastSentElementsRef = useRef<ExcalidrawElement[]>([]);

  // èŠ‚æµå‘é€å…ƒç´ æ›´æ–°
  const throttledSendElements = useCallback(
    (() => {
      let timeoutId: NodeJS.Timeout | null = null;
      
      return (elements: ExcalidrawElement[]) => {
        if (timeoutId) clearTimeout(timeoutId);
        
        timeoutId = setTimeout(() => {
          if (socketRef.current && isConnected) {
            // åªå‘é€å˜åŒ–çš„å…ƒç´ 
            const elementsToSend = elements.filter(el => {
              const lastElement = lastSentElementsRef.current.find(last => last.id === el.id);
              return !lastElement || lastElement.version !== el.version;
            });

            if (elementsToSend.length > 0) {
              socketRef.current.emit("elements-update", {
                roomId,
                elements: elementsToSend,
                userId: userIdRef.current,
              });
              
              lastSentElementsRef.current = elements;
            }
          }
        }, 100); // 100ms èŠ‚æµ
      };
    })(),
    [roomId, isConnected]
  );

  // åˆå§‹åŒ– Socket è¿æ¥
  useEffect(() => {
    const socket = io(process.env.REACT_APP_SERVER_URL || "http://localhost:3001");
    socketRef.current = socket;

    // è¿æ¥æˆåŠŸ
    socket.on("connect", () => {
      console.log("Connected to server");
      setIsConnected(true);
      
      // åŠ å…¥æˆ¿é—´
      socket.emit("join-room", {
        roomId,
        userName,
        userId: userIdRef.current,
      });
    });

    // æˆ¿é—´æ•°æ®
    socket.on("room-data", (data: RoomData) => {
      console.log("Received room data:", data);
      setRoomData(data);
      
      // æ›´æ–°ç”»å¸ƒ
      if (data.elements) {
        excalidrawRef.current?.updateScene({
          elements: data.elements,
          commitToHistory: false,
        });
      }
      setIsLoading(false);
    });

    // åä½œè€…æ›´æ–°
    socket.on("collaborators-update", (collaboratorsData: Record<string, Collaborator>) => {
      const newCollaborators = new Map();
      Object.entries(collaboratorsData).forEach(([userId, collaborator]) => {
        if (userId !== userIdRef.current) {
          newCollaborators.set(userId, collaborator);
        }
      });
      setCollaborators(newCollaborators);
    });

    // æ¥æ”¶å…ƒç´ æ›´æ–°
    socket.on("elements-update", ({ elements, userId }: { 
      elements: ExcalidrawElement[]; 
      userId: string; 
    }) => {
      if (userId !== userIdRef.current) {
        const currentElements = excalidrawRef.current?.getSceneElements() || [];
        const elementsMap = new Map(currentElements.map(el => [el.id, el]));
        
        // åˆå¹¶è¿œç¨‹æ›´æ–°
        elements.forEach(remoteElement => {
          const localElement = elementsMap.get(remoteElement.id);
          if (!localElement || remoteElement.version > localElement.version) {
            elementsMap.set(remoteElement.id, remoteElement);
          }
        });

        const mergedElements = Array.from(elementsMap.values());
        
        excalidrawRef.current?.updateScene({
          elements: mergedElements,
          commitToHistory: false,
        });
      }
    });

    // æŒ‡é’ˆæ›´æ–°
    socket.on("pointer-update", ({ pointer, userId, userName: remoteUserName }: {
      pointer: { x: number; y: number };
      userId: string;
      userName: string;
    }) => {
      if (userId !== userIdRef.current) {
        setCollaborators(prev => {
          const newCollaborators = new Map(prev);
          const existingCollaborator = newCollaborators.get(userId);
          
          newCollaborators.set(userId, {
            ...existingCollaborator,
            pointer: {
              x: pointer.x,
              y: pointer.y,
              tool: "pointer",
            },
            username: remoteUserName,
            color: existingCollaborator?.color || generateUserColor(userId),
          });
          
          return newCollaborators;
        });
      }
    });

    // è¿æ¥æ–­å¼€
    socket.on("disconnect", () => {
      console.log("Disconnected from server");
      setIsConnected(false);
    });

    return () => {
      socket.disconnect();
    };
  }, [roomId, userName]);

  // ç”Ÿæˆç”¨æˆ·é¢œè‰²
  const generateUserColor = (userId: string) => {
    const colors = [
      "#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", 
      "#FFEAA7", "#DDA0DD", "#98D8C8", "#F7DC6F"
    ];
    const index = userId.charCodeAt(0) % colors.length;
    return {
      background: colors[index],
      stroke: colors[index],
    };
  };

  // å¤„ç†å…ƒç´ å˜åŒ–
  const handleElementsChange = useCallback((elements: ExcalidrawElement[]) => {
    throttledSendElements(elements);
  }, [throttledSendElements]);

  // å¤„ç†æŒ‡é’ˆæ›´æ–°
  const handlePointerUpdate = useCallback((payload: {
    pointer: { x: number; y: number };
    button: "up" | "down";
  }) => {
    if (socketRef.current && isConnected) {
      socketRef.current.emit("pointer-update", {
        roomId,
        pointer: payload.pointer,
        userId: userIdRef.current,
        userName,
      });
    }
  }, [roomId, userName, isConnected]);

  // ä¿å­˜ç”»æ¿
  const handleSave = async () => {
    const elements = excalidrawRef.current?.getSceneElements();
    const appState = excalidrawRef.current?.getAppState();
    
    if (elements && appState && socketRef.current) {
      const data = {
        elements,
        appState: {
          viewBackgroundColor: appState.viewBackgroundColor,
          zoom: appState.zoom,
          scrollX: appState.scrollX,
          scrollY: appState.scrollY,
        },
      };

      socketRef.current.emit("save-room", {
        roomId,
        data: JSON.stringify(data),
      });

      console.log("Room saved successfully");
    }
  };

  // å¯¼å‡ºå›¾ç‰‡
  const handleExportImage = async () => {
    const elements = excalidrawRef.current?.getSceneElements();
    const appState = excalidrawRef.current?.getAppState();
    const files = excalidrawRef.current?.getFiles();

    if (elements && appState) {
      const { exportToBlob } = await import("@excalidraw/excalidraw");
      
      const blob = await exportToBlob({
        elements,
        appState,
        files,
        mimeType: "image/png",
        quality: 0.8,
      });

      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `whiteboard-${roomId}.png`;
      a.click();
      URL.revokeObjectURL(url);
    }
  };

  if (isLoading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner">åŠ è½½ä¸­...</div>
      </div>
    );
  }

  return (
    <div className="collaborative-whiteboard">
      {/* å¤´éƒ¨å·¥å…·æ  */}
      <div className="toolbar">
        <div className="room-info">
          <span className="room-name">{roomData?.name}</span>
          <span className="participants-count">
            å‚ä¸è€…: {collaborators.size + 1}
          </span>
        </div>
        
        <div className="actions">
          <button 
            onClick={handleSave}
            disabled={!isConnected}
            className="btn btn-primary"
          >
            ä¿å­˜
          </button>
          <button 
            onClick={handleExportImage}
            className="btn btn-secondary"
          >
            å¯¼å‡ºå›¾ç‰‡
          </button>
        </div>
      </div>

      {/* ç”»æ¿åŒºåŸŸ */}
      <div className="canvas-container">
        <Excalidraw
          ref={excalidrawRef}
          onChange={handleElementsChange}
          onPointerUpdate={handlePointerUpdate}
          isCollaborating={true}
          collaborators={collaborators}
          
          renderTopRightUI={() => (
            <div className="connection-status">
              <div className={`status-indicator ${isConnected ? "connected" : "disconnected"}`}>
                {isConnected ? "å·²è¿æ¥" : "è¿æ¥ä¸­..."}
              </div>
            </div>
          )}
          
          UIOptions={{
            canvasActions: {
              export: false, // ä½¿ç”¨è‡ªå®šä¹‰å¯¼å‡º
              loadScene: false,
              clearCanvas: true,
            },
          }}
        />
      </div>

      {/* åä½œè€…åˆ—è¡¨ */}
      {collaborators.size > 0 && (
        <div className="collaborators-panel">
          <h4>åœ¨çº¿ç”¨æˆ·</h4>
          <div className="user-list">
            <div className="user-item current-user">
              <div className="user-avatar" style={{ backgroundColor: "#007bff" }}>
                {userName.charAt(0).toUpperCase()}
              </div>
              <span>{userName} (ä½ )</span>
            </div>
            
            {Array.from(collaborators.entries()).map(([userId, collaborator]) => (
              <div key={userId} className="user-item">
                <div 
                  className="user-avatar" 
                  style={{ backgroundColor: collaborator.color?.background }}
                >
                  {(collaborator.username || "U").charAt(0).toUpperCase()}
                </div>
                <span>{collaborator.username || `ç”¨æˆ· ${userId.slice(0, 6)}`}</span>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};
```

### 1.3 åç«¯å®ç° (Node.js + Socket.IO)

```typescript
// server.ts
import express from "express";
import { createServer } from "http";
import { Server } from "socket.io";
import Redis from "ioredis";
import { MongoClient, Db } from "mongodb";
import cors from "cors";

interface RoomData {
  id: string;
  name: string;
  elements: any[];
  appState: any;
  participants: Map<string, { userId: string; userName: string; joinedAt: Date }>;
  lastUpdated: Date;
}

interface CollaboratorData {
  userId: string;
  userName: string;
  pointer?: { x: number; y: number };
  color: { background: string; stroke: string };
  socketId: string;
}

class WhiteboardServer {
  private app: express.Application;
  private server: ReturnType<typeof createServer>;
  private io: Server;
  private redis: Redis;
  private db: Db | null = null;
  private rooms = new Map<string, RoomData>();

  constructor() {
    this.app = express();
    this.server = createServer(this.app);
    this.io = new Server(this.server, {
      cors: {
        origin: process.env.CLIENT_URL || "http://localhost:3000",
        methods: ["GET", "POST"],
      },
    });

    this.redis = new Redis(process.env.REDIS_URL || "redis://localhost:6379");
    this.setupExpress();
    this.setupSocket();
    this.connectMongoDB();
  }

  private setupExpress() {
    this.app.use(cors());
    this.app.use(express.json());

    // å¥åº·æ£€æŸ¥
    this.app.get("/health", (req, res) => {
      res.json({ status: "ok", timestamp: new Date().toISOString() });
    });

    // è·å–æˆ¿é—´åˆ—è¡¨
    this.app.get("/api/rooms", async (req, res) => {
      try {
        if (this.db) {
          const rooms = await this.db.collection("rooms")
            .find({})
            .project({ _id: 1, name: 1, participantCount: 1, lastUpdated: 1 })
            .sort({ lastUpdated: -1 })
            .limit(20)
            .toArray();
          
          res.json(rooms);
        } else {
          res.json(Array.from(this.rooms.values()).map(room => ({
            id: room.id,
            name: room.name,
            participantCount: room.participants.size,
            lastUpdated: room.lastUpdated,
          })));
        }
      } catch (error) {
        console.error("Error fetching rooms:", error);
        res.status(500).json({ error: "Internal server error" });
      }
    });

    // åˆ›å»ºæˆ¿é—´
    this.app.post("/api/rooms", async (req, res) => {
      try {
        const { name } = req.body;
        const roomId = this.generateRoomId();
        
        const roomData: RoomData = {
          id: roomId,
          name: name || `æˆ¿é—´ ${roomId}`,
          elements: [],
          appState: {},
          participants: new Map(),
          lastUpdated: new Date(),
        };

        this.rooms.set(roomId, roomData);

        // ä¿å­˜åˆ°æ•°æ®åº“
        if (this.db) {
          await this.db.collection("rooms").insertOne({
            _id: roomId,
            name: roomData.name,
            elements: roomData.elements,
            appState: roomData.appState,
            createdAt: new Date(),
            lastUpdated: roomData.lastUpdated,
          });
        }

        res.json({ roomId, name: roomData.name });
      } catch (error) {
        console.error("Error creating room:", error);
        res.status(500).json({ error: "Internal server error" });
      }
    });
  }

  private setupSocket() {
    this.io.on("connection", (socket) => {
      console.log(`User connected: ${socket.id}`);

      // åŠ å…¥æˆ¿é—´
      socket.on("join-room", async ({ roomId, userName, userId }) => {
        try {
          await socket.join(roomId);
          console.log(`User ${userName} joined room ${roomId}`);

          // è·å–æˆ–åˆ›å»ºæˆ¿é—´æ•°æ®
          let roomData = this.rooms.get(roomId);
          if (!roomData) {
            roomData = await this.loadRoomFromDB(roomId);
            if (roomData) {
              this.rooms.set(roomId, roomData);
            }
          }

          if (!roomData) {
            roomData = {
              id: roomId,
              name: `æˆ¿é—´ ${roomId}`,
              elements: [],
              appState: {},
              participants: new Map(),
              lastUpdated: new Date(),
            };
            this.rooms.set(roomId, roomData);
          }

          // æ·»åŠ å‚ä¸è€…
          roomData.participants.set(userId, {
            userId,
            userName,
            joinedAt: new Date(),
          });

          // å‘é€æˆ¿é—´æ•°æ®ç»™æ–°ç”¨æˆ·
          socket.emit("room-data", {
            id: roomData.id,
            name: roomData.name,
            elements: roomData.elements,
            participants: roomData.participants.size,
          });

          // æ›´æ–°åä½œè€…ä¿¡æ¯
          this.updateCollaborators(roomId);

          // ç¼“å­˜åˆ° Redis
          await this.redis.set(`room:${roomId}`, JSON.stringify({
            elements: roomData.elements,
            appState: roomData.appState,
            lastUpdated: roomData.lastUpdated,
          }), "EX", 3600); // 1å°æ—¶è¿‡æœŸ

        } catch (error) {
          console.error("Error joining room:", error);
          socket.emit("error", { message: "åŠ å…¥æˆ¿é—´å¤±è´¥" });
        }
      });

      // å…ƒç´ æ›´æ–°
      socket.on("elements-update", async ({ roomId, elements, userId }) => {
        try {
          const roomData = this.rooms.get(roomId);
          if (!roomData) return;

          // åˆå¹¶å…ƒç´ æ›´æ–°
          const elementsMap = new Map(roomData.elements.map(el => [el.id, el]));
          
          elements.forEach((element: any) => {
            const existing = elementsMap.get(element.id);
            if (!existing || element.version > existing.version) {
              elementsMap.set(element.id, element);
            }
          });

          roomData.elements = Array.from(elementsMap.values());
          roomData.lastUpdated = new Date();

          // å¹¿æ’­ç»™æˆ¿é—´å†…å…¶ä»–ç”¨æˆ·
          socket.to(roomId).emit("elements-update", { elements, userId });

          // å®šæœŸä¿å­˜åˆ°æ•°æ®åº“ï¼ˆé˜²æŠ–ï¼‰
          this.debouncedSaveRoom(roomId, roomData);

        } catch (error) {
          console.error("Error updating elements:", error);
        }
      });

      // æŒ‡é’ˆæ›´æ–°
      socket.on("pointer-update", ({ roomId, pointer, userId, userName }) => {
        socket.to(roomId).emit("pointer-update", { 
          pointer, 
          userId, 
          userName 
        });
      });

      // ä¿å­˜æˆ¿é—´
      socket.on("save-room", async ({ roomId, data }) => {
        try {
          const roomData = this.rooms.get(roomId);
          if (!roomData) return;

          const parsedData = JSON.parse(data);
          roomData.elements = parsedData.elements;
          roomData.appState = parsedData.appState;
          roomData.lastUpdated = new Date();

          await this.saveRoomToDB(roomId, roomData);
          
          socket.emit("room-saved", { success: true });
          console.log(`Room ${roomId} saved successfully`);

        } catch (error) {
          console.error("Error saving room:", error);
          socket.emit("room-saved", { success: false, error: error.message });
        }
      });

      // æ–­å¼€è¿æ¥
      socket.on("disconnect", () => {
        console.log(`User disconnected: ${socket.id}`);
        
        // ä»æ‰€æœ‰æˆ¿é—´ä¸­ç§»é™¤è¯¥ç”¨æˆ·
        for (const [roomId, roomData] of this.rooms.entries()) {
          for (const [userId, participant] of roomData.participants.entries()) {
            // è¿™é‡Œéœ€è¦æ›´å®Œå–„çš„ç”¨æˆ·è¿½è¸ªæœºåˆ¶
            // æš‚æ—¶ç®€åŒ–å¤„ç†
          }
        }
      });
    });
  }

  private async connectMongoDB() {
    try {
      const client = new MongoClient(process.env.MONGODB_URL || "mongodb://localhost:27017");
      await client.connect();
      this.db = client.db("whiteboard");
      console.log("Connected to MongoDB");
    } catch (error) {
      console.error("MongoDB connection error:", error);
    }
  }

  private async loadRoomFromDB(roomId: string): Promise<RoomData | null> {
    try {
      // å…ˆä» Redis ç¼“å­˜æŸ¥æ‰¾
      const cached = await this.redis.get(`room:${roomId}`);
      if (cached) {
        const data = JSON.parse(cached);
        return {
          id: roomId,
          name: `æˆ¿é—´ ${roomId}`,
          elements: data.elements || [],
          appState: data.appState || {},
          participants: new Map(),
          lastUpdated: new Date(data.lastUpdated),
        };
      }

      // ä»æ•°æ®åº“æŸ¥æ‰¾
      if (this.db) {
        const room = await this.db.collection("rooms").findOne({ _id: roomId });
        if (room) {
          return {
            id: roomId,
            name: room.name,
            elements: room.elements || [],
            appState: room.appState || {},
            participants: new Map(),
            lastUpdated: room.lastUpdated,
          };
        }
      }

      return null;
    } catch (error) {
      console.error("Error loading room from DB:", error);
      return null;
    }
  }

  private debouncedSaveRoom = (() => {
    const timeouts = new Map<string, NodeJS.Timeout>();
    
    return (roomId: string, roomData: RoomData) => {
      const existingTimeout = timeouts.get(roomId);
      if (existingTimeout) {
        clearTimeout(existingTimeout);
      }

      const timeout = setTimeout(async () => {
        await this.saveRoomToDB(roomId, roomData);
        timeouts.delete(roomId);
      }, 5000); // 5ç§’é˜²æŠ–

      timeouts.set(roomId, timeout);
    };
  })();

  private async saveRoomToDB(roomId: string, roomData: RoomData) {
    try {
      // ä¿å­˜åˆ° Redis
      await this.redis.set(`room:${roomId}`, JSON.stringify({
        elements: roomData.elements,
        appState: roomData.appState,
        lastUpdated: roomData.lastUpdated,
      }), "EX", 3600);

      // ä¿å­˜åˆ° MongoDB
      if (this.db) {
        await this.db.collection("rooms").updateOne(
          { _id: roomId },
          {
            $set: {
              elements: roomData.elements,
              appState: roomData.appState,
              lastUpdated: roomData.lastUpdated,
            },
          },
          { upsert: true }
        );
      }
    } catch (error) {
      console.error("Error saving room to DB:", error);
    }
  }

  private updateCollaborators(roomId: string) {
    const roomData = this.rooms.get(roomId);
    if (!roomData) return;

    const collaborators: Record<string, CollaboratorData> = {};
    
    roomData.participants.forEach((participant) => {
      collaborators[participant.userId] = {
        userId: participant.userId,
        userName: participant.userName,
        color: this.generateUserColor(participant.userId),
        socketId: "", // å®é™…é¡¹ç›®ä¸­éœ€è¦è¿½è¸ª socketId
      };
    });

    this.io.to(roomId).emit("collaborators-update", collaborators);
  }

  private generateUserColor(userId: string) {
    const colors = [
      "#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", 
      "#FFEAA7", "#DDA0DD", "#98D8C8", "#F7DC6F"
    ];
    const index = userId.charCodeAt(0) % colors.length;
    return {
      background: colors[index],
      stroke: colors[index],
    };
  }

  private generateRoomId(): string {
    return Math.random().toString(36).substr(2, 9);
  }

  public start(port: number = 3001) {
    this.server.listen(port, () => {
      console.log(`Whiteboard server running on port ${port}`);
    });
  }
}

// å¯åŠ¨æœåŠ¡å™¨
const server = new WhiteboardServer();
server.start();
```

### 1.4 æ ·å¼æ–‡ä»¶

```scss
// CollaborativeWhiteboard.scss
.collaborative-whiteboard {
  display: flex;
  flex-direction: column;
  height: 100vh;
  background: #f8f9fa;

  .toolbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 20px;
    background: white;
    border-bottom: 1px solid #e9ecef;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);

    .room-info {
      display: flex;
      align-items: center;
      gap: 16px;

      .room-name {
        font-weight: 600;
        font-size: 18px;
        color: #495057;
      }

      .participants-count {
        background: #e3f2fd;
        color: #1976d2;
        padding: 4px 12px;
        border-radius: 16px;
        font-size: 14px;
      }
    }

    .actions {
      display: flex;
      gap: 12px;
    }
  }

  .canvas-container {
    flex: 1;
    position: relative;
    overflow: hidden;
  }

  .connection-status {
    .status-indicator {
      padding: 6px 12px;
      border-radius: 16px;
      font-size: 12px;
      font-weight: 500;

      &.connected {
        background: #d4edda;
        color: #155724;
      }

      &.disconnected {
        background: #f8d7da;
        color: #721c24;
      }
    }
  }

  .collaborators-panel {
    position: fixed;
    top: 80px;
    right: 20px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    padding: 16px;
    min-width: 200px;
    z-index: 1000;

    h4 {
      margin: 0 0 12px 0;
      font-size: 14px;
      color: #495057;
    }

    .user-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .user-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px;
      border-radius: 4px;

      &.current-user {
        background: #e3f2fd;
      }

      .user-avatar {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 600;
        font-size: 12px;
      }

      span {
        font-size: 14px;
        color: #495057;
      }
    }
  }
}

// æŒ‰é’®æ ·å¼
.btn {
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;

  &:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  &.btn-primary {
    background: #007bff;
    color: white;

    &:hover:not(:disabled) {
      background: #0056b3;
    }
  }

  &.btn-secondary {
    background: #6c757d;
    color: white;

    &:hover:not(:disabled) {
      background: #545b62;
    }
  }
}

.loading-container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;

  .loading-spinner {
    font-size: 18px;
    color: #6c757d;
  }
}
```

## æ¡ˆä¾‹2ï¼šæ•™è‚²ç»˜å›¾å·¥å…·

è¿™æ˜¯ä¸€ä¸ªä¸“é—¨ä¸ºæ•™è‚²åœºæ™¯è®¾è®¡çš„ç»˜å›¾å·¥å…·ï¼Œæ”¯æŒæ•°å­¦å…¬å¼ã€å‡ ä½•å›¾å½¢ã€æ•™å­¦æ¨¡æ¿ç­‰åŠŸèƒ½ã€‚

### 2.1 åŠŸèƒ½ç‰¹æ€§

```typescript
// EducationDrawingTool.tsx
import React, { useRef, useState, useCallback } from "react";
import { Excalidraw, convertToExcalidrawElements, exportToBlob } from "@excalidraw/excalidraw";
import type { ExcalidrawImperativeAPI, ExcalidrawElement } from "@excalidraw/excalidraw/types";

// æ•°å­¦æ¨¡æ¿
const MATH_TEMPLATES = {
  coordinateSystem: {
    name: "åæ ‡ç³»",
    elements: [
      // Xè½´
      { type: "arrow", x: 50, y: 200, points: [[0, 0], [300, 0]], strokeColor: "#000", endArrowhead: "arrow" },
      // Yè½´  
      { type: "arrow", x: 200, y: 50, points: [[0, 0], [0, 300]], strokeColor: "#000", endArrowhead: "arrow" },
      // åŸç‚¹
      { type: "text", x: 180, y: 210, text: "O", fontSize: 16 },
      // Xè½´æ ‡ç­¾
      { type: "text", x: 340, y: 210, text: "X", fontSize: 16 },
      // Yè½´æ ‡ç­¾
      { type: "text", x: 180, y: 40, text: "Y", fontSize: 16 },
      // ç½‘æ ¼ç‚¹
      ...generateGridPoints(50, 50, 300, 300, 50),
    ]
  },
  triangle: {
    name: "ä¸‰è§’å½¢",
    elements: [
      { 
        type: "line", 
        x: 100, 
        y: 100, 
        points: [[0, 100], [50, 0], [100, 100], [0, 100]], 
        strokeColor: "#000",
        strokeWidth: 2 
      },
      { type: "text", x: 90, y: 120, text: "A", fontSize: 16 },
      { type: "text", x: 140, y: 90, text: "B", fontSize: 16 },
      { type: "text", x: 190, y: 120, text: "C", fontSize: 16 },
    ]
  },
  circle: {
    name: "åœ†å½¢ä¸åœ†å¿ƒ",
    elements: [
      { type: "ellipse", x: 100, y: 100, width: 200, height: 200, strokeColor: "#000", strokeWidth: 2 },
      { type: "text", x: 195, y: 195, text: "O", fontSize: 16 },
      { type: "line", x: 200, y: 200, points: [[0, 0], [100, 0]], strokeColor: "#ff0000", strokeStyle: "dashed" },
      { type: "text", x: 240, y: 190, text: "r", fontSize: 16, strokeColor: "#ff0000" },
    ]
  },
};

// ç”Ÿæˆç½‘æ ¼ç‚¹çš„è¾…åŠ©å‡½æ•°
function generateGridPoints(startX: number, startY: number, endX: number, endY: number, step: number) {
  const points = [];
  for (let x = startX; x <= endX; x += step) {
    for (let y = startY; y <= endY; y += step) {
      if (x !== 200 && y !== 200) { // é¿å…ä¸åæ ‡è½´é‡å 
        points.push({
          type: "ellipse",
          x: x - 2,
          y: y - 2,
          width: 4,
          height: 4,
          strokeColor: "#ccc",
          backgroundColor: "#ccc",
          fillStyle: "solid",
        });
      }
    }
  }
  return points;
}

export const EducationDrawingTool: React.FC = () => {
  const excalidrawRef = useRef<ExcalidrawImperativeAPI>(null);
  const [selectedTemplate, setSelectedTemplate] = useState<string>("");
  const [showMathKeyboard, setShowMathKeyboard] = useState(false);
  const [annotations, setAnnotations] = useState<Array<{ id: string; content: string; position: { x: number; y: number } }>>([]);

  // æ’å…¥æ•°å­¦æ¨¡æ¿
  const insertTemplate = (templateKey: keyof typeof MATH_TEMPLATES) => {
    const template = MATH_TEMPLATES[templateKey];
    const elements = convertToExcalidrawElements(template.elements);
    
    const currentElements = excalidrawRef.current?.getSceneElements() || [];
    excalidrawRef.current?.updateScene({
      elements: [...currentElements, ...elements],
    });
  };

  // æ’å…¥æ•°å­¦å…¬å¼
  const insertMathFormula = (formula: string) => {
    // è¿™é‡Œå¯ä»¥é›†æˆ MathJax æˆ– KaTeX æ¥æ¸²æŸ“æ•°å­¦å…¬å¼
    // ç®€åŒ–å®ç°ï¼šç›´æ¥æ’å…¥æ–‡æœ¬
    const elements = convertToExcalidrawElements([
      {
        type: "text",
        x: 100,
        y: 100,
        text: formula,
        fontSize: 20,
        fontFamily: 2, // Helveticaï¼Œæ›´é€‚åˆæ•°å­¦ç¬¦å·
        backgroundColor: "#fff3cd",
        strokeColor: "#856404",
      }
    ]);

    const currentElements = excalidrawRef.current?.getSceneElements() || [];
    excalidrawRef.current?.updateScene({
      elements: [...currentElements, ...elements],
    });
  };

  // æ·»åŠ æ³¨é‡Š
  const addAnnotation = (x: number, y: number) => {
    const annotation = {
      id: Date.now().toString(),
      content: "ç‚¹å‡»ç¼–è¾‘æ³¨é‡Š",
      position: { x, y },
    };
    
    setAnnotations(prev => [...prev, annotation]);
    
    // åŒæ—¶åœ¨ç”»å¸ƒä¸Šåˆ›å»ºæ³¨é‡Šå…ƒç´ 
    const elements = convertToExcalidrawElements([
      {
        type: "text",
        x: x,
        y: y,
        text: "ğŸ“ " + annotation.content,
        fontSize: 14,
        backgroundColor: "#d4edda",
        strokeColor: "#155724",
      }
    ]);

    const currentElements = excalidrawRef.current?.getSceneElements() || [];
    excalidrawRef.current?.updateScene({
      elements: [...currentElements, ...elements],
    });
  };

  // æµ‹é‡å·¥å…·
  const addMeasurementTool = () => {
    const elements = convertToExcalidrawElements([
      {
        type: "line",
        x: 100,
        y: 100,
        points: [[0, 0], [100, 0]],
        strokeColor: "#dc3545",
        strokeWidth: 2,
        strokeStyle: "dashed",
      },
      {
        type: "text",
        x: 130,
        y: 85,
        text: "10cm",
        fontSize: 12,
        strokeColor: "#dc3545",
        backgroundColor: "white",
      }
    ]);

    const currentElements = excalidrawRef.current?.getSceneElements() || [];
    excalidrawRef.current?.updateScene({
      elements: [...currentElements, ...elements],
    });
  };

  // ä¿å­˜ä½œä¸š
  const saveHomework = async () => {
    const elements = excalidrawRef.current?.getSceneElements();
    const appState = excalidrawRef.current?.getAppState();
    
    if (elements && appState) {
      const homeworkData = {
        elements,
        appState,
        annotations,
        timestamp: new Date().toISOString(),
        studentId: "student_123", // å®é™…åº”ç”¨ä¸­ä»è®¤è¯ç³»ç»Ÿè·å–
        assignmentId: "assignment_456",
      };

      // è¿™é‡Œå¯ä»¥å‘é€åˆ°æœåŠ¡å™¨
      console.log("ä¿å­˜ä½œä¸š:", homeworkData);
      
      // æœ¬åœ°å­˜å‚¨
      localStorage.setItem("homework_draft", JSON.stringify(homeworkData));
      
      alert("ä½œä¸šå·²ä¿å­˜ï¼");
    }
  };

  // æäº¤ä½œä¸š
  const submitHomework = async () => {
    const elements = excalidrawRef.current?.getSceneElements();
    const appState = excalidrawRef.current?.getAppState();
    const files = excalidrawRef.current?.getFiles();
    
    if (elements && appState) {
      // å¯¼å‡ºä¸ºå›¾ç‰‡
      const blob = await exportToBlob({
        elements,
        appState,
        files,
        mimeType: "image/png",
      });

      const formData = new FormData();
      formData.append("homework", blob, "homework.png");
      formData.append("data", JSON.stringify({
        elements,
        annotations,
        submittedAt: new Date().toISOString(),
      }));

      // å‘é€åˆ°æœåŠ¡å™¨
      try {
        const response = await fetch("/api/homework/submit", {
          method: "POST",
          body: formData,
        });
        
        if (response.ok) {
          alert("ä½œä¸šæäº¤æˆåŠŸï¼");
          localStorage.removeItem("homework_draft");
        } else {
          alert("æäº¤å¤±è´¥ï¼Œè¯·é‡è¯•");
        }
      } catch (error) {
        console.error("æäº¤å¤±è´¥:", error);
        alert("ç½‘ç»œé”™è¯¯ï¼Œè¯·æ£€æŸ¥è¿æ¥");
      }
    }
  };

  return (
    <div className="education-drawing-tool">
      {/* æ•™è‚²å·¥å…·æ  */}
      <div className="education-toolbar">
        <div className="template-section">
          <h4>æ¨¡æ¿åº“</h4>
          <div className="template-buttons">
            {Object.entries(MATH_TEMPLATES).map(([key, template]) => (
              <button
                key={key}
                onClick={() => insertTemplate(key as keyof typeof MATH_TEMPLATES)}
                className="template-btn"
              >
                {template.name}
              </button>
            ))}
          </div>
        </div>

        <div className="math-section">
          <h4>æ•°å­¦å·¥å…·</h4>
          <div className="math-buttons">
            <button onClick={() => insertMathFormula("xÂ² + yÂ² = rÂ²")}>
              åœ†çš„æ–¹ç¨‹
            </button>
            <button onClick={() => insertMathFormula("y = mx + b")}>
              ç›´çº¿æ–¹ç¨‹
            </button>
            <button onClick={() => insertMathFormula("A = Ï€rÂ²")}>
              åœ†é¢ç§¯
            </button>
            <button onClick={() => setShowMathKeyboard(!showMathKeyboard)}>
              æ•°å­¦é”®ç›˜
            </button>
          </div>
        </div>

        <div className="tools-section">
          <h4>æ•™å­¦å·¥å…·</h4>
          <div className="tool-buttons">
            <button onClick={addMeasurementTool}>å°ºå­</button>
            <button onClick={() => addAnnotation(200, 200)}>æ·»åŠ æ³¨é‡Š</button>
          </div>
        </div>

        <div className="homework-section">
          <h4>ä½œä¸šç®¡ç†</h4>
          <div className="homework-buttons">
            <button onClick={saveHomework} className="save-btn">
              ä¿å­˜è‰ç¨¿
            </button>
            <button onClick={submitHomework} className="submit-btn">
              æäº¤ä½œä¸š
            </button>
          </div>
        </div>
      </div>

      {/* æ•°å­¦é”®ç›˜ */}
      {showMathKeyboard && (
        <div className="math-keyboard">
          <h4>æ•°å­¦ç¬¦å·</h4>
          <div className="symbol-grid">
            {["Î±", "Î²", "Î³", "Ï€", "Î¸", "âˆ‘", "âˆ«", "âˆš", "âˆ", "â‰ ", "â‰¤", "â‰¥", "âˆ ", "âŠ¥", "âˆ¥"].map(symbol => (
              <button
                key={symbol}
                onClick={() => insertMathFormula(symbol)}
                className="symbol-btn"
              >
                {symbol}
              </button>
            ))}
          </div>
        </div>
      )}

      {/* ç”»å¸ƒåŒºåŸŸ */}
      <div className="canvas-area">
        <Excalidraw
          ref={excalidrawRef}
          
          // æ•™è‚²æ¨¡å¼é…ç½®
          UIOptions={{
            canvasActions: {
              export: true,
              loadScene: true,
              clearCanvas: true,
              theme: true,
            },
            tools: {
              image: true, // å…è®¸æ’å…¥å›¾ç‰‡
            },
          }}
          
          // åˆå§‹é…ç½®
          initialData={{
            elements: [],
            appState: {
              viewBackgroundColor: "#ffffff",
              gridSize: 20, // æ˜¾ç¤ºç½‘æ ¼ä¾¿äºç»˜åˆ¶
            },
          }}
          
          // è‡ªå®šä¹‰é¡¶éƒ¨å·¥å…·æ 
          renderTopRightUI={() => (
            <div className="custom-controls">
              <select
                value={selectedTemplate}
                onChange={(e) => setSelectedTemplate(e.target.value)}
              >
                <option value="">é€‰æ‹©æ¨¡æ¿</option>
                {Object.entries(MATH_TEMPLATES).map(([key, template]) => (
                  <option key={key} value={key}>{template.name}</option>
                ))}
              </select>
              
              <button
                onClick={() => selectedTemplate && insertTemplate(selectedTemplate as keyof typeof MATH_TEMPLATES)}
                disabled={!selectedTemplate}
                className="insert-template-btn"
              >
                æ’å…¥æ¨¡æ¿
              </button>
            </div>
          )}
          
          // ç½‘æ ¼æ¨¡å¼é»˜è®¤å¼€å¯
          gridModeEnabled={true}
        />
      </div>

      {/* æ³¨é‡Šé¢æ¿ */}
      {annotations.length > 0 && (
        <div className="annotations-panel">
          <h4>æ³¨é‡Šåˆ—è¡¨</h4>
          {annotations.map(annotation => (
            <div key={annotation.id} className="annotation-item">
              <span>{annotation.content}</span>
              <button
                onClick={() => setAnnotations(prev => prev.filter(a => a.id !== annotation.id))}
                className="delete-btn"
              >
                åˆ é™¤
              </button>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};
```

### 2.2 æ•™è‚²å·¥å…·æ ·å¼

```scss
// EducationDrawingTool.scss
.education-drawing-tool {
  display: flex;
  height: 100vh;
  background: #f8f9fa;

  .education-toolbar {
    width: 300px;
    background: white;
    border-right: 1px solid #e9ecef;
    padding: 16px;
    overflow-y: auto;

    h4 {
      margin: 0 0 12px 0;
      color: #495057;
      font-size: 14px;
      font-weight: 600;
      border-bottom: 2px solid #007bff;
      padding-bottom: 4px;
    }

    .template-section,
    .math-section,
    .tools-section,
    .homework-section {
      margin-bottom: 24px;
    }

    .template-buttons,
    .math-buttons,
    .tool-buttons,
    .homework-buttons {
      display: flex;
      flex-direction: column;
      gap: 8px;

      button {
        padding: 8px 12px;
        border: 1px solid #dee2e6;
        background: white;
        border-radius: 4px;
        cursor: pointer;
        font-size: 13px;
        transition: all 0.2s;

        &:hover {
          background: #f8f9fa;
          border-color: #007bff;
        }
      }
    }

    .template-btn {
      background: #e3f2fd;
      border-color: #2196f3;

      &:hover {
        background: #bbdefb;
      }
    }

    .save-btn {
      background: #d4edda;
      border-color: #28a745;
      color: #155724;

      &:hover {
        background: #c3e6cb;
      }
    }

    .submit-btn {
      background: #f8d7da;
      border-color: #dc3545;
      color: #721c24;

      &:hover {
        background: #f5c6cb;
      }
    }
  }

  .canvas-area {
    flex: 1;
    position: relative;

    .custom-controls {
      display: flex;
      gap: 8px;
      align-items: center;

      select {
        padding: 6px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 12px;
      }

      .insert-template-btn {
        padding: 6px 12px;
        background: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 12px;
        cursor: pointer;

        &:disabled {
          background: #6c757d;
          cursor: not-allowed;
        }
      }
    }
  }

  .math-keyboard {
    position: absolute;
    top: 80px;
    left: 320px;
    background: white;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 16px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    z-index: 1000;

    h4 {
      margin: 0 0 12px 0;
      font-size: 14px;
    }

    .symbol-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 8px;

      .symbol-btn {
        padding: 8px;
        border: 1px solid #dee2e6;
        background: white;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
        min-height: 36px;

        &:hover {
          background: #f8f9fa;
          border-color: #007bff;
        }
      }
    }
  }

  .annotations-panel {
    position: absolute;
    bottom: 20px;
    right: 20px;
    background: white;
    border-radius: 8px;
    padding: 16px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    max-width: 300px;
    z-index: 1000;

    h4 {
      margin: 0 0 12px 0;
      font-size: 14px;
    }

    .annotation-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      margin-bottom: 8px;
      background: #f8f9fa;
      border-radius: 4px;

      span {
        font-size: 13px;
        flex: 1;
      }

      .delete-btn {
        padding: 4px 8px;
        background: #dc3545;
        color: white;
        border: none;
        border-radius: 3px;
        font-size: 11px;
        cursor: pointer;

        &:hover {
          background: #c82333;
        }
      }
    }
  }
}
```

## æ¡ˆä¾‹3ï¼šæµç¨‹å›¾è®¾è®¡å™¨

ä¸€ä¸ªä¸“é—¨ç”¨äºåˆ›å»ºå„ç§æµç¨‹å›¾çš„å·¥å…·ï¼Œæ”¯æŒè‡ªåŠ¨è¿æ¥ã€æ™ºèƒ½å¯¹é½ã€æ¨¡æ¿åº“ç­‰åŠŸèƒ½ã€‚

### 3.1 æ ¸å¿ƒå®ç°

```typescript
// FlowchartDesigner.tsx
import React, { useRef, useState, useCallback } from "react";
import { Excalidraw, convertToExcalidrawElements } from "@excalidraw/excalidraw";
import type { ExcalidrawImperativeAPI, ExcalidrawElement } from "@excalidraw/excalidraw/types";

// æµç¨‹å›¾å½¢çŠ¶åº“
const FLOWCHART_SHAPES = {
  start: {
    name: "å¼€å§‹/ç»“æŸ",
    shape: "ellipse",
    style: { backgroundColor: "#d4edda", strokeColor: "#28a745" }
  },
  process: {
    name: "å¤„ç†",
    shape: "rectangle", 
    style: { backgroundColor: "#cce5ff", strokeColor: "#007bff" }
  },
  decision: {
    name: "åˆ¤æ–­",
    shape: "diamond",
    style: { backgroundColor: "#fff3cd", strokeColor: "#ffc107" }
  },
  data: {
    name: "æ•°æ®",
    shape: "rectangle",
    style: { backgroundColor: "#f8d7da", strokeColor: "#dc3545" }
  },
};

// æµç¨‹å›¾æ¨¡æ¿
const FLOWCHART_TEMPLATES = {
  simple: {
    name: "ç®€å•æµç¨‹",
    elements: [
      { type: "ellipse", x: 200, y: 50, width: 120, height: 60, text: "å¼€å§‹" },
      { type: "rectangle", x: 200, y: 150, width: 120, height: 60, text: "å¤„ç†" },
      { type: "diamond", x: 200, y: 250, width: 120, height: 80, text: "åˆ¤æ–­" },
      { type: "ellipse", x: 200, y: 370, width: 120, height: 60, text: "ç»“æŸ" },
    ]
  },
  approval: {
    name: "å®¡æ‰¹æµç¨‹", 
    elements: [
      { type: "ellipse", x: 100, y: 50, width: 100, height: 50, text: "æäº¤ç”³è¯·" },
      { type: "diamond", x: 100, y: 150, width: 100, height: 70, text: "éƒ¨é—¨å®¡æ ¸" },
      { type: "diamond", x: 300, y: 150, width: 100, height: 70, text: "é¢†å¯¼å®¡æ‰¹" },
      { type: "ellipse", x: 200, y: 270, width: 100, height: 50, text: "å®¡æ‰¹å®Œæˆ" },
    ]
  },
};

export const FlowchartDesigner: React.FC = () => {
  const excalidrawRef = useRef<ExcalidrawImperativeAPI>(null);
  const [selectedShape, setSelectedShape] = useState<keyof typeof FLOWCHART_SHAPES>("process");
  const [autoConnect, setAutoConnect] = useState(true);
  const [snapToGrid, setSnapToGrid] = useState(true);

  // æ’å…¥å½¢çŠ¶
  const insertShape = useCallback((shapeType: keyof typeof FLOWCHART_SHAPES, x = 200, y = 200) => {
    const shape = FLOWCHART_SHAPES[shapeType];
    const element = {
      type: shape.shape,
      x: x - 60,
      y: y - 30,
      width: 120,
      height: shape.shape === "diamond" ? 80 : 60,
      ...shape.style,
      strokeWidth: 2,
    };

    const elements = convertToExcalidrawElements([element]);
    const currentElements = excalidrawRef.current?.getSceneElements() || [];
    
    excalidrawRef.current?.updateScene({
      elements: [...currentElements, ...elements],
    });

    // å¦‚æœå¯ç”¨è‡ªåŠ¨è¿æ¥ï¼Œå°è¯•è¿æ¥åˆ°æœ€è¿‘çš„å…ƒç´ 
    if (autoConnect && currentElements.length > 0) {
      const newElement = elements[0];
      const nearestElement = findNearestElement(currentElements, newElement);
      
      if (nearestElement && getDistance(newElement, nearestElement) < 200) {
        connectElements(nearestElement, newElement);
      }
    }
  }, [autoConnect]);

  // æŸ¥æ‰¾æœ€è¿‘çš„å…ƒç´ 
  const findNearestElement = (elements: ExcalidrawElement[], targetElement: ExcalidrawElement) => {
    let nearest = null;
    let minDistance = Infinity;

    elements.forEach(element => {
      if (element.id === targetElement.id) return;
      
      const distance = getDistance(element, targetElement);
      if (distance < minDistance) {
        minDistance = distance;
        nearest = element;
      }
    });

    return nearest;
  };

  // è®¡ç®—ä¸¤ä¸ªå…ƒç´ ä¹‹é—´çš„è·ç¦»
  const getDistance = (element1: ExcalidrawElement, element2: ExcalidrawElement) => {
    const x1 = element1.x + element1.width / 2;
    const y1 = element1.y + element1.height / 2;
    const x2 = element2.x + element2.width / 2;
    const y2 = element2.y + element2.height / 2;
    
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  };

  // è¿æ¥ä¸¤ä¸ªå…ƒç´ 
  const connectElements = (element1: ExcalidrawElement, element2: ExcalidrawElement) => {
    const startX = element1.x + element1.width / 2;
    const startY = element1.y + element1.height;
    const endX = element2.x + element2.width / 2;
    const endY = element2.y;

    const arrow = {
      type: "arrow",
      x: startX,
      y: startY,
      points: [[0, 0], [endX - startX, endY - startY]],
      strokeColor: "#666666",
      strokeWidth: 2,
      endArrowhead: "arrow",
    };

    const elements = convertToExcalidrawElements([arrow]);
    const currentElements = excalidrawRef.current?.getSceneElements() || [];
    
    excalidrawRef.current?.updateScene({
      elements: [...currentElements, ...elements],
    });
  };

  // æ’å…¥æ¨¡æ¿
  const insertTemplate = (templateKey: keyof typeof FLOWCHART_TEMPLATES) => {
    const template = FLOWCHART_TEMPLATES[templateKey];
    const elements = convertToExcalidrawElements(template.elements);
    
    excalidrawRef.current?.updateScene({
      elements,
    });

    // è‡ªåŠ¨è¿æ¥æ¨¡æ¿ä¸­çš„å…ƒç´ 
    setTimeout(() => {
      autoConnectTemplate(elements);
    }, 100);
  };

  // è‡ªåŠ¨è¿æ¥æ¨¡æ¿ä¸­çš„å…ƒç´ 
  const autoConnectTemplate = (elements: ExcalidrawElement[]) => {
    const connections = [];
    
    for (let i = 0; i < elements.length - 1; i++) {
      const current = elements[i];
      const next = elements[i + 1];
      
      const startX = current.x + current.width / 2;
      const startY = current.y + current.height;
      const endX = next.x + next.width / 2;
      const endY = next.y;
      
      connections.push({
        type: "arrow",
        x: startX,
        y: startY,
        points: [[0, 0], [endX - startX, endY - startY]],
        strokeColor: "#666666",
        strokeWidth: 2,
        endArrowhead: "arrow",
      });
    }

    const connectionElements = convertToExcalidrawElements(connections);
    const currentElements = excalidrawRef.current?.getSceneElements() || [];
    
    excalidrawRef.current?.updateScene({
      elements: [...currentElements, ...connectionElements],
    });
  };

  // å¯¹é½å·¥å…·
  const alignElements = (direction: "horizontal" | "vertical") => {
    const elements = excalidrawRef.current?.getSceneElements() || [];
    const selectedElements = elements.filter(el => el.isSelected);
    
    if (selectedElements.length < 2) {
      alert("è¯·é€‰æ‹©è‡³å°‘ä¸¤ä¸ªå…ƒç´ è¿›è¡Œå¯¹é½");
      return;
    }

    const updatedElements = elements.map(element => {
      if (!element.isSelected) return element;

      if (direction === "horizontal") {
        // æ°´å¹³å¯¹é½åˆ°ç¬¬ä¸€ä¸ªå…ƒç´ çš„Yåæ ‡
        const referenceY = selectedElements[0].y;
        return { ...element, y: referenceY };
      } else {
        // å‚ç›´å¯¹é½åˆ°ç¬¬ä¸€ä¸ªå…ƒç´ çš„Xåæ ‡
        const referenceX = selectedElements[0].x;
        return { ...element, x: referenceX };
      }
    });

    excalidrawRef.current?.updateScene({
      elements: updatedElements,
    });
  };

  // åˆ†å¸ƒå·¥å…·
  const distributeElements = (direction: "horizontal" | "vertical") => {
    const elements = excalidrawRef.current?.getSceneElements() || [];
    const selectedElements = elements.filter(el => el.isSelected).sort((a, b) => {
      return direction === "horizontal" ? a.x - b.x : a.y - b.y;
    });
    
    if (selectedElements.length < 3) {
      alert("è¯·é€‰æ‹©è‡³å°‘ä¸‰ä¸ªå…ƒç´ è¿›è¡Œåˆ†å¸ƒ");
      return;
    }

    const first = selectedElements[0];
    const last = selectedElements[selectedElements.length - 1];
    const totalDistance = direction === "horizontal" 
      ? (last.x - first.x) 
      : (last.y - first.y);
    
    const step = totalDistance / (selectedElements.length - 1);

    const updatedElements = elements.map(element => {
      const index = selectedElements.findIndex(el => el.id === element.id);
      if (index === -1) return element;

      if (direction === "horizontal") {
        return { ...element, x: first.x + step * index };
      } else {
        return { ...element, y: first.y + step * index };
      }
    });

    excalidrawRef.current?.updateScene({
      elements: updatedElements,
    });
  };

  // å¯¼å‡ºæµç¨‹å›¾
  const exportFlowchart = async (format: "png" | "svg" = "png") => {
    const elements = excalidrawRef.current?.getSceneElements();
    const appState = excalidrawRef.current?.getAppState();
    const files = excalidrawRef.current?.getFiles();

    if (elements && appState) {
      const { exportToBlob, exportToSvg } = await import("@excalidraw/excalidraw");
      
      if (format === "svg") {
        const svg = await exportToSvg({
          elements,
          appState,
          files,
        });
        
        const svgBlob = new Blob([svg.outerHTML], { type: "image/svg+xml" });
        downloadBlob(svgBlob, "flowchart.svg");
      } else {
        const blob = await exportToBlob({
          elements,
          appState,
          files,
          mimeType: "image/png",
        });
        
        downloadBlob(blob, "flowchart.png");
      }
    }
  };

  const downloadBlob = (blob: Blob, filename: string) => {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  };

  // å¤„ç†ç”»å¸ƒç‚¹å‡»
  const handleCanvasClick = useCallback((event: any) => {
    if (event.detail === 2) { // åŒå‡»
      const rect = event.target.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      
      insertShape(selectedShape, x, y);
    }
  }, [selectedShape, insertShape]);

  return (
    <div className="flowchart-designer">
      {/* å·¥å…·é¢æ¿ */}
      <div className="tools-panel">
        <div className="shapes-section">
          <h4>å½¢çŠ¶åº“</h4>
          <div className="shape-buttons">
            {Object.entries(FLOWCHART_SHAPES).map(([key, shape]) => (
              <button
                key={key}
                onClick={() => setSelectedShape(key as keyof typeof FLOWCHART_SHAPES)}
                className={`shape-btn ${selectedShape === key ? "active" : ""}`}
                style={shape.style}
              >
                {shape.name}
              </button>
            ))}
          </div>
        </div>

        <div className="templates-section">
          <h4>æ¨¡æ¿åº“</h4>
          <div className="template-buttons">
            {Object.entries(FLOWCHART_TEMPLATES).map(([key, template]) => (
              <button
                key={key}
                onClick={() => insertTemplate(key as keyof typeof FLOWCHART_TEMPLATES)}
                className="template-btn"
              >
                {template.name}
              </button>
            ))}
          </div>
        </div>

        <div className="alignment-section">
          <h4>å¯¹é½å·¥å…·</h4>
          <div className="alignment-buttons">
            <button onClick={() => alignElements("horizontal")}>
              æ°´å¹³å¯¹é½
            </button>
            <button onClick={() => alignElements("vertical")}>
              å‚ç›´å¯¹é½
            </button>
            <button onClick={() => distributeElements("horizontal")}>
              æ°´å¹³åˆ†å¸ƒ
            </button>
            <button onClick={() => distributeElements("vertical")}>
              å‚ç›´åˆ†å¸ƒ
            </button>
          </div>
        </div>

        <div className="settings-section">
          <h4>è®¾ç½®</h4>
          <div className="setting-items">
            <label>
              <input
                type="checkbox"
                checked={autoConnect}
                onChange={(e) => setAutoConnect(e.target.checked)}
              />
              è‡ªåŠ¨è¿æ¥
            </label>
            <label>
              <input
                type="checkbox"
                checked={snapToGrid}
                onChange={(e) => setSnapToGrid(e.target.checked)}
              />
              ç½‘æ ¼å¯¹é½
            </label>
          </div>
        </div>

        <div className="export-section">
          <h4>å¯¼å‡º</h4>
          <div className="export-buttons">
            <button onClick={() => exportFlowchart("png")}>
              å¯¼å‡ºPNG
            </button>
            <button onClick={() => exportFlowchart("svg")}>
              å¯¼å‡ºSVG
            </button>
          </div>
        </div>
      </div>

      {/* ç”»å¸ƒåŒºåŸŸ */}
      <div className="canvas-area" onClick={handleCanvasClick}>
        <Excalidraw
          ref={excalidrawRef}
          
          UIOptions={{
            canvasActions: {
              export: false, // ä½¿ç”¨è‡ªå®šä¹‰å¯¼å‡º
              loadScene: true,
              clearCanvas: true,
            },
          }}
          
          initialData={{
            elements: [],
            appState: {
              gridSize: snapToGrid ? 20 : null,
            },
          }}
          
          gridModeEnabled={snapToGrid}
          
          renderTopRightUI={() => (
            <div className="canvas-controls">
              <span className="help-text">
                åŒå‡»æ·»åŠ  {FLOWCHART_SHAPES[selectedShape].name}
              </span>
            </div>
          )}
        />
      </div>
    </div>
  );
};
```

### 3.2 æµç¨‹å›¾æ ·å¼

```scss
// FlowchartDesigner.scss
.flowchart-designer {
  display: flex;
  height: 100vh;
  background: #f8f9fa;

  .tools-panel {
    width: 280px;
    background: white;
    border-right: 1px solid #e9ecef;
    padding: 16px;
    overflow-y: auto;

    h4 {
      margin: 0 0 12px 0;
      color: #495057;
      font-size: 14px;
      font-weight: 600;
      border-bottom: 2px solid #17a2b8;
      padding-bottom: 4px;
    }

    .shapes-section,
    .templates-section,
    .alignment-section,
    .settings-section,
    .export-section {
      margin-bottom: 24px;
    }

    .shape-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;

      .shape-btn {
        padding: 12px 8px;
        border: 2px solid transparent;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        font-weight: 500;
        transition: all 0.2s;

        &:hover {
          transform: translateY(-1px);
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        &.active {
          border-color: #007bff;
          box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }
      }
    }

    .template-buttons,
    .alignment-buttons,
    .export-buttons {
      display: flex;
      flex-direction: column;
      gap: 8px;

      button {
        padding: 8px 12px;
        border: 1px solid #dee2e6;
        background: white;
        border-radius: 4px;
        cursor: pointer;
        font-size: 13px;
        transition: all 0.2s;

        &:hover {
          background: #f8f9fa;
          border-color: #17a2b8;
        }
      }
    }

    .template-btn {
      background: #e1f5fe;
      border-color: #0288d1;

      &:hover {
        background: #b3e5fc;
      }
    }

    .setting-items {
      display: flex;
      flex-direction: column;
      gap: 8px;

      label {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        color: #495057;
        cursor: pointer;

        input[type="checkbox"] {
          margin: 0;
        }
      }
    }
  }

  .canvas-area {
    flex: 1;
    position: relative;

    .canvas-controls {
      .help-text {
        padding: 6px 12px;
        background: #fff3cd;
        color: #856404;
        border-radius: 4px;
        font-size: 12px;
      }
    }
  }
}
```

## æ€»ç»“

é€šè¿‡è¿™ä¸‰ä¸ªå®æˆ˜æ¡ˆä¾‹ï¼Œæˆ‘ä»¬å±•ç¤ºäº† Excalidraw åœ¨ä¸åŒåœºæ™¯ä¸‹çš„å¼ºå¤§åº”ç”¨èƒ½åŠ›ï¼š

### æ¡ˆä¾‹ç‰¹ç‚¹å¯¹æ¯”

| æ¡ˆä¾‹ | ä¸»è¦ç‰¹æ€§ | æŠ€æœ¯éš¾ç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|----------|----------|----------|
| **åä½œç™½æ¿** | å®æ—¶åä½œã€æ•°æ®åŒæ­¥ | WebSocketç®¡ç†ã€å†²çªè§£å†³ | å›¢é˜Ÿåä½œã€è¿œç¨‹åŠå…¬ |
| **æ•™è‚²å·¥å…·** | æ¨¡æ¿åº“ã€æ•°å­¦ç¬¦å· | ä¸“ä¸šæ¨¡æ¿ã€ç¬¦å·æ¸²æŸ“ | åœ¨çº¿æ•™è‚²ã€ä½œä¸šç³»ç»Ÿ |
| **æµç¨‹å›¾è®¾è®¡å™¨** | è‡ªåŠ¨è¿æ¥ã€æ™ºèƒ½å¯¹é½ | å›¾å½¢ç®—æ³•ã€å¸ƒå±€ä¼˜åŒ– | ä¸šåŠ¡æµç¨‹ã€ç³»ç»Ÿè®¾è®¡ |

### æ ¸å¿ƒæŠ€æœ¯è¦ç‚¹

1. **çŠ¶æ€ç®¡ç†** - ä½¿ç”¨ refs å’Œå›è°ƒå‡½æ•°ç®¡ç†å¤æ‚çŠ¶æ€
2. **å®æ—¶é€šä¿¡** - WebSocket å®ç°å¤šäººåä½œ
3. **æ•°æ®æŒä¹…åŒ–** - ç»“åˆ Redis å’Œ MongoDB çš„å­˜å‚¨ç­–ç•¥
4. **æ€§èƒ½ä¼˜åŒ–** - èŠ‚æµã€é˜²æŠ–ã€ç¼“å­˜ç­‰ä¼˜åŒ–æŠ€æœ¯
5. **ç”¨æˆ·ä½“éªŒ** - æ™ºèƒ½æç¤ºã€æ¨¡æ¿åº“ã€å¿«æ·æ“ä½œ

### æ‰©å±•å»ºè®®

åŸºäºè¿™äº›æ¡ˆä¾‹ï¼Œä½ å¯ä»¥ç»§ç»­æ‰©å±•ï¼š

- **æ’ä»¶ç³»ç»Ÿ** - æ”¯æŒç¬¬ä¸‰æ–¹æ’ä»¶æ‰©å±•åŠŸèƒ½
- **AI é›†æˆ** - æ™ºèƒ½å›¾è¡¨ç”Ÿæˆã€å†…å®¹è¯†åˆ«
- **å¤šå¹³å°æ”¯æŒ** - ç§»åŠ¨ç«¯é€‚é…ã€æ¡Œé¢åº”ç”¨
- **ä¼ä¸šåŠŸèƒ½** - æƒé™ç®¡ç†ã€å®¡è®¡æ—¥å¿—ã€ç‰ˆæœ¬æ§åˆ¶

è¿™äº›æ¡ˆä¾‹ä¸ºä½ çš„ Excalidraw äºŒæ¬¡å¼€å‘æä¾›äº†å®Œæ•´çš„å‚è€ƒå®ç°ï¼Œä½ å¯ä»¥æ ¹æ®å…·ä½“éœ€æ±‚è¿›è¡Œè°ƒæ•´å’Œæ‰©å±•ã€‚ğŸ¨