# Excalidraw 实战案例集

本文档提供了多个真实场景的完整实现案例，帮助你学习如何在实际项目中使用和扩展 Excalidraw。

## 案例1：在线协作白板系统

这是一个完整的在线协作白板系统，支持实时多人协作、房间管理、数据持久化。

### 1.1 技术栈

```json
{
  "frontend": {
    "react": "^18.2.0",
    "@excalidraw/excalidraw": "^0.18.0",
    "socket.io-client": "^4.7.2",
    "uuid": "^9.0.0"
  },
  "backend": {
    "express": "^4.18.2",
    "socket.io": "^4.7.2",
    "redis": "^4.6.7",
    "mongodb": "^5.7.0"
  }
}
```

### 1.2 前端实现

```typescript
// CollaborativeWhiteboard.tsx
import React, { useRef, useEffect, useState, useCallback } from "react";
import { Excalidraw, serializeAsJSON } from "@excalidraw/excalidraw";
import { io, Socket } from "socket.io-client";
import { v4 as uuidv4 } from "uuid";
import type { 
  ExcalidrawElement, 
  ExcalidrawImperativeAPI,
  Collaborator,
  AppState 
} from "@excalidraw/excalidraw/types";

interface RoomData {
  id: string;
  name: string;
  elements: ExcalidrawElement[];
  participants: number;
}

interface CollaborativeWhiteboardProps {
  roomId: string;
  userName: string;
}

export const CollaborativeWhiteboard: React.FC<CollaborativeWhiteboardProps> = ({
  roomId,
  userName,
}) => {
  const excalidrawRef = useRef<ExcalidrawImperativeAPI>(null);
  const socketRef = useRef<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [collaborators, setCollaborators] = useState<Map<string, Collaborator>>(new Map());
  const [roomData, setRoomData] = useState<RoomData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const userIdRef = useRef<string>(uuidv4());
  const lastSentElementsRef = useRef<ExcalidrawElement[]>([]);

  // 节流发送元素更新
  const throttledSendElements = useCallback(
    (() => {
      let timeoutId: NodeJS.Timeout | null = null;
      
      return (elements: ExcalidrawElement[]) => {
        if (timeoutId) clearTimeout(timeoutId);
        
        timeoutId = setTimeout(() => {
          if (socketRef.current && isConnected) {
            // 只发送变化的元素
            const elementsToSend = elements.filter(el => {
              const lastElement = lastSentElementsRef.current.find(last => last.id === el.id);
              return !lastElement || lastElement.version !== el.version;
            });

            if (elementsToSend.length > 0) {
              socketRef.current.emit("elements-update", {
                roomId,
                elements: elementsToSend,
                userId: userIdRef.current,
              });
              
              lastSentElementsRef.current = elements;
            }
          }
        }, 100); // 100ms 节流
      };
    })(),
    [roomId, isConnected]
  );

  // 初始化 Socket 连接
  useEffect(() => {
    const socket = io(process.env.REACT_APP_SERVER_URL || "http://localhost:3001");
    socketRef.current = socket;

    // 连接成功
    socket.on("connect", () => {
      console.log("Connected to server");
      setIsConnected(true);
      
      // 加入房间
      socket.emit("join-room", {
        roomId,
        userName,
        userId: userIdRef.current,
      });
    });

    // 房间数据
    socket.on("room-data", (data: RoomData) => {
      console.log("Received room data:", data);
      setRoomData(data);
      
      // 更新画布
      if (data.elements) {
        excalidrawRef.current?.updateScene({
          elements: data.elements,
          commitToHistory: false,
        });
      }
      setIsLoading(false);
    });

    // 协作者更新
    socket.on("collaborators-update", (collaboratorsData: Record<string, Collaborator>) => {
      const newCollaborators = new Map();
      Object.entries(collaboratorsData).forEach(([userId, collaborator]) => {
        if (userId !== userIdRef.current) {
          newCollaborators.set(userId, collaborator);
        }
      });
      setCollaborators(newCollaborators);
    });

    // 接收元素更新
    socket.on("elements-update", ({ elements, userId }: { 
      elements: ExcalidrawElement[]; 
      userId: string; 
    }) => {
      if (userId !== userIdRef.current) {
        const currentElements = excalidrawRef.current?.getSceneElements() || [];
        const elementsMap = new Map(currentElements.map(el => [el.id, el]));
        
        // 合并远程更新
        elements.forEach(remoteElement => {
          const localElement = elementsMap.get(remoteElement.id);
          if (!localElement || remoteElement.version > localElement.version) {
            elementsMap.set(remoteElement.id, remoteElement);
          }
        });

        const mergedElements = Array.from(elementsMap.values());
        
        excalidrawRef.current?.updateScene({
          elements: mergedElements,
          commitToHistory: false,
        });
      }
    });

    // 指针更新
    socket.on("pointer-update", ({ pointer, userId, userName: remoteUserName }: {
      pointer: { x: number; y: number };
      userId: string;
      userName: string;
    }) => {
      if (userId !== userIdRef.current) {
        setCollaborators(prev => {
          const newCollaborators = new Map(prev);
          const existingCollaborator = newCollaborators.get(userId);
          
          newCollaborators.set(userId, {
            ...existingCollaborator,
            pointer: {
              x: pointer.x,
              y: pointer.y,
              tool: "pointer",
            },
            username: remoteUserName,
            color: existingCollaborator?.color || generateUserColor(userId),
          });
          
          return newCollaborators;
        });
      }
    });

    // 连接断开
    socket.on("disconnect", () => {
      console.log("Disconnected from server");
      setIsConnected(false);
    });

    return () => {
      socket.disconnect();
    };
  }, [roomId, userName]);

  // 生成用户颜色
  const generateUserColor = (userId: string) => {
    const colors = [
      "#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", 
      "#FFEAA7", "#DDA0DD", "#98D8C8", "#F7DC6F"
    ];
    const index = userId.charCodeAt(0) % colors.length;
    return {
      background: colors[index],
      stroke: colors[index],
    };
  };

  // 处理元素变化
  const handleElementsChange = useCallback((elements: ExcalidrawElement[]) => {
    throttledSendElements(elements);
  }, [throttledSendElements]);

  // 处理指针更新
  const handlePointerUpdate = useCallback((payload: {
    pointer: { x: number; y: number };
    button: "up" | "down";
  }) => {
    if (socketRef.current && isConnected) {
      socketRef.current.emit("pointer-update", {
        roomId,
        pointer: payload.pointer,
        userId: userIdRef.current,
        userName,
      });
    }
  }, [roomId, userName, isConnected]);

  // 保存画板
  const handleSave = async () => {
    const elements = excalidrawRef.current?.getSceneElements();
    const appState = excalidrawRef.current?.getAppState();
    
    if (elements && appState && socketRef.current) {
      const data = {
        elements,
        appState: {
          viewBackgroundColor: appState.viewBackgroundColor,
          zoom: appState.zoom,
          scrollX: appState.scrollX,
          scrollY: appState.scrollY,
        },
      };

      socketRef.current.emit("save-room", {
        roomId,
        data: JSON.stringify(data),
      });

      console.log("Room saved successfully");
    }
  };

  // 导出图片
  const handleExportImage = async () => {
    const elements = excalidrawRef.current?.getSceneElements();
    const appState = excalidrawRef.current?.getAppState();
    const files = excalidrawRef.current?.getFiles();

    if (elements && appState) {
      const { exportToBlob } = await import("@excalidraw/excalidraw");
      
      const blob = await exportToBlob({
        elements,
        appState,
        files,
        mimeType: "image/png",
        quality: 0.8,
      });

      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `whiteboard-${roomId}.png`;
      a.click();
      URL.revokeObjectURL(url);
    }
  };

  if (isLoading) {
    return (
      <div className="loading-container">
        <div className="loading-spinner">加载中...</div>
      </div>
    );
  }

  return (
    <div className="collaborative-whiteboard">
      {/* 头部工具栏 */}
      <div className="toolbar">
        <div className="room-info">
          <span className="room-name">{roomData?.name}</span>
          <span className="participants-count">
            参与者: {collaborators.size + 1}
          </span>
        </div>
        
        <div className="actions">
          <button 
            onClick={handleSave}
            disabled={!isConnected}
            className="btn btn-primary"
          >
            保存
          </button>
          <button 
            onClick={handleExportImage}
            className="btn btn-secondary"
          >
            导出图片
          </button>
        </div>
      </div>

      {/* 画板区域 */}
      <div className="canvas-container">
        <Excalidraw
          ref={excalidrawRef}
          onChange={handleElementsChange}
          onPointerUpdate={handlePointerUpdate}
          isCollaborating={true}
          collaborators={collaborators}
          
          renderTopRightUI={() => (
            <div className="connection-status">
              <div className={`status-indicator ${isConnected ? "connected" : "disconnected"}`}>
                {isConnected ? "已连接" : "连接中..."}
              </div>
            </div>
          )}
          
          UIOptions={{
            canvasActions: {
              export: false, // 使用自定义导出
              loadScene: false,
              clearCanvas: true,
            },
          }}
        />
      </div>

      {/* 协作者列表 */}
      {collaborators.size > 0 && (
        <div className="collaborators-panel">
          <h4>在线用户</h4>
          <div className="user-list">
            <div className="user-item current-user">
              <div className="user-avatar" style={{ backgroundColor: "#007bff" }}>
                {userName.charAt(0).toUpperCase()}
              </div>
              <span>{userName} (你)</span>
            </div>
            
            {Array.from(collaborators.entries()).map(([userId, collaborator]) => (
              <div key={userId} className="user-item">
                <div 
                  className="user-avatar" 
                  style={{ backgroundColor: collaborator.color?.background }}
                >
                  {(collaborator.username || "U").charAt(0).toUpperCase()}
                </div>
                <span>{collaborator.username || `用户 ${userId.slice(0, 6)}`}</span>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};
```

### 1.3 后端实现 (Node.js + Socket.IO)

```typescript
// server.ts
import express from "express";
import { createServer } from "http";
import { Server } from "socket.io";
import Redis from "ioredis";
import { MongoClient, Db } from "mongodb";
import cors from "cors";

interface RoomData {
  id: string;
  name: string;
  elements: any[];
  appState: any;
  participants: Map<string, { userId: string; userName: string; joinedAt: Date }>;
  lastUpdated: Date;
}

interface CollaboratorData {
  userId: string;
  userName: string;
  pointer?: { x: number; y: number };
  color: { background: string; stroke: string };
  socketId: string;
}

class WhiteboardServer {
  private app: express.Application;
  private server: ReturnType<typeof createServer>;
  private io: Server;
  private redis: Redis;
  private db: Db | null = null;
  private rooms = new Map<string, RoomData>();

  constructor() {
    this.app = express();
    this.server = createServer(this.app);
    this.io = new Server(this.server, {
      cors: {
        origin: process.env.CLIENT_URL || "http://localhost:3000",
        methods: ["GET", "POST"],
      },
    });

    this.redis = new Redis(process.env.REDIS_URL || "redis://localhost:6379");
    this.setupExpress();
    this.setupSocket();
    this.connectMongoDB();
  }

  private setupExpress() {
    this.app.use(cors());
    this.app.use(express.json());

    // 健康检查
    this.app.get("/health", (req, res) => {
      res.json({ status: "ok", timestamp: new Date().toISOString() });
    });

    // 获取房间列表
    this.app.get("/api/rooms", async (req, res) => {
      try {
        if (this.db) {
          const rooms = await this.db.collection("rooms")
            .find({})
            .project({ _id: 1, name: 1, participantCount: 1, lastUpdated: 1 })
            .sort({ lastUpdated: -1 })
            .limit(20)
            .toArray();
          
          res.json(rooms);
        } else {
          res.json(Array.from(this.rooms.values()).map(room => ({
            id: room.id,
            name: room.name,
            participantCount: room.participants.size,
            lastUpdated: room.lastUpdated,
          })));
        }
      } catch (error) {
        console.error("Error fetching rooms:", error);
        res.status(500).json({ error: "Internal server error" });
      }
    });

    // 创建房间
    this.app.post("/api/rooms", async (req, res) => {
      try {
        const { name } = req.body;
        const roomId = this.generateRoomId();
        
        const roomData: RoomData = {
          id: roomId,
          name: name || `房间 ${roomId}`,
          elements: [],
          appState: {},
          participants: new Map(),
          lastUpdated: new Date(),
        };

        this.rooms.set(roomId, roomData);

        // 保存到数据库
        if (this.db) {
          await this.db.collection("rooms").insertOne({
            _id: roomId,
            name: roomData.name,
            elements: roomData.elements,
            appState: roomData.appState,
            createdAt: new Date(),
            lastUpdated: roomData.lastUpdated,
          });
        }

        res.json({ roomId, name: roomData.name });
      } catch (error) {
        console.error("Error creating room:", error);
        res.status(500).json({ error: "Internal server error" });
      }
    });
  }

  private setupSocket() {
    this.io.on("connection", (socket) => {
      console.log(`User connected: ${socket.id}`);

      // 加入房间
      socket.on("join-room", async ({ roomId, userName, userId }) => {
        try {
          await socket.join(roomId);
          console.log(`User ${userName} joined room ${roomId}`);

          // 获取或创建房间数据
          let roomData = this.rooms.get(roomId);
          if (!roomData) {
            roomData = await this.loadRoomFromDB(roomId);
            if (roomData) {
              this.rooms.set(roomId, roomData);
            }
          }

          if (!roomData) {
            roomData = {
              id: roomId,
              name: `房间 ${roomId}`,
              elements: [],
              appState: {},
              participants: new Map(),
              lastUpdated: new Date(),
            };
            this.rooms.set(roomId, roomData);
          }

          // 添加参与者
          roomData.participants.set(userId, {
            userId,
            userName,
            joinedAt: new Date(),
          });

          // 发送房间数据给新用户
          socket.emit("room-data", {
            id: roomData.id,
            name: roomData.name,
            elements: roomData.elements,
            participants: roomData.participants.size,
          });

          // 更新协作者信息
          this.updateCollaborators(roomId);

          // 缓存到 Redis
          await this.redis.set(`room:${roomId}`, JSON.stringify({
            elements: roomData.elements,
            appState: roomData.appState,
            lastUpdated: roomData.lastUpdated,
          }), "EX", 3600); // 1小时过期

        } catch (error) {
          console.error("Error joining room:", error);
          socket.emit("error", { message: "加入房间失败" });
        }
      });

      // 元素更新
      socket.on("elements-update", async ({ roomId, elements, userId }) => {
        try {
          const roomData = this.rooms.get(roomId);
          if (!roomData) return;

          // 合并元素更新
          const elementsMap = new Map(roomData.elements.map(el => [el.id, el]));
          
          elements.forEach((element: any) => {
            const existing = elementsMap.get(element.id);
            if (!existing || element.version > existing.version) {
              elementsMap.set(element.id, element);
            }
          });

          roomData.elements = Array.from(elementsMap.values());
          roomData.lastUpdated = new Date();

          // 广播给房间内其他用户
          socket.to(roomId).emit("elements-update", { elements, userId });

          // 定期保存到数据库（防抖）
          this.debouncedSaveRoom(roomId, roomData);

        } catch (error) {
          console.error("Error updating elements:", error);
        }
      });

      // 指针更新
      socket.on("pointer-update", ({ roomId, pointer, userId, userName }) => {
        socket.to(roomId).emit("pointer-update", { 
          pointer, 
          userId, 
          userName 
        });
      });

      // 保存房间
      socket.on("save-room", async ({ roomId, data }) => {
        try {
          const roomData = this.rooms.get(roomId);
          if (!roomData) return;

          const parsedData = JSON.parse(data);
          roomData.elements = parsedData.elements;
          roomData.appState = parsedData.appState;
          roomData.lastUpdated = new Date();

          await this.saveRoomToDB(roomId, roomData);
          
          socket.emit("room-saved", { success: true });
          console.log(`Room ${roomId} saved successfully`);

        } catch (error) {
          console.error("Error saving room:", error);
          socket.emit("room-saved", { success: false, error: error.message });
        }
      });

      // 断开连接
      socket.on("disconnect", () => {
        console.log(`User disconnected: ${socket.id}`);
        
        // 从所有房间中移除该用户
        for (const [roomId, roomData] of this.rooms.entries()) {
          for (const [userId, participant] of roomData.participants.entries()) {
            // 这里需要更完善的用户追踪机制
            // 暂时简化处理
          }
        }
      });
    });
  }

  private async connectMongoDB() {
    try {
      const client = new MongoClient(process.env.MONGODB_URL || "mongodb://localhost:27017");
      await client.connect();
      this.db = client.db("whiteboard");
      console.log("Connected to MongoDB");
    } catch (error) {
      console.error("MongoDB connection error:", error);
    }
  }

  private async loadRoomFromDB(roomId: string): Promise<RoomData | null> {
    try {
      // 先从 Redis 缓存查找
      const cached = await this.redis.get(`room:${roomId}`);
      if (cached) {
        const data = JSON.parse(cached);
        return {
          id: roomId,
          name: `房间 ${roomId}`,
          elements: data.elements || [],
          appState: data.appState || {},
          participants: new Map(),
          lastUpdated: new Date(data.lastUpdated),
        };
      }

      // 从数据库查找
      if (this.db) {
        const room = await this.db.collection("rooms").findOne({ _id: roomId });
        if (room) {
          return {
            id: roomId,
            name: room.name,
            elements: room.elements || [],
            appState: room.appState || {},
            participants: new Map(),
            lastUpdated: room.lastUpdated,
          };
        }
      }

      return null;
    } catch (error) {
      console.error("Error loading room from DB:", error);
      return null;
    }
  }

  private debouncedSaveRoom = (() => {
    const timeouts = new Map<string, NodeJS.Timeout>();
    
    return (roomId: string, roomData: RoomData) => {
      const existingTimeout = timeouts.get(roomId);
      if (existingTimeout) {
        clearTimeout(existingTimeout);
      }

      const timeout = setTimeout(async () => {
        await this.saveRoomToDB(roomId, roomData);
        timeouts.delete(roomId);
      }, 5000); // 5秒防抖

      timeouts.set(roomId, timeout);
    };
  })();

  private async saveRoomToDB(roomId: string, roomData: RoomData) {
    try {
      // 保存到 Redis
      await this.redis.set(`room:${roomId}`, JSON.stringify({
        elements: roomData.elements,
        appState: roomData.appState,
        lastUpdated: roomData.lastUpdated,
      }), "EX", 3600);

      // 保存到 MongoDB
      if (this.db) {
        await this.db.collection("rooms").updateOne(
          { _id: roomId },
          {
            $set: {
              elements: roomData.elements,
              appState: roomData.appState,
              lastUpdated: roomData.lastUpdated,
            },
          },
          { upsert: true }
        );
      }
    } catch (error) {
      console.error("Error saving room to DB:", error);
    }
  }

  private updateCollaborators(roomId: string) {
    const roomData = this.rooms.get(roomId);
    if (!roomData) return;

    const collaborators: Record<string, CollaboratorData> = {};
    
    roomData.participants.forEach((participant) => {
      collaborators[participant.userId] = {
        userId: participant.userId,
        userName: participant.userName,
        color: this.generateUserColor(participant.userId),
        socketId: "", // 实际项目中需要追踪 socketId
      };
    });

    this.io.to(roomId).emit("collaborators-update", collaborators);
  }

  private generateUserColor(userId: string) {
    const colors = [
      "#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", 
      "#FFEAA7", "#DDA0DD", "#98D8C8", "#F7DC6F"
    ];
    const index = userId.charCodeAt(0) % colors.length;
    return {
      background: colors[index],
      stroke: colors[index],
    };
  }

  private generateRoomId(): string {
    return Math.random().toString(36).substr(2, 9);
  }

  public start(port: number = 3001) {
    this.server.listen(port, () => {
      console.log(`Whiteboard server running on port ${port}`);
    });
  }
}

// 启动服务器
const server = new WhiteboardServer();
server.start();
```

### 1.4 样式文件

```scss
// CollaborativeWhiteboard.scss
.collaborative-whiteboard {
  display: flex;
  flex-direction: column;
  height: 100vh;
  background: #f8f9fa;

  .toolbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 20px;
    background: white;
    border-bottom: 1px solid #e9ecef;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);

    .room-info {
      display: flex;
      align-items: center;
      gap: 16px;

      .room-name {
        font-weight: 600;
        font-size: 18px;
        color: #495057;
      }

      .participants-count {
        background: #e3f2fd;
        color: #1976d2;
        padding: 4px 12px;
        border-radius: 16px;
        font-size: 14px;
      }
    }

    .actions {
      display: flex;
      gap: 12px;
    }
  }

  .canvas-container {
    flex: 1;
    position: relative;
    overflow: hidden;
  }

  .connection-status {
    .status-indicator {
      padding: 6px 12px;
      border-radius: 16px;
      font-size: 12px;
      font-weight: 500;

      &.connected {
        background: #d4edda;
        color: #155724;
      }

      &.disconnected {
        background: #f8d7da;
        color: #721c24;
      }
    }
  }

  .collaborators-panel {
    position: fixed;
    top: 80px;
    right: 20px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    padding: 16px;
    min-width: 200px;
    z-index: 1000;

    h4 {
      margin: 0 0 12px 0;
      font-size: 14px;
      color: #495057;
    }

    .user-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .user-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px;
      border-radius: 4px;

      &.current-user {
        background: #e3f2fd;
      }

      .user-avatar {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 600;
        font-size: 12px;
      }

      span {
        font-size: 14px;
        color: #495057;
      }
    }
  }
}

// 按钮样式
.btn {
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;

  &:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  &.btn-primary {
    background: #007bff;
    color: white;

    &:hover:not(:disabled) {
      background: #0056b3;
    }
  }

  &.btn-secondary {
    background: #6c757d;
    color: white;

    &:hover:not(:disabled) {
      background: #545b62;
    }
  }
}

.loading-container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;

  .loading-spinner {
    font-size: 18px;
    color: #6c757d;
  }
}
```

## 案例2：教育绘图工具

这是一个专门为教育场景设计的绘图工具，支持数学公式、几何图形、教学模板等功能。

### 2.1 功能特性

```typescript
// EducationDrawingTool.tsx
import React, { useRef, useState, useCallback } from "react";
import { Excalidraw, convertToExcalidrawElements, exportToBlob } from "@excalidraw/excalidraw";
import type { ExcalidrawImperativeAPI, ExcalidrawElement } from "@excalidraw/excalidraw/types";

// 数学模板
const MATH_TEMPLATES = {
  coordinateSystem: {
    name: "坐标系",
    elements: [
      // X轴
      { type: "arrow", x: 50, y: 200, points: [[0, 0], [300, 0]], strokeColor: "#000", endArrowhead: "arrow" },
      // Y轴  
      { type: "arrow", x: 200, y: 50, points: [[0, 0], [0, 300]], strokeColor: "#000", endArrowhead: "arrow" },
      // 原点
      { type: "text", x: 180, y: 210, text: "O", fontSize: 16 },
      // X轴标签
      { type: "text", x: 340, y: 210, text: "X", fontSize: 16 },
      // Y轴标签
      { type: "text", x: 180, y: 40, text: "Y", fontSize: 16 },
      // 网格点
      ...generateGridPoints(50, 50, 300, 300, 50),
    ]
  },
  triangle: {
    name: "三角形",
    elements: [
      { 
        type: "line", 
        x: 100, 
        y: 100, 
        points: [[0, 100], [50, 0], [100, 100], [0, 100]], 
        strokeColor: "#000",
        strokeWidth: 2 
      },
      { type: "text", x: 90, y: 120, text: "A", fontSize: 16 },
      { type: "text", x: 140, y: 90, text: "B", fontSize: 16 },
      { type: "text", x: 190, y: 120, text: "C", fontSize: 16 },
    ]
  },
  circle: {
    name: "圆形与圆心",
    elements: [
      { type: "ellipse", x: 100, y: 100, width: 200, height: 200, strokeColor: "#000", strokeWidth: 2 },
      { type: "text", x: 195, y: 195, text: "O", fontSize: 16 },
      { type: "line", x: 200, y: 200, points: [[0, 0], [100, 0]], strokeColor: "#ff0000", strokeStyle: "dashed" },
      { type: "text", x: 240, y: 190, text: "r", fontSize: 16, strokeColor: "#ff0000" },
    ]
  },
};

// 生成网格点的辅助函数
function generateGridPoints(startX: number, startY: number, endX: number, endY: number, step: number) {
  const points = [];
  for (let x = startX; x <= endX; x += step) {
    for (let y = startY; y <= endY; y += step) {
      if (x !== 200 && y !== 200) { // 避免与坐标轴重叠
        points.push({
          type: "ellipse",
          x: x - 2,
          y: y - 2,
          width: 4,
          height: 4,
          strokeColor: "#ccc",
          backgroundColor: "#ccc",
          fillStyle: "solid",
        });
      }
    }
  }
  return points;
}

export const EducationDrawingTool: React.FC = () => {
  const excalidrawRef = useRef<ExcalidrawImperativeAPI>(null);
  const [selectedTemplate, setSelectedTemplate] = useState<string>("");
  const [showMathKeyboard, setShowMathKeyboard] = useState(false);
  const [annotations, setAnnotations] = useState<Array<{ id: string; content: string; position: { x: number; y: number } }>>([]);

  // 插入数学模板
  const insertTemplate = (templateKey: keyof typeof MATH_TEMPLATES) => {
    const template = MATH_TEMPLATES[templateKey];
    const elements = convertToExcalidrawElements(template.elements);
    
    const currentElements = excalidrawRef.current?.getSceneElements() || [];
    excalidrawRef.current?.updateScene({
      elements: [...currentElements, ...elements],
    });
  };

  // 插入数学公式
  const insertMathFormula = (formula: string) => {
    // 这里可以集成 MathJax 或 KaTeX 来渲染数学公式
    // 简化实现：直接插入文本
    const elements = convertToExcalidrawElements([
      {
        type: "text",
        x: 100,
        y: 100,
        text: formula,
        fontSize: 20,
        fontFamily: 2, // Helvetica，更适合数学符号
        backgroundColor: "#fff3cd",
        strokeColor: "#856404",
      }
    ]);

    const currentElements = excalidrawRef.current?.getSceneElements() || [];
    excalidrawRef.current?.updateScene({
      elements: [...currentElements, ...elements],
    });
  };

  // 添加注释
  const addAnnotation = (x: number, y: number) => {
    const annotation = {
      id: Date.now().toString(),
      content: "点击编辑注释",
      position: { x, y },
    };
    
    setAnnotations(prev => [...prev, annotation]);
    
    // 同时在画布上创建注释元素
    const elements = convertToExcalidrawElements([
      {
        type: "text",
        x: x,
        y: y,
        text: "📝 " + annotation.content,
        fontSize: 14,
        backgroundColor: "#d4edda",
        strokeColor: "#155724",
      }
    ]);

    const currentElements = excalidrawRef.current?.getSceneElements() || [];
    excalidrawRef.current?.updateScene({
      elements: [...currentElements, ...elements],
    });
  };

  // 测量工具
  const addMeasurementTool = () => {
    const elements = convertToExcalidrawElements([
      {
        type: "line",
        x: 100,
        y: 100,
        points: [[0, 0], [100, 0]],
        strokeColor: "#dc3545",
        strokeWidth: 2,
        strokeStyle: "dashed",
      },
      {
        type: "text",
        x: 130,
        y: 85,
        text: "10cm",
        fontSize: 12,
        strokeColor: "#dc3545",
        backgroundColor: "white",
      }
    ]);

    const currentElements = excalidrawRef.current?.getSceneElements() || [];
    excalidrawRef.current?.updateScene({
      elements: [...currentElements, ...elements],
    });
  };

  // 保存作业
  const saveHomework = async () => {
    const elements = excalidrawRef.current?.getSceneElements();
    const appState = excalidrawRef.current?.getAppState();
    
    if (elements && appState) {
      const homeworkData = {
        elements,
        appState,
        annotations,
        timestamp: new Date().toISOString(),
        studentId: "student_123", // 实际应用中从认证系统获取
        assignmentId: "assignment_456",
      };

      // 这里可以发送到服务器
      console.log("保存作业:", homeworkData);
      
      // 本地存储
      localStorage.setItem("homework_draft", JSON.stringify(homeworkData));
      
      alert("作业已保存！");
    }
  };

  // 提交作业
  const submitHomework = async () => {
    const elements = excalidrawRef.current?.getSceneElements();
    const appState = excalidrawRef.current?.getAppState();
    const files = excalidrawRef.current?.getFiles();
    
    if (elements && appState) {
      // 导出为图片
      const blob = await exportToBlob({
        elements,
        appState,
        files,
        mimeType: "image/png",
      });

      const formData = new FormData();
      formData.append("homework", blob, "homework.png");
      formData.append("data", JSON.stringify({
        elements,
        annotations,
        submittedAt: new Date().toISOString(),
      }));

      // 发送到服务器
      try {
        const response = await fetch("/api/homework/submit", {
          method: "POST",
          body: formData,
        });
        
        if (response.ok) {
          alert("作业提交成功！");
          localStorage.removeItem("homework_draft");
        } else {
          alert("提交失败，请重试");
        }
      } catch (error) {
        console.error("提交失败:", error);
        alert("网络错误，请检查连接");
      }
    }
  };

  return (
    <div className="education-drawing-tool">
      {/* 教育工具栏 */}
      <div className="education-toolbar">
        <div className="template-section">
          <h4>模板库</h4>
          <div className="template-buttons">
            {Object.entries(MATH_TEMPLATES).map(([key, template]) => (
              <button
                key={key}
                onClick={() => insertTemplate(key as keyof typeof MATH_TEMPLATES)}
                className="template-btn"
              >
                {template.name}
              </button>
            ))}
          </div>
        </div>

        <div className="math-section">
          <h4>数学工具</h4>
          <div className="math-buttons">
            <button onClick={() => insertMathFormula("x² + y² = r²")}>
              圆的方程
            </button>
            <button onClick={() => insertMathFormula("y = mx + b")}>
              直线方程
            </button>
            <button onClick={() => insertMathFormula("A = πr²")}>
              圆面积
            </button>
            <button onClick={() => setShowMathKeyboard(!showMathKeyboard)}>
              数学键盘
            </button>
          </div>
        </div>

        <div className="tools-section">
          <h4>教学工具</h4>
          <div className="tool-buttons">
            <button onClick={addMeasurementTool}>尺子</button>
            <button onClick={() => addAnnotation(200, 200)}>添加注释</button>
          </div>
        </div>

        <div className="homework-section">
          <h4>作业管理</h4>
          <div className="homework-buttons">
            <button onClick={saveHomework} className="save-btn">
              保存草稿
            </button>
            <button onClick={submitHomework} className="submit-btn">
              提交作业
            </button>
          </div>
        </div>
      </div>

      {/* 数学键盘 */}
      {showMathKeyboard && (
        <div className="math-keyboard">
          <h4>数学符号</h4>
          <div className="symbol-grid">
            {["α", "β", "γ", "π", "θ", "∑", "∫", "√", "∞", "≠", "≤", "≥", "∠", "⊥", "∥"].map(symbol => (
              <button
                key={symbol}
                onClick={() => insertMathFormula(symbol)}
                className="symbol-btn"
              >
                {symbol}
              </button>
            ))}
          </div>
        </div>
      )}

      {/* 画布区域 */}
      <div className="canvas-area">
        <Excalidraw
          ref={excalidrawRef}
          
          // 教育模式配置
          UIOptions={{
            canvasActions: {
              export: true,
              loadScene: true,
              clearCanvas: true,
              theme: true,
            },
            tools: {
              image: true, // 允许插入图片
            },
          }}
          
          // 初始配置
          initialData={{
            elements: [],
            appState: {
              viewBackgroundColor: "#ffffff",
              gridSize: 20, // 显示网格便于绘制
            },
          }}
          
          // 自定义顶部工具栏
          renderTopRightUI={() => (
            <div className="custom-controls">
              <select
                value={selectedTemplate}
                onChange={(e) => setSelectedTemplate(e.target.value)}
              >
                <option value="">选择模板</option>
                {Object.entries(MATH_TEMPLATES).map(([key, template]) => (
                  <option key={key} value={key}>{template.name}</option>
                ))}
              </select>
              
              <button
                onClick={() => selectedTemplate && insertTemplate(selectedTemplate as keyof typeof MATH_TEMPLATES)}
                disabled={!selectedTemplate}
                className="insert-template-btn"
              >
                插入模板
              </button>
            </div>
          )}
          
          // 网格模式默认开启
          gridModeEnabled={true}
        />
      </div>

      {/* 注释面板 */}
      {annotations.length > 0 && (
        <div className="annotations-panel">
          <h4>注释列表</h4>
          {annotations.map(annotation => (
            <div key={annotation.id} className="annotation-item">
              <span>{annotation.content}</span>
              <button
                onClick={() => setAnnotations(prev => prev.filter(a => a.id !== annotation.id))}
                className="delete-btn"
              >
                删除
              </button>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};
```

### 2.2 教育工具样式

```scss
// EducationDrawingTool.scss
.education-drawing-tool {
  display: flex;
  height: 100vh;
  background: #f8f9fa;

  .education-toolbar {
    width: 300px;
    background: white;
    border-right: 1px solid #e9ecef;
    padding: 16px;
    overflow-y: auto;

    h4 {
      margin: 0 0 12px 0;
      color: #495057;
      font-size: 14px;
      font-weight: 600;
      border-bottom: 2px solid #007bff;
      padding-bottom: 4px;
    }

    .template-section,
    .math-section,
    .tools-section,
    .homework-section {
      margin-bottom: 24px;
    }

    .template-buttons,
    .math-buttons,
    .tool-buttons,
    .homework-buttons {
      display: flex;
      flex-direction: column;
      gap: 8px;

      button {
        padding: 8px 12px;
        border: 1px solid #dee2e6;
        background: white;
        border-radius: 4px;
        cursor: pointer;
        font-size: 13px;
        transition: all 0.2s;

        &:hover {
          background: #f8f9fa;
          border-color: #007bff;
        }
      }
    }

    .template-btn {
      background: #e3f2fd;
      border-color: #2196f3;

      &:hover {
        background: #bbdefb;
      }
    }

    .save-btn {
      background: #d4edda;
      border-color: #28a745;
      color: #155724;

      &:hover {
        background: #c3e6cb;
      }
    }

    .submit-btn {
      background: #f8d7da;
      border-color: #dc3545;
      color: #721c24;

      &:hover {
        background: #f5c6cb;
      }
    }
  }

  .canvas-area {
    flex: 1;
    position: relative;

    .custom-controls {
      display: flex;
      gap: 8px;
      align-items: center;

      select {
        padding: 6px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 12px;
      }

      .insert-template-btn {
        padding: 6px 12px;
        background: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 12px;
        cursor: pointer;

        &:disabled {
          background: #6c757d;
          cursor: not-allowed;
        }
      }
    }
  }

  .math-keyboard {
    position: absolute;
    top: 80px;
    left: 320px;
    background: white;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 16px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    z-index: 1000;

    h4 {
      margin: 0 0 12px 0;
      font-size: 14px;
    }

    .symbol-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 8px;

      .symbol-btn {
        padding: 8px;
        border: 1px solid #dee2e6;
        background: white;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
        min-height: 36px;

        &:hover {
          background: #f8f9fa;
          border-color: #007bff;
        }
      }
    }
  }

  .annotations-panel {
    position: absolute;
    bottom: 20px;
    right: 20px;
    background: white;
    border-radius: 8px;
    padding: 16px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    max-width: 300px;
    z-index: 1000;

    h4 {
      margin: 0 0 12px 0;
      font-size: 14px;
    }

    .annotation-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      margin-bottom: 8px;
      background: #f8f9fa;
      border-radius: 4px;

      span {
        font-size: 13px;
        flex: 1;
      }

      .delete-btn {
        padding: 4px 8px;
        background: #dc3545;
        color: white;
        border: none;
        border-radius: 3px;
        font-size: 11px;
        cursor: pointer;

        &:hover {
          background: #c82333;
        }
      }
    }
  }
}
```

## 案例3：流程图设计器

一个专门用于创建各种流程图的工具，支持自动连接、智能对齐、模板库等功能。

### 3.1 核心实现

```typescript
// FlowchartDesigner.tsx
import React, { useRef, useState, useCallback } from "react";
import { Excalidraw, convertToExcalidrawElements } from "@excalidraw/excalidraw";
import type { ExcalidrawImperativeAPI, ExcalidrawElement } from "@excalidraw/excalidraw/types";

// 流程图形状库
const FLOWCHART_SHAPES = {
  start: {
    name: "开始/结束",
    shape: "ellipse",
    style: { backgroundColor: "#d4edda", strokeColor: "#28a745" }
  },
  process: {
    name: "处理",
    shape: "rectangle", 
    style: { backgroundColor: "#cce5ff", strokeColor: "#007bff" }
  },
  decision: {
    name: "判断",
    shape: "diamond",
    style: { backgroundColor: "#fff3cd", strokeColor: "#ffc107" }
  },
  data: {
    name: "数据",
    shape: "rectangle",
    style: { backgroundColor: "#f8d7da", strokeColor: "#dc3545" }
  },
};

// 流程图模板
const FLOWCHART_TEMPLATES = {
  simple: {
    name: "简单流程",
    elements: [
      { type: "ellipse", x: 200, y: 50, width: 120, height: 60, text: "开始" },
      { type: "rectangle", x: 200, y: 150, width: 120, height: 60, text: "处理" },
      { type: "diamond", x: 200, y: 250, width: 120, height: 80, text: "判断" },
      { type: "ellipse", x: 200, y: 370, width: 120, height: 60, text: "结束" },
    ]
  },
  approval: {
    name: "审批流程", 
    elements: [
      { type: "ellipse", x: 100, y: 50, width: 100, height: 50, text: "提交申请" },
      { type: "diamond", x: 100, y: 150, width: 100, height: 70, text: "部门审核" },
      { type: "diamond", x: 300, y: 150, width: 100, height: 70, text: "领导审批" },
      { type: "ellipse", x: 200, y: 270, width: 100, height: 50, text: "审批完成" },
    ]
  },
};

export const FlowchartDesigner: React.FC = () => {
  const excalidrawRef = useRef<ExcalidrawImperativeAPI>(null);
  const [selectedShape, setSelectedShape] = useState<keyof typeof FLOWCHART_SHAPES>("process");
  const [autoConnect, setAutoConnect] = useState(true);
  const [snapToGrid, setSnapToGrid] = useState(true);

  // 插入形状
  const insertShape = useCallback((shapeType: keyof typeof FLOWCHART_SHAPES, x = 200, y = 200) => {
    const shape = FLOWCHART_SHAPES[shapeType];
    const element = {
      type: shape.shape,
      x: x - 60,
      y: y - 30,
      width: 120,
      height: shape.shape === "diamond" ? 80 : 60,
      ...shape.style,
      strokeWidth: 2,
    };

    const elements = convertToExcalidrawElements([element]);
    const currentElements = excalidrawRef.current?.getSceneElements() || [];
    
    excalidrawRef.current?.updateScene({
      elements: [...currentElements, ...elements],
    });

    // 如果启用自动连接，尝试连接到最近的元素
    if (autoConnect && currentElements.length > 0) {
      const newElement = elements[0];
      const nearestElement = findNearestElement(currentElements, newElement);
      
      if (nearestElement && getDistance(newElement, nearestElement) < 200) {
        connectElements(nearestElement, newElement);
      }
    }
  }, [autoConnect]);

  // 查找最近的元素
  const findNearestElement = (elements: ExcalidrawElement[], targetElement: ExcalidrawElement) => {
    let nearest = null;
    let minDistance = Infinity;

    elements.forEach(element => {
      if (element.id === targetElement.id) return;
      
      const distance = getDistance(element, targetElement);
      if (distance < minDistance) {
        minDistance = distance;
        nearest = element;
      }
    });

    return nearest;
  };

  // 计算两个元素之间的距离
  const getDistance = (element1: ExcalidrawElement, element2: ExcalidrawElement) => {
    const x1 = element1.x + element1.width / 2;
    const y1 = element1.y + element1.height / 2;
    const x2 = element2.x + element2.width / 2;
    const y2 = element2.y + element2.height / 2;
    
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  };

  // 连接两个元素
  const connectElements = (element1: ExcalidrawElement, element2: ExcalidrawElement) => {
    const startX = element1.x + element1.width / 2;
    const startY = element1.y + element1.height;
    const endX = element2.x + element2.width / 2;
    const endY = element2.y;

    const arrow = {
      type: "arrow",
      x: startX,
      y: startY,
      points: [[0, 0], [endX - startX, endY - startY]],
      strokeColor: "#666666",
      strokeWidth: 2,
      endArrowhead: "arrow",
    };

    const elements = convertToExcalidrawElements([arrow]);
    const currentElements = excalidrawRef.current?.getSceneElements() || [];
    
    excalidrawRef.current?.updateScene({
      elements: [...currentElements, ...elements],
    });
  };

  // 插入模板
  const insertTemplate = (templateKey: keyof typeof FLOWCHART_TEMPLATES) => {
    const template = FLOWCHART_TEMPLATES[templateKey];
    const elements = convertToExcalidrawElements(template.elements);
    
    excalidrawRef.current?.updateScene({
      elements,
    });

    // 自动连接模板中的元素
    setTimeout(() => {
      autoConnectTemplate(elements);
    }, 100);
  };

  // 自动连接模板中的元素
  const autoConnectTemplate = (elements: ExcalidrawElement[]) => {
    const connections = [];
    
    for (let i = 0; i < elements.length - 1; i++) {
      const current = elements[i];
      const next = elements[i + 1];
      
      const startX = current.x + current.width / 2;
      const startY = current.y + current.height;
      const endX = next.x + next.width / 2;
      const endY = next.y;
      
      connections.push({
        type: "arrow",
        x: startX,
        y: startY,
        points: [[0, 0], [endX - startX, endY - startY]],
        strokeColor: "#666666",
        strokeWidth: 2,
        endArrowhead: "arrow",
      });
    }

    const connectionElements = convertToExcalidrawElements(connections);
    const currentElements = excalidrawRef.current?.getSceneElements() || [];
    
    excalidrawRef.current?.updateScene({
      elements: [...currentElements, ...connectionElements],
    });
  };

  // 对齐工具
  const alignElements = (direction: "horizontal" | "vertical") => {
    const elements = excalidrawRef.current?.getSceneElements() || [];
    const selectedElements = elements.filter(el => el.isSelected);
    
    if (selectedElements.length < 2) {
      alert("请选择至少两个元素进行对齐");
      return;
    }

    const updatedElements = elements.map(element => {
      if (!element.isSelected) return element;

      if (direction === "horizontal") {
        // 水平对齐到第一个元素的Y坐标
        const referenceY = selectedElements[0].y;
        return { ...element, y: referenceY };
      } else {
        // 垂直对齐到第一个元素的X坐标
        const referenceX = selectedElements[0].x;
        return { ...element, x: referenceX };
      }
    });

    excalidrawRef.current?.updateScene({
      elements: updatedElements,
    });
  };

  // 分布工具
  const distributeElements = (direction: "horizontal" | "vertical") => {
    const elements = excalidrawRef.current?.getSceneElements() || [];
    const selectedElements = elements.filter(el => el.isSelected).sort((a, b) => {
      return direction === "horizontal" ? a.x - b.x : a.y - b.y;
    });
    
    if (selectedElements.length < 3) {
      alert("请选择至少三个元素进行分布");
      return;
    }

    const first = selectedElements[0];
    const last = selectedElements[selectedElements.length - 1];
    const totalDistance = direction === "horizontal" 
      ? (last.x - first.x) 
      : (last.y - first.y);
    
    const step = totalDistance / (selectedElements.length - 1);

    const updatedElements = elements.map(element => {
      const index = selectedElements.findIndex(el => el.id === element.id);
      if (index === -1) return element;

      if (direction === "horizontal") {
        return { ...element, x: first.x + step * index };
      } else {
        return { ...element, y: first.y + step * index };
      }
    });

    excalidrawRef.current?.updateScene({
      elements: updatedElements,
    });
  };

  // 导出流程图
  const exportFlowchart = async (format: "png" | "svg" = "png") => {
    const elements = excalidrawRef.current?.getSceneElements();
    const appState = excalidrawRef.current?.getAppState();
    const files = excalidrawRef.current?.getFiles();

    if (elements && appState) {
      const { exportToBlob, exportToSvg } = await import("@excalidraw/excalidraw");
      
      if (format === "svg") {
        const svg = await exportToSvg({
          elements,
          appState,
          files,
        });
        
        const svgBlob = new Blob([svg.outerHTML], { type: "image/svg+xml" });
        downloadBlob(svgBlob, "flowchart.svg");
      } else {
        const blob = await exportToBlob({
          elements,
          appState,
          files,
          mimeType: "image/png",
        });
        
        downloadBlob(blob, "flowchart.png");
      }
    }
  };

  const downloadBlob = (blob: Blob, filename: string) => {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  };

  // 处理画布点击
  const handleCanvasClick = useCallback((event: any) => {
    if (event.detail === 2) { // 双击
      const rect = event.target.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      
      insertShape(selectedShape, x, y);
    }
  }, [selectedShape, insertShape]);

  return (
    <div className="flowchart-designer">
      {/* 工具面板 */}
      <div className="tools-panel">
        <div className="shapes-section">
          <h4>形状库</h4>
          <div className="shape-buttons">
            {Object.entries(FLOWCHART_SHAPES).map(([key, shape]) => (
              <button
                key={key}
                onClick={() => setSelectedShape(key as keyof typeof FLOWCHART_SHAPES)}
                className={`shape-btn ${selectedShape === key ? "active" : ""}`}
                style={shape.style}
              >
                {shape.name}
              </button>
            ))}
          </div>
        </div>

        <div className="templates-section">
          <h4>模板库</h4>
          <div className="template-buttons">
            {Object.entries(FLOWCHART_TEMPLATES).map(([key, template]) => (
              <button
                key={key}
                onClick={() => insertTemplate(key as keyof typeof FLOWCHART_TEMPLATES)}
                className="template-btn"
              >
                {template.name}
              </button>
            ))}
          </div>
        </div>

        <div className="alignment-section">
          <h4>对齐工具</h4>
          <div className="alignment-buttons">
            <button onClick={() => alignElements("horizontal")}>
              水平对齐
            </button>
            <button onClick={() => alignElements("vertical")}>
              垂直对齐
            </button>
            <button onClick={() => distributeElements("horizontal")}>
              水平分布
            </button>
            <button onClick={() => distributeElements("vertical")}>
              垂直分布
            </button>
          </div>
        </div>

        <div className="settings-section">
          <h4>设置</h4>
          <div className="setting-items">
            <label>
              <input
                type="checkbox"
                checked={autoConnect}
                onChange={(e) => setAutoConnect(e.target.checked)}
              />
              自动连接
            </label>
            <label>
              <input
                type="checkbox"
                checked={snapToGrid}
                onChange={(e) => setSnapToGrid(e.target.checked)}
              />
              网格对齐
            </label>
          </div>
        </div>

        <div className="export-section">
          <h4>导出</h4>
          <div className="export-buttons">
            <button onClick={() => exportFlowchart("png")}>
              导出PNG
            </button>
            <button onClick={() => exportFlowchart("svg")}>
              导出SVG
            </button>
          </div>
        </div>
      </div>

      {/* 画布区域 */}
      <div className="canvas-area" onClick={handleCanvasClick}>
        <Excalidraw
          ref={excalidrawRef}
          
          UIOptions={{
            canvasActions: {
              export: false, // 使用自定义导出
              loadScene: true,
              clearCanvas: true,
            },
          }}
          
          initialData={{
            elements: [],
            appState: {
              gridSize: snapToGrid ? 20 : null,
            },
          }}
          
          gridModeEnabled={snapToGrid}
          
          renderTopRightUI={() => (
            <div className="canvas-controls">
              <span className="help-text">
                双击添加 {FLOWCHART_SHAPES[selectedShape].name}
              </span>
            </div>
          )}
        />
      </div>
    </div>
  );
};
```

### 3.2 流程图样式

```scss
// FlowchartDesigner.scss
.flowchart-designer {
  display: flex;
  height: 100vh;
  background: #f8f9fa;

  .tools-panel {
    width: 280px;
    background: white;
    border-right: 1px solid #e9ecef;
    padding: 16px;
    overflow-y: auto;

    h4 {
      margin: 0 0 12px 0;
      color: #495057;
      font-size: 14px;
      font-weight: 600;
      border-bottom: 2px solid #17a2b8;
      padding-bottom: 4px;
    }

    .shapes-section,
    .templates-section,
    .alignment-section,
    .settings-section,
    .export-section {
      margin-bottom: 24px;
    }

    .shape-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;

      .shape-btn {
        padding: 12px 8px;
        border: 2px solid transparent;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        font-weight: 500;
        transition: all 0.2s;

        &:hover {
          transform: translateY(-1px);
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        &.active {
          border-color: #007bff;
          box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }
      }
    }

    .template-buttons,
    .alignment-buttons,
    .export-buttons {
      display: flex;
      flex-direction: column;
      gap: 8px;

      button {
        padding: 8px 12px;
        border: 1px solid #dee2e6;
        background: white;
        border-radius: 4px;
        cursor: pointer;
        font-size: 13px;
        transition: all 0.2s;

        &:hover {
          background: #f8f9fa;
          border-color: #17a2b8;
        }
      }
    }

    .template-btn {
      background: #e1f5fe;
      border-color: #0288d1;

      &:hover {
        background: #b3e5fc;
      }
    }

    .setting-items {
      display: flex;
      flex-direction: column;
      gap: 8px;

      label {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        color: #495057;
        cursor: pointer;

        input[type="checkbox"] {
          margin: 0;
        }
      }
    }
  }

  .canvas-area {
    flex: 1;
    position: relative;

    .canvas-controls {
      .help-text {
        padding: 6px 12px;
        background: #fff3cd;
        color: #856404;
        border-radius: 4px;
        font-size: 12px;
      }
    }
  }
}
```

## 总结

通过这三个实战案例，我们展示了 Excalidraw 在不同场景下的强大应用能力：

### 案例特点对比

| 案例 | 主要特性 | 技术难点 | 适用场景 |
|------|----------|----------|----------|
| **协作白板** | 实时协作、数据同步 | WebSocket管理、冲突解决 | 团队协作、远程办公 |
| **教育工具** | 模板库、数学符号 | 专业模板、符号渲染 | 在线教育、作业系统 |
| **流程图设计器** | 自动连接、智能对齐 | 图形算法、布局优化 | 业务流程、系统设计 |

### 核心技术要点

1. **状态管理** - 使用 refs 和回调函数管理复杂状态
2. **实时通信** - WebSocket 实现多人协作
3. **数据持久化** - 结合 Redis 和 MongoDB 的存储策略
4. **性能优化** - 节流、防抖、缓存等优化技术
5. **用户体验** - 智能提示、模板库、快捷操作

### 扩展建议

基于这些案例，你可以继续扩展：

- **插件系统** - 支持第三方插件扩展功能
- **AI 集成** - 智能图表生成、内容识别
- **多平台支持** - 移动端适配、桌面应用
- **企业功能** - 权限管理、审计日志、版本控制

这些案例为你的 Excalidraw 二次开发提供了完整的参考实现，你可以根据具体需求进行调整和扩展。🎨