# 第五章：元素系统与图形抽象（基于真实Excalidraw源码）

## 5.1 真实的元素类型系统

通过深入分析Excalidraw的真实源码，我们发现其元素系统设计得极其精巧和完善。让我们从实际代码出发，理解真正的工程实践。

### 5.1.1 元素基础类型定义

```typescript
// 基于 packages/element/src/types.ts 的真实实现

type _ExcalidrawElementBase = Readonly<{
  // 基本标识
  id: string;
  
  // 几何属性
  x: number;
  y: number;
  width: number;
  height: number;
  angle: Radians;
  
  // 视觉样式
  strokeColor: string;
  backgroundColor: string;
  fillStyle: FillStyle; // "hachure" | "cross-hatch" | "solid" | "zigzag"
  strokeWidth: number;
  strokeStyle: StrokeStyle; // "solid" | "dashed" | "dotted"
  roundness: null | { type: RoundnessType; value?: number };
  roughness: number;
  opacity: number;
  
  // 版本控制和协作
  /** 随机整数，用于种子化形状生成，确保roughjs形状在渲染间不变 */
  seed: number;
  /** 在每次变更时顺序递增的整数，用于协作时的元素协调或保存到服务器 */
  version: number;
  /** 在每次变更时重新生成的随机整数，用于协作期间的确定性协调 */
  versionNonce: number;
  /** 分数形式的字符串，用于多人场景中的排序 */
  index: FractionalIndex | null;
  /** 元素上次更新的纪元时间戳(ms) */
  updated: number;
  
  // 状态标记
  isDeleted: boolean;
  locked: boolean;
  
  // 层次结构
  /** 元素所属的组列表，从最深到最浅排序 */
  groupIds: readonly GroupId[];
  frameId: string | null;
  
  // 绑定关系
  /** 绑定到此元素的其他元素 */
  boundElements: readonly BoundElement[] | null;
  
  // 链接和自定义数据
  link: string | null;
  customData?: Record<string, any>;
}>;

// 具体元素类型
export type ExcalidrawRectangleElement = _ExcalidrawElementBase & {
  type: "rectangle";
};

export type ExcalidrawDiamondElement = _ExcalidrawElementBase & {
  type: "diamond";
};

export type ExcalidrawEllipseElement = _ExcalidrawElementBase & {
  type: "ellipse";
};

export type ExcalidrawImageElement = _ExcalidrawElementBase & {
  type: "image";
  fileId: FileId | null;
  status: "pending" | "saved" | "error";
  scale: [number, number]; // X和Y缩放因子，用于图像轴翻转
  crop: ImageCrop | null;  // 图像裁剪信息
};

export type ExcalidrawTextElement = _ExcalidrawElementBase & {
  type: "text";
  fontSize: number;
  fontFamily: FontFamilyValues;
  text: string;
  textAlign: TextAlign;
  verticalAlign: VerticalAlign;
  containerId: ExcalidrawElement["id"] | null;
  originalText: string;
  /** 文本自动调整大小的方向 */
  autoResize: boolean;
  lineHeight: LineHeight;
};

export type ExcalidrawLinearElement = _ExcalidrawElementBase & {
  type: "line" | "arrow" | "elbow-arrow";
  points: readonly Point[];
  lastCommittedPoint: Point | null;
  startBinding: PointBinding | null;
  endBinding: PointBinding | null;
  startArrowhead: Arrowhead | null;
  endArrowhead: Arrowhead | null;
};

export type ExcalidrawFreeDrawElement = _ExcalidrawElementBase & {
  type: "freedraw";
  points: readonly Point[];
  pressures: readonly number[];
  simulatePressure: boolean;
};

export type ExcalidrawFrameElement = _ExcalidrawElementBase & {
  type: "frame";
  name: string | null;
};

export type ExcalidrawEmbeddableElement = _ExcalidrawElementBase & {
  type: "embeddable";
};

export type ExcalidrawIframeElement = _ExcalidrawElementBase & {
  type: "iframe";
  customData?: { generationData?: MagicGenerationData };
};

// 元素分组类型
export type ExcalidrawGenericElement =
  | ExcalidrawSelectionElement
  | ExcalidrawRectangleElement
  | ExcalidrawDiamondElement
  | ExcalidrawEllipseElement;

export type ExcalidrawFlowchartNodeElement =
  | ExcalidrawRectangleElement
  | ExcalidrawDiamondElement
  | ExcalidrawEllipseElement;

export type ExcalidrawRectanguloidElement =
  | ExcalidrawRectangleElement
  | ExcalidrawImageElement
  | ExcalidrawTextElement
  | ExcalidrawFreeDrawElement
  | ExcalidrawIframeLikeElement
  | ExcalidrawFrameLikeElement
  | ExcalidrawEmbeddableElement
  | ExcalidrawSelectionElement;

// 主要元素联合类型
export type ExcalidrawElement =
  | ExcalidrawGenericElement
  | ExcalidrawTextElement
  | ExcalidrawLinearElement
  | ExcalidrawFreeDrawElement
  | ExcalidrawImageElement
  | ExcalidrawFrameLikeElement
  | ExcalidrawEmbeddableElement
  | ExcalidrawIframeElement;

// 非删除元素类型
export type NonDeletedExcalidrawElement = NonDeleted<ExcalidrawElement>;
```

### 5.1.2 元素创建的真实实现

```typescript
// 基于 packages/element/src/newElement.ts 的真实实现

export type ElementConstructorOpts = MarkOptional<
  Omit<ExcalidrawGenericElement, "id" | "type" | "isDeleted" | "updated">,
  | "width"
  | "height"
  | "angle"
  | "groupIds"
  | "frameId"
  | "index"
  | "roundness"
  | "boundElements"
  | "seed"
  | "version"
  | "versionNonce"
  | "link"
  | "locked"
  | "customData"
>;

const _newElementBase = <T extends ExcalidrawElement>(
  type: T["type"],
  opts: {
    x?: number;
    y?: number;
    strokeColor?: string;
    backgroundColor?: string;
    fillStyle?: FillStyle;
    strokeWidth?: number;
    strokeStyle?: StrokeStyle;
    roughness?: number;
    opacity?: number;
    width?: number;
    height?: number;
    angle?: Radians;
    groupIds?: readonly GroupId[];
    frameId?: string | null;
    index?: FractionalIndex | null;
    roundness?: ExcalidrawElement["roundness"];
    boundElements?: ExcalidrawElement["boundElements"];
    link?: string | null;
    locked?: boolean;
    customData?: ExcalidrawElement["customData"];
  } = {}
): Omit<T, "type"> => {
  return {
    id: randomId(),
    x: opts.x ?? 0,
    y: opts.y ?? 0,
    strokeColor: opts.strokeColor ?? DEFAULT_ELEMENT_PROPS.strokeColor,
    backgroundColor: opts.backgroundColor ?? DEFAULT_ELEMENT_PROPS.backgroundColor,
    fillStyle: opts.fillStyle ?? DEFAULT_ELEMENT_PROPS.fillStyle,
    strokeWidth: opts.strokeWidth ?? DEFAULT_ELEMENT_PROPS.strokeWidth,
    strokeStyle: opts.strokeStyle ?? DEFAULT_ELEMENT_PROPS.strokeStyle,
    roughness: opts.roughness ?? DEFAULT_ELEMENT_PROPS.roughness,
    opacity: opts.opacity ?? DEFAULT_ELEMENT_PROPS.opacity,
    width: opts.width ?? 0,
    height: opts.height ?? 0,
    angle: opts.angle ?? (0 as Radians),
    groupIds: opts.groupIds ?? [],
    frameId: opts.frameId ?? null,
    index: opts.index ?? null,
    roundness: opts.roundness ?? DEFAULT_ELEMENT_PROPS.roundness,
    seed: randomInteger(),
    version: 1,
    versionNonce: randomInteger(),
    isDeleted: false,
    boundElements: opts.boundElements ?? null,
    updated: getUpdatedTimestamp(),
    link: opts.link ?? null,
    locked: opts.locked ?? DEFAULT_ELEMENT_PROPS.locked,
    customData: opts.customData,
  } as Omit<T, "type">;
};

// 创建矩形元素
export const newRectangleElement = (
  opts: ElementConstructorOpts
): ExcalidrawRectangleElement => {
  return {
    ..._newElementBase<ExcalidrawRectangleElement>("rectangle", opts),
    type: "rectangle",
  };
};

// 创建椭圆元素
export const newEllipseElement = (
  opts: ElementConstructorOpts
): ExcalidrawEllipseElement => {
  return {
    ..._newElementBase<ExcalidrawEllipseElement>("ellipse", opts),
    type: "ellipse",
  };
};

// 创建钻石元素
export const newDiamondElement = (
  opts: ElementConstructorOpts
): ExcalidrawDiamondElement => {
  return {
    ..._newElementBase<ExcalidrawDiamondElement>("diamond", opts),
    type: "diamond",
  };
};

// 创建文本元素
export const newTextElement = (
  opts: {
    text?: string;
    fontSize?: number;
    fontFamily?: FontFamilyValues;
    textAlign?: TextAlign;
    verticalAlign?: VerticalAlign;
    containerId?: ExcalidrawTextContainer["id"] | null;
    autoResize?: boolean;
  } & ElementConstructorOpts
): ExcalidrawTextElement => {
  const fontSize = opts.fontSize ?? DEFAULT_FONT_SIZE;
  const fontFamily = opts.fontFamily ?? DEFAULT_FONT_FAMILY;
  const text = normalizeText(opts.text || "");
  
  // 测量文本尺寸
  const { width, height } = measureText(
    text,
    getFontString({ fontSize, fontFamily }),
    getLineHeight(fontFamily)
  );
  
  const textElement: ExcalidrawTextElement = {
    ..._newElementBase<ExcalidrawTextElement>("text", {
      ...opts,
      width: opts.width ?? width,
      height: opts.height ?? height,
    }),
    type: "text",
    fontSize,
    fontFamily,
    text,
    textAlign: opts.textAlign ?? DEFAULT_TEXT_ALIGN,
    verticalAlign: opts.verticalAlign ?? VERTICAL_ALIGN.top,
    containerId: opts.containerId ?? null,
    originalText: text,
    autoResize: opts.autoResize ?? true,
    lineHeight: getLineHeight(fontFamily),
  };
  
  return textElement;
};

// 创建线性元素
export const newLinearElement = (
  type: "line" | "arrow" | "elbow-arrow",
  opts: {
    points?: Point[];
    startArrowhead?: Arrowhead | null;
    endArrowhead?: Arrowhead | null;
  } & ElementConstructorOpts
): ExcalidrawLinearElement => {
  const points = opts.points ?? [[0, 0], [100, 100]];
  
  return {
    ..._newElementBase<ExcalidrawLinearElement>(type, opts),
    type,
    points,
    lastCommittedPoint: null,
    startBinding: null,
    endBinding: null,
    startArrowhead: opts.startArrowhead ?? null,
    endArrowhead: opts.endArrowhead ?? (type === "arrow" ? "arrow" : null),
  };
};

// 创建自由绘制元素
export const newFreeDrawElement = (
  opts: {
    points?: Point[];
    pressures?: number[];
    simulatePressure?: boolean;
  } & ElementConstructorOpts
): ExcalidrawFreeDrawElement => {
  return {
    ..._newElementBase<ExcalidrawFreeDrawElement>("freedraw", opts),
    type: "freedraw",
    points: opts.points ?? [],
    pressures: opts.pressures ?? [],
    simulatePressure: opts.simulatePressure ?? true,
  };
};

// 创建图片元素
export const newImageElement = (
  opts: {
    fileId?: FileId | null;
    status?: "pending" | "saved" | "error";
    scale?: [number, number];
    crop?: ImageCrop | null;
  } & ElementConstructorOpts
): ExcalidrawImageElement => {
  return {
    ..._newElementBase<ExcalidrawImageElement>("image", opts),
    type: "image",
    fileId: opts.fileId ?? null,
    status: opts.status ?? "pending",
    scale: opts.scale ?? [1, 1],
    crop: opts.crop ?? null,
  };
};

// 创建框架元素
export const newFrameElement = (
  opts: {
    name?: string | null;
  } & ElementConstructorOpts
): ExcalidrawFrameElement => {
  return {
    ..._newElementBase<ExcalidrawFrameElement>("frame", opts),
    type: "frame",
    name: opts.name ?? null,
  };
};
```

## 5.2 元素变更系统

### 5.2.1 不可变更新的真实实现

```typescript
// 基于 packages/element/src/mutateElement.ts 的真实实现

type MutableElement = Omit<ExcalidrawElement, "id" | "seed">;

/**
 * 变更元素 - 这是 Excalidraw 中修改元素的标准方式
 * 使用就地变更以获得性能，但保持外部 API 的不可变性
 */
export const mutateElement = <TElement extends ExcalidrawElement>(
  element: TElement,
  updates: Partial<MutableElement>,
  informMutation = true
): TElement => {
  const mutableElement = element as any;
  
  let shouldUpdateVersion = false;
  let shouldUpdateTimestamp = false;
  
  for (const key in updates) {
    const value = updates[key as keyof MutableElement];
    if (
      typeof value !== "undefined" &&
      mutableElement[key] !== value
    ) {
      mutableElement[key] = value;
      shouldUpdateVersion = true;
      
      // 某些属性变更需要更新时间戳
      if (key !== "version" && key !== "versionNonce" && key !== "updated") {
        shouldUpdateTimestamp = true;
      }
    }
  }
  
  // 更新版本信息
  if (shouldUpdateVersion) {
    mutableElement.version++;
    mutableElement.versionNonce = randomInteger();
    
    if (shouldUpdateTimestamp) {
      mutableElement.updated = getUpdatedTimestamp();
    }
  }
  
  // 通知场景变更
  if (informMutation && shouldUpdateVersion) {
    Scene.getScene(element)?.informMutation();
  }
  
  return mutableElement;
};

/**
 * 创建元素的新版本（浅拷贝 + 更新）
 */
export const newElementWith = <TElement extends ExcalidrawElement>(
  element: TElement,
  updates: Partial<MutableElement>
): TElement => {
  const newElement = {
    ...element,
    ...updates,
  } as TElement;
  
  // 更新版本信息
  if (Object.keys(updates).length > 0) {
    newElement.version = element.version + 1;
    newElement.versionNonce = randomInteger();
    newElement.updated = getUpdatedTimestamp();
  }
  
  return newElement;
};

/**
 * 批量变更多个元素
 */
export const mutateElements = (
  elements: readonly ExcalidrawElement[],
  updates: { [id: string]: Partial<MutableElement> },
  informMutation = true
): ExcalidrawElement[] => {
  const nextElements = [...elements];
  let didChange = false;
  
  for (let i = 0; i < nextElements.length; i++) {
    const element = nextElements[i];
    const update = updates[element.id];
    
    if (update && Object.keys(update).length > 0) {
      nextElements[i] = mutateElement(element, update, false);
      didChange = true;
    }
  }
  
  // 批量通知变更
  if (didChange && informMutation) {
    Scene.informMutation();
  }
  
  return nextElements;
};

/**
 * 批量创建元素的新版本
 */
export const newElementsWith = (
  elements: readonly ExcalidrawElement[],
  updates: { [id: string]: Partial<MutableElement> }
): ExcalidrawElement[] => {
  return elements.map(element => {
    const update = updates[element.id];
    return update ? newElementWith(element, update) : element;
  });
};
```

### 5.2.2 元素边界计算

```typescript
// 基于 packages/element/src/bounds.ts 的真实实现

type Bounds = readonly [
  minX: number,
  minY: number,
  maxX: number,
  maxY: number
];

/**
 * 获取元素的绝对坐标边界
 */
export const getElementAbsoluteCoords = (
  element: ExcalidrawElement,
  includeBoundText = false
): Bounds => {
  if (isLinearElement(element)) {
    return getLinearElementAbsoluteCoords(element);
  }
  if (isTextElement(element)) {
    return getTextElementAbsoluteCoords(element);
  }
  if (isFreeDrawElement(element)) {
    return getFreeDrawElementAbsoluteCoords(element);
  }
  
  // 基本元素的边界计算
  const [x1, y1, x2, y2] = getElementBounds(element);
  
  // 考虑旋转
  if (element.angle !== 0) {
    const [rotatedX1, rotatedY1, rotatedX2, rotatedY2] = 
      getRotatedElementAbsoluteCoords(element, x1, y1, x2, y2);
    return [rotatedX1, rotatedY1, rotatedX2, rotatedY2];
  }
  
  let bounds: Bounds = [x1, y1, x2, y2];
  
  // 包含绑定文本的边界
  if (includeBoundText) {
    const boundTextElement = getBoundTextElement(element);
    if (boundTextElement) {
      const textBounds = getElementAbsoluteCoords(boundTextElement);
      bounds = [
        Math.min(bounds[0], textBounds[0]),
        Math.min(bounds[1], textBounds[1]),
        Math.max(bounds[2], textBounds[2]),
        Math.max(bounds[3], textBounds[3]),
      ];
    }
  }
  
  return bounds;
};

/**
 * 获取元素的基本边界框
 */
export const getElementBounds = (element: ExcalidrawElement): Bounds => {
  return [
    element.x,
    element.y,
    element.x + element.width,
    element.y + element.height,
  ];
};

/**
 * 获取线性元素的边界
 */
const getLinearElementAbsoluteCoords = (
  element: ExcalidrawLinearElement
): Bounds => {
  const points = element.points;
  
  if (points.length < 1) {
    return [element.x, element.y, element.x, element.y];
  }
  
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  
  for (const [x, y] of points) {
    const absoluteX = element.x + x;
    const absoluteY = element.y + y;
    
    minX = Math.min(minX, absoluteX);
    minY = Math.min(minY, absoluteY);
    maxX = Math.max(maxX, absoluteX);
    maxY = Math.max(maxY, absoluteY);
  }
  
  // 考虑描边宽度
  const strokeWidth = element.strokeWidth;
  return [
    minX - strokeWidth / 2,
    minY - strokeWidth / 2,
    maxX + strokeWidth / 2,
    maxY + strokeWidth / 2,
  ];
};

/**
 * 获取文本元素的边界
 */
const getTextElementAbsoluteCoords = (
  element: ExcalidrawTextElement
): Bounds => {
  const [x1, y1, x2, y2] = getElementBounds(element);
  
  // 文本元素可能需要额外的填充
  const padding = 4;
  return [
    x1 - padding,
    y1 - padding,
    x2 + padding,
    y2 + padding,
  ];
};

/**
 * 获取自由绘制元素的边界
 */
const getFreeDrawElementAbsoluteCoords = (
  element: ExcalidrawFreeDrawElement
): Bounds => {
  const points = element.points;
  
  if (points.length === 0) {
    return [element.x, element.y, element.x, element.y];
  }
  
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  
  for (const [x, y] of points) {
    const absoluteX = element.x + x;
    const absoluteY = element.y + y;
    
    minX = Math.min(minX, absoluteX);
    minY = Math.min(minY, absoluteY);
    maxX = Math.max(maxX, absoluteX);
    maxY = Math.max(maxY, absoluteY);
  }
  
  // 考虑描边宽度
  const strokeWidth = element.strokeWidth;
  return [
    minX - strokeWidth / 2,
    minY - strokeWidth / 2,
    maxX + strokeWidth / 2,
    maxY + strokeWidth / 2,
  ];
};

/**
 * 计算旋转元素的边界
 */
const getRotatedElementAbsoluteCoords = (
  element: ExcalidrawElement,
  x1: number,
  y1: number,
  x2: number,
  y2: number
): Bounds => {
  const cx = (x1 + x2) / 2;
  const cy = (y1 + y2) / 2;
  const angle = element.angle;
  
  // 计算四个角点的旋转后坐标
  const corners = [
    [x1, y1],
    [x2, y1],
    [x2, y2],
    [x1, y2],
  ];
  
  const rotatedCorners = corners.map(([x, y]) => {
    const dx = x - cx;
    const dy = y - cy;
    const rotatedX = cx + dx * Math.cos(angle) - dy * Math.sin(angle);
    const rotatedY = cy + dx * Math.sin(angle) + dy * Math.cos(angle);
    return [rotatedX, rotatedY];
  });
  
  // 找到最小和最大边界
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  
  for (const [x, y] of rotatedCorners) {
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x);
    maxY = Math.max(maxY, y);
  }
  
  return [minX, minY, maxX, maxY];
};

/**
 * 检查点是否在元素内部
 */
export const isPointInElement = (
  point: { x: number; y: number },
  element: ExcalidrawElement
): boolean => {
  if (isLinearElement(element)) {
    return isPointInLinearElement(point, element);
  }
  if (isTextElement(element)) {
    return isPointInTextElement(point, element);
  }
  if (isFreeDrawElement(element)) {
    return isPointInFreeDrawElement(point, element);
  }
  
  // 基本形状的点检测
  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);
  
  if (element.angle !== 0) {
    // 旋转元素需要将点逆向旋转后检测
    const cx = (x1 + x2) / 2;
    const cy = (y1 + y2) / 2;
    const dx = point.x - cx;
    const dy = point.y - cy;
    const angle = -element.angle;
    
    const rotatedX = cx + dx * Math.cos(angle) - dy * Math.sin(angle);
    const rotatedY = cy + dx * Math.sin(angle) + dy * Math.cos(angle);
    
    return rotatedX >= x1 && rotatedX <= x2 && 
           rotatedY >= y1 && rotatedY <= y2;
  }
  
  // 简单边界框检测
  return point.x >= x1 && point.x <= x2 && 
         point.y >= y1 && point.y <= y2;
};
```

## 5.3 元素渲染系统

### 5.3.1 渲染分发器

```typescript
// 基于 packages/element/src/renderElement.ts 的真实实现

/**
 * 渲染单个元素
 */
export const renderElement = (
  element: NonDeletedExcalidrawElement,
  rc: RoughCanvas,
  context: CanvasRenderingContext2D,
  renderConfig: StaticCanvasRenderConfig,
  appState: StaticCanvasAppState
): void => {
  const { 
    isExporting = false,
    renderGrid = true,
    frameRendering,
  } = renderConfig;
  
  // 设置渲染上下文
  context.save();
  
  try {
    // 应用透明度
    if (element.opacity < 1) {
      context.globalAlpha = element.opacity;
    }
    
    // 应用变换
    if (element.angle !== 0) {
      const [cx, cy] = getElementCenter(element);
      context.translate(cx, cy);
      context.rotate(element.angle);
      context.translate(-cx, -cy);
    }
    
    // 根据元素类型分发渲染
    switch (element.type) {
      case "rectangle":
      case "diamond":
      case "ellipse":
        renderGenericElement(element, rc, context, appState);
        break;
        
      case "text":
        renderTextElement(element, context, appState);
        break;
        
      case "line":
      case "arrow":
      case "elbow-arrow":
        renderLinearElement(element, rc, context, appState);
        break;
        
      case "freedraw":
        renderFreeDrawElement(element, context, appState);
        break;
        
      case "image":
        renderImageElement(element, context, appState);
        break;
        
      case "frame":
      case "magicframe":
        renderFrameElement(element, rc, context, appState, frameRendering);
        break;
        
      case "embeddable":
      case "iframe":
        renderEmbeddableElement(element, context, appState);
        break;
    }
    
    // 渲染选择指示器
    if (!isExporting && isElementSelected(element, appState)) {
      renderSelectionBorder(element, context, appState);
    }
    
    // 渲染链接指示器
    if (element.link && !isExporting) {
      renderLinkIcon(element, context, appState);
    }
    
  } finally {
    context.restore();
  }
};

/**
 * 渲染通用几何元素
 */
const renderGenericElement = (
  element: ExcalidrawGenericElement,
  rc: RoughCanvas,
  context: CanvasRenderingContext2D,
  appState: StaticCanvasAppState
): void => {
  const { x, y, width, height } = element;
  
  // 设置样式
  const roughOptions = {
    seed: element.seed,
    strokeWidth: element.strokeWidth,
    stroke: element.strokeColor,
    fill: element.backgroundColor,
    fillStyle: element.fillStyle,
    roughness: element.roughness,
    strokeLineDash: getStrokeLineDash(element.strokeStyle),
  };
  
  // 根据形状类型渲染
  switch (element.type) {
    case "rectangle":
      if (element.roundness) {
        const radius = getRoundedRectangleRadius(element);
        renderRoundedRectangle(context, rc, x, y, width, height, radius, roughOptions);
      } else {
        rc.rectangle(x, y, width, height, roughOptions);
      }
      break;
      
    case "diamond":
      renderDiamond(rc, x, y, width, height, roughOptions);
      break;
      
    case "ellipse":
      rc.ellipse(x + width / 2, y + height / 2, width, height, roughOptions);
      break;
  }
};

/**
 * 渲染文本元素
 */
const renderTextElement = (
  element: ExcalidrawTextElement,
  context: CanvasRenderingContext2D,
  appState: StaticCanvasAppState
): void => {
  const { x, y, width, height, text, fontSize, fontFamily, textAlign, verticalAlign } = element;
  
  // 设置字体
  context.font = getFontString({ fontSize, fontFamily });
  context.fillStyle = element.strokeColor;
  context.textAlign = textAlign;
  
  // 分割文本行
  const lines = text.split('\n');
  const lineHeight = getLineHeight(fontFamily);
  const actualLineHeight = fontSize * lineHeight;
  
  // 计算垂直对齐的起始Y位置
  let startY = y;
  if (verticalAlign === VERTICAL_ALIGN.middle) {
    startY = y + (height - lines.length * actualLineHeight) / 2;
  } else if (verticalAlign === VERTICAL_ALIGN.bottom) {
    startY = y + height - lines.length * actualLineHeight;
  }
  
  // 计算水平对齐的X位置
  let textX = x;
  if (textAlign === 'center') {
    textX = x + width / 2;
  } else if (textAlign === 'right') {
    textX = x + width;
  }
  
  // 渲染每一行
  lines.forEach((line, index) => {
    const lineY = startY + (index + 1) * actualLineHeight;
    context.fillText(line, textX, lineY);
  });
};

/**
 * 渲染线性元素
 */
const renderLinearElement = (
  element: ExcalidrawLinearElement,
  rc: RoughCanvas,
  context: CanvasRenderingContext2D,
  appState: StaticCanvasAppState
): void => {
  const { points, strokeColor, strokeWidth, strokeStyle } = element;
  
  if (points.length < 2) return;
  
  // 转换为绝对坐标
  const absolutePoints = points.map(([x, y]) => [element.x + x, element.y + y]);
  
  // 设置样式
  const roughOptions = {
    seed: element.seed,
    strokeWidth,
    stroke: strokeColor,
    roughness: element.roughness,
    strokeLineDash: getStrokeLineDash(strokeStyle),
  };
  
  if (element.type === "line") {
    // 渲染普通线条
    rc.linearPath(absolutePoints, roughOptions);
  } else if (element.type === "arrow") {
    // 渲染箭头
    rc.linearPath(absolutePoints, roughOptions);
    
    // 渲染箭头头部
    if (element.endArrowhead) {
      renderArrowhead(context, absolutePoints, element.endArrowhead, strokeColor, strokeWidth);
    }
    if (element.startArrowhead) {
      renderArrowhead(context, absolutePoints.slice().reverse(), element.startArrowhead, strokeColor, strokeWidth);
    }
  } else if (element.type === "elbow-arrow") {
    // 渲染肘形箭头（特殊的多段线箭头）
    renderElbowArrow(element, rc, context, appState);
  }
};

/**
 * 渲染自由绘制元素
 */
const renderFreeDrawElement = (
  element: ExcalidrawFreeDrawElement,
  context: CanvasRenderingContext2D,
  appState: StaticCanvasAppState
): void => {
  const { points, pressures, strokeColor, strokeWidth } = element;
  
  if (points.length < 2) return;
  
  context.save();
  context.strokeStyle = strokeColor;
  context.lineCap = 'round';
  context.lineJoin = 'round';
  
  // 使用压力敏感绘制
  if (element.simulatePressure || pressures.length > 0) {
    renderPressureSensitivePath(context, element);
  } else {
    // 简单路径绘制
    context.lineWidth = strokeWidth;
    context.beginPath();
    
    const [firstX, firstY] = points[0];
    context.moveTo(element.x + firstX, element.y + firstY);
    
    for (let i = 1; i < points.length; i++) {
      const [x, y] = points[i];
      context.lineTo(element.x + x, element.y + y);
    }
    
    context.stroke();
  }
  
  context.restore();
};

/**
 * 渲染压力敏感路径
 */
const renderPressureSensitivePath = (
  context: CanvasRenderingContext2D,
  element: ExcalidrawFreeDrawElement
): void => {
  const { points, pressures, strokeWidth } = element;
  
  for (let i = 0; i < points.length - 1; i++) {
    const [x1, y1] = points[i];
    const [x2, y2] = points[i + 1];
    
    // 获取压力值
    const pressure1 = pressures[i] || 0.5;
    const pressure2 = pressures[i + 1] || 0.5;
    
    // 计算线条宽度
    const width1 = strokeWidth * pressure1;
    const width2 = strokeWidth * pressure2;
    
    // 绘制渐变宽度的线段
    drawPressureLine(
      context,
      element.x + x1, element.y + y1, width1,
      element.x + x2, element.y + y2, width2
    );
  }
};

/**
 * 绘制压力线条
 */
const drawPressureLine = (
  context: CanvasRenderingContext2D,
  x1: number, y1: number, width1: number,
  x2: number, y2: number, width2: number
): void => {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const length = Math.sqrt(dx * dx + dy * dy);
  
  if (length === 0) return;
  
  const unitX = dx / length;
  const unitY = dy / length;
  
  // 垂直方向向量
  const perpX = -unitY;
  const perpY = unitX;
  
  // 计算四个边界点
  const halfWidth1 = width1 / 2;
  const halfWidth2 = width2 / 2;
  
  const p1x = x1 + perpX * halfWidth1;
  const p1y = y1 + perpY * halfWidth1;
  const p2x = x1 - perpX * halfWidth1;
  const p2y = y1 - perpY * halfWidth1;
  const p3x = x2 - perpX * halfWidth2;
  const p3y = y2 - perpY * halfWidth2;
  const p4x = x2 + perpX * halfWidth2;
  const p4y = y2 + perpY * halfWidth2;
  
  // 绘制四边形
  context.beginPath();
  context.moveTo(p1x, p1y);
  context.lineTo(p4x, p4y);
  context.lineTo(p3x, p3y);
  context.lineTo(p2x, p2y);
  context.closePath();
  context.fill();
};
```

## 5.4 实践项目：完整的元素系统

基于真实的Excalidraw源码，让我们实现一个完整的元素系统：

```typescript
// 完整的元素管理系统
class ElementManager {
  private elements = new Map<string, ExcalidrawElement>();
  private scene: Scene;
  private history: History;
  
  constructor(scene: Scene, history: History) {
    this.scene = scene;
    this.history = history;
  }
  
  // 创建新元素
  createElement(
    type: ExcalidrawElement["type"],
    options: Partial<ExcalidrawElement>
  ): ExcalidrawElement {
    let element: ExcalidrawElement;
    
    switch (type) {
      case "rectangle":
        element = newRectangleElement(options);
        break;
      case "ellipse":
        element = newEllipseElement(options);
        break;
      case "diamond":
        element = newDiamondElement(options);
        break;
      case "text":
        element = newTextElement(options);
        break;
      case "line":
      case "arrow":
      case "elbow-arrow":
        element = newLinearElement(type, options);
        break;
      case "freedraw":
        element = newFreeDrawElement(options);
        break;
      case "image":
        element = newImageElement(options);
        break;
      case "frame":
        element = newFrameElement(options);
        break;
      default:
        throw new Error(`Unknown element type: ${type}`);
    }
    
    this.elements.set(element.id, element);
    this.updateScene();
    
    return element;
  }
  
  // 更新元素
  updateElement(
    elementId: string,
    updates: Partial<ExcalidrawElement>
  ): ExcalidrawElement | null {
    const element = this.elements.get(elementId);
    if (!element) return null;
    
    const updatedElement = mutateElement(element, updates);
    this.elements.set(elementId, updatedElement);
    this.updateScene();
    
    return updatedElement;
  }
  
  // 删除元素
  deleteElement(elementId: string): boolean {
    const element = this.elements.get(elementId);
    if (!element) return false;
    
    mutateElement(element, { isDeleted: true });
    this.updateScene();
    
    return true;
  }
  
  // 复制元素
  duplicateElement(elementId: string, offset = { x: 20, y: 20 }): ExcalidrawElement | null {
    const element = this.elements.get(elementId);
    if (!element) return null;
    
    const duplicatedElement = {
      ...element,
      id: randomId(),
      x: element.x + offset.x,
      y: element.y + offset.y,
      seed: randomInteger(),
      version: 1,
      versionNonce: randomInteger(),
      updated: getUpdatedTimestamp(),
    };
    
    this.elements.set(duplicatedElement.id, duplicatedElement);
    this.updateScene();
    
    return duplicatedElement;
  }
  
  // 群组元素
  groupElements(elementIds: string[], groupId?: string): string {
    const finalGroupId = groupId || randomId();
    
    elementIds.forEach(elementId => {
      const element = this.elements.get(elementId);
      if (element) {
        mutateElement(element, {
          groupIds: [...element.groupIds, finalGroupId]
        });
      }
    });
    
    this.updateScene();
    return finalGroupId;
  }
  
  // 取消群组
  ungroupElements(groupId: string): void {
    for (const element of this.elements.values()) {
      if (element.groupIds.includes(groupId)) {
        mutateElement(element, {
          groupIds: element.groupIds.filter(id => id !== groupId)
        });
      }
    }
    
    this.updateScene();
  }
  
  // 调整元素层级
  moveElementToLayer(elementId: string, direction: 'front' | 'back' | 'forward' | 'backward'): void {
    const element = this.elements.get(elementId);
    if (!element) return;
    
    const allElements = Array.from(this.elements.values());
    const currentIndex = allElements.findIndex(el => el.id === elementId);
    
    let newIndex: number;
    switch (direction) {
      case 'front':
        newIndex = allElements.length - 1;
        break;
      case 'back':
        newIndex = 0;
        break;
      case 'forward':
        newIndex = Math.min(currentIndex + 1, allElements.length - 1);
        break;
      case 'backward':
        newIndex = Math.max(currentIndex - 1, 0);
        break;
    }
    
    // 更新分数索引
    const newFractionalIndex = this.calculateNewFractionalIndex(allElements, newIndex);
    mutateElement(element, { index: newFractionalIndex });
    
    this.updateScene();
  }
  
  // 获取元素边界
  getElementBounds(elementId: string): Bounds | null {
    const element = this.elements.get(elementId);
    if (!element) return null;
    
    return getElementAbsoluteCoords(element);
  }
  
  // 检查点击命中
  getElementAtPoint(point: { x: number; y: number }): ExcalidrawElement | null {
    // 从前往后检查（后渲染的元素优先）
    const elements = Array.from(this.elements.values())
      .filter(el => !el.isDeleted)
      .sort((a, b) => (b.index || '') > (a.index || '') ? 1 : -1);
    
    for (const element of elements) {
      if (isPointInElement(point, element)) {
        return element;
      }
    }
    
    return null;
  }
  
  // 获取区域内的元素
  getElementsInArea(area: Bounds): ExcalidrawElement[] {
    const [areaX1, areaY1, areaX2, areaY2] = area;
    
    return Array.from(this.elements.values()).filter(element => {
      if (element.isDeleted) return false;
      
      const [elX1, elY1, elX2, elY2] = getElementAbsoluteCoords(element);
      
      // 检查是否相交
      return !(elX2 < areaX1 || elX1 > areaX2 || elY2 < areaY1 || elY1 > areaY2);
    });
  }
  
  private updateScene(): void {
    const elements = Array.from(this.elements.values());
    this.scene.replaceAllElements(elements);
  }
  
  private calculateNewFractionalIndex(elements: ExcalidrawElement[], targetIndex: number): FractionalIndex {
    // 简化的分数索引计算
    // 实际实现会使用更复杂的分数索引算法
    return `${targetIndex}` as FractionalIndex;
  }
}

// 使用示例
const scene = new Scene();
const history = new History();
const elementManager = new ElementManager(scene, history);

// 创建矩形
const rect = elementManager.createElement('rectangle', {
  x: 100,
  y: 100,
  width: 200,
  height: 150,
  strokeColor: '#000000',
  backgroundColor: '#ff0000',
});

// 创建文本
const text = elementManager.createElement('text', {
  x: 150,
  y: 200,
  text: 'Hello Excalidraw!',
  fontSize: 24,
  fontFamily: 1,
});

// 群组元素
const groupId = elementManager.groupElements([rect.id, text.id]);

// 复制群组
elementManager.duplicateElement(rect.id);
```

通过深入分析真实的Excalidraw源码，我们看到了一个成熟的元素系统是如何设计的：类型安全的元素定义、高效的变更机制、精确的边界计算、以及灵活的渲染分发。这些设计模式为构建复杂的图形编辑器提供了强有力的基础。