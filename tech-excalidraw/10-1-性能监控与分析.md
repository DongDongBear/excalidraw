# 第十章第一节：性能监控与分析

## 10.1.1 性能监控的重要性

在 Excalidraw 这样的图形编辑器中，性能直接影响用户体验。流畅的绘制、快速的响应和稳定的帧率是用户满意度的关键指标。

### 性能监控的目标

```typescript
interface PerformanceMetrics {
  // 渲染性能
  frameRate: number;           // 帧率 (FPS)
  renderTime: number;          // 渲染耗时 (ms)
  drawCallCount: number;       // 绘制调用次数
  
  // 内存使用
  memoryUsage: number;         // 内存占用 (MB)
  canvasMemory: number;        // Canvas内存占用
  elementCount: number;        // 元素数量
  
  // 交互响应
  inputLatency: number;        // 输入延迟 (ms)
  scrollPerformance: number;   // 滚动流畅度
  toolSwitchTime: number;      // 工具切换耗时
  
  // 网络性能（协作模式）
  networkLatency: number;      // 网络延迟
  syncTime: number;           // 同步耗时
  operationQueueSize: number; // 操作队列长度
}
```

## 10.1.2 基础性能监控器

```typescript
class PerformanceMonitor {
  private metrics: PerformanceMetrics;
  private observers: PerformanceObserver[] = [];
  private rafCallback: number | null = null;
  private isMonitoring = false;
  
  // 历史数据存储
  private history: Array<{
    timestamp: number;
    metrics: PerformanceMetrics;
  }> = [];
  
  constructor() {
    this.metrics = this.initializeMetrics();
    this.setupPerformanceObservers();
  }
  
  // 开始监控
  startMonitoring(): void {
    if (this.isMonitoring) return;
    
    this.isMonitoring = true;
    this.startFrameRateMonitoring();
    this.startMemoryMonitoring();
    this.startInputLatencyMonitoring();
    
    console.log('Performance monitoring started');
  }
  
  // 停止监控
  stopMonitoring(): void {
    if (!this.isMonitoring) return;
    
    this.isMonitoring = false;
    
    if (this.rafCallback) {
      cancelAnimationFrame(this.rafCallback);
      this.rafCallback = null;
    }
    
    this.observers.forEach(observer => observer.disconnect());
    this.observers = [];
    
    console.log('Performance monitoring stopped');
  }
  
  // 获取当前性能指标
  getCurrentMetrics(): PerformanceMetrics {
    return { ...this.metrics };
  }
  
  // 获取性能历史
  getPerformanceHistory(timeRange?: number): Array<{
    timestamp: number;
    metrics: PerformanceMetrics;
  }> {
    if (!timeRange) {
      return [...this.history];
    }
    
    const cutoff = Date.now() - timeRange;
    return this.history.filter(entry => entry.timestamp >= cutoff);
  }
  
  private initializeMetrics(): PerformanceMetrics {
    return {
      frameRate: 0,
      renderTime: 0,
      drawCallCount: 0,
      memoryUsage: 0,
      canvasMemory: 0,
      elementCount: 0,
      inputLatency: 0,
      scrollPerformance: 0,
      toolSwitchTime: 0,
      networkLatency: 0,
      syncTime: 0,
      operationQueueSize: 0
    };
  }
  
  private setupPerformanceObservers(): void {
    // 监控长任务
    if ('PerformanceObserver' in window) {
      const longTaskObserver = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.duration > 50) { // 超过50ms的任务
            console.warn(`Long task detected: ${entry.duration}ms`);
            this.recordLongTask(entry);
          }
        }
      });
      
      try {
        longTaskObserver.observe({ entryTypes: ['longtask'] });
        this.observers.push(longTaskObserver);
      } catch (e) {
        console.log('Long task observer not supported');
      }
    }
    
    // 监控导航时间
    if ('PerformanceObserver' in window) {
      const navigationObserver = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          this.recordNavigationTiming(entry as PerformanceNavigationTiming);
        }
      });
      
      try {
        navigationObserver.observe({ entryTypes: ['navigation'] });
        this.observers.push(navigationObserver);
      } catch (e) {
        console.log('Navigation observer not supported');
      }
    }
  }
  
  // 帧率监控
  private startFrameRateMonitoring(): void {
    let frameCount = 0;
    let lastTime = performance.now();
    let frameStartTime = performance.now();
    
    const measureFrame = (currentTime: number) => {
      if (!this.isMonitoring) return;
      
      frameCount++;
      const frameTime = currentTime - frameStartTime;
      
      // 更新帧时间
      this.metrics.renderTime = frameTime;
      
      // 每秒计算一次帧率
      if (currentTime - lastTime >= 1000) {
        this.metrics.frameRate = frameCount;
        frameCount = 0;
        lastTime = currentTime;
        
        // 记录历史数据
        this.recordMetrics();
      }
      
      frameStartTime = currentTime;
      this.rafCallback = requestAnimationFrame(measureFrame);
    };
    
    this.rafCallback = requestAnimationFrame(measureFrame);
  }
  
  // 内存监控
  private startMemoryMonitoring(): void {
    const measureMemory = () => {
      if (!this.isMonitoring) return;
      
      // 浏览器内存API
      if ('memory' in performance) {
        const memInfo = (performance as any).memory;
        this.metrics.memoryUsage = memInfo.usedJSHeapSize / (1024 * 1024); // MB
      }
      
      // 定期测量
      setTimeout(measureMemory, 5000); // 每5秒测量一次
    };
    
    measureMemory();
  }
  
  // 输入延迟监控
  private startInputLatencyMonitoring(): void {
    let inputStartTime: number;
    
    // 监听指针事件
    const handlePointerDown = () => {
      inputStartTime = performance.now();
    };
    
    const handlePointerMove = () => {
      if (inputStartTime) {
        const latency = performance.now() - inputStartTime;
        this.metrics.inputLatency = latency;
      }
    };
    
    document.addEventListener('pointerdown', handlePointerDown);
    document.addEventListener('pointermove', handlePointerMove);
    
    // 清理函数会在停止监控时调用
    this.observers.push({
      disconnect: () => {
        document.removeEventListener('pointerdown', handlePointerDown);
        document.removeEventListener('pointermove', handlePointerMove);
      }
    } as any);
  }
  
  // 记录长任务
  private recordLongTask(entry: PerformanceEntry): void {
    // 可以发送到分析服务
    console.log('Long task:', {
      duration: entry.duration,
      startTime: entry.startTime,
      name: entry.name
    });
  }
  
  // 记录导航时间
  private recordNavigationTiming(timing: PerformanceNavigationTiming): void {
    const metrics = {
      domContentLoaded: timing.domContentLoadedEventEnd - timing.domContentLoadedEventStart,
      loadComplete: timing.loadEventEnd - timing.loadEventStart,
      domInteractive: timing.domInteractive - timing.navigationStart,
      firstPaint: this.getFirstPaintTime(),
      firstContentfulPaint: this.getFirstContentfulPaintTime()
    };
    
    console.log('Navigation timing:', metrics);
  }
  
  // 记录当前指标到历史
  private recordMetrics(): void {
    this.history.push({
      timestamp: Date.now(),
      metrics: { ...this.metrics }
    });
    
    // 限制历史数据大小
    if (this.history.length > 1000) {
      this.history = this.history.slice(-800);
    }
  }
  
  // 获取首次绘制时间
  private getFirstPaintTime(): number {
    const paintEntries = performance.getEntriesByType('paint');
    const fpEntry = paintEntries.find(entry => entry.name === 'first-paint');
    return fpEntry ? fpEntry.startTime : 0;
  }
  
  // 获取首次内容绘制时间
  private getFirstContentfulPaintTime(): number {
    const paintEntries = performance.getEntriesByType('paint');
    const fcpEntry = paintEntries.find(entry => entry.name === 'first-contentful-paint');
    return fcpEntry ? fcpEntry.startTime : 0;
  }
}
```

## 10.1.3 Canvas特定性能监控

```typescript
class CanvasPerformanceMonitor {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  private drawCallCount = 0;
  private lastDrawCallReset = Date.now();
  
  constructor(canvas: HTMLCanvasElement) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d')!;
    this.wrapCanvasAPIs();
  }
  
  // 包装Canvas API来监控调用
  private wrapCanvasAPIs(): void {
    const originalMethods = {
      fillRect: this.ctx.fillRect,
      strokeRect: this.ctx.strokeRect,
      fillText: this.ctx.fillText,
      strokeText: this.ctx.strokeText,
      drawImage: this.ctx.drawImage,
      fill: this.ctx.fill,
      stroke: this.ctx.stroke
    };
    
    // 包装绘制方法
    this.ctx.fillRect = (...args) => {
      this.recordDrawCall('fillRect');
      return originalMethods.fillRect.apply(this.ctx, args);
    };
    
    this.ctx.strokeRect = (...args) => {
      this.recordDrawCall('strokeRect');
      return originalMethods.strokeRect.apply(this.ctx, args);
    };
    
    this.ctx.fillText = (...args) => {
      this.recordDrawCall('fillText');
      return originalMethods.fillText.apply(this.ctx, args);
    };
    
    this.ctx.strokeText = (...args) => {
      this.recordDrawCall('strokeText');
      return originalMethods.strokeText.apply(this.ctx, args);
    };
    
    this.ctx.drawImage = (...args) => {
      this.recordDrawCall('drawImage');
      return originalMethods.drawImage.apply(this.ctx, args as any);
    };
    
    this.ctx.fill = (...args) => {
      this.recordDrawCall('fill');
      return originalMethods.fill.apply(this.ctx, args as any);
    };
    
    this.ctx.stroke = (...args) => {
      this.recordDrawCall('stroke');
      return originalMethods.stroke.apply(this.ctx, args);
    };
  }
  
  // 记录绘制调用
  private recordDrawCall(method: string): void {
    this.drawCallCount++;
    
    // 每秒重置计数器
    const now = Date.now();
    if (now - this.lastDrawCallReset >= 1000) {
      console.log(`Draw calls in last second: ${this.drawCallCount}`);
      this.drawCallCount = 0;
      this.lastDrawCallReset = now;
    }
  }
  
  // 测量渲染时间
  measureRenderTime<T>(renderFunction: () => T): { result: T; time: number } {
    const startTime = performance.now();
    const result = renderFunction();
    const endTime = performance.now();
    
    return {
      result,
      time: endTime - startTime
    };
  }
  
  // 获取Canvas内存使用估算
  getCanvasMemoryUsage(): number {
    const { width, height } = this.canvas;
    // Canvas使用RGBA，每像素4字节
    const pixelMemory = width * height * 4;
    
    // 转换为MB
    return pixelMemory / (1024 * 1024);
  }
  
  // 获取当前绘制调用数
  getCurrentDrawCallCount(): number {
    return this.drawCallCount;
  }
}
```

## 10.1.4 实时性能仪表盘

```typescript
interface PerformanceDashboardProps {
  monitor: PerformanceMonitor;
  canvasMonitor?: CanvasPerformanceMonitor;
}

const PerformanceDashboard: React.FC<PerformanceDashboardProps> = ({
  monitor,
  canvasMonitor
}) => {
  const [metrics, setMetrics] = useState<PerformanceMetrics | null>(null);
  const [isVisible, setIsVisible] = useState(false);
  
  useEffect(() => {
    if (!isVisible) return;
    
    const updateMetrics = () => {
      const currentMetrics = monitor.getCurrentMetrics();
      
      if (canvasMonitor) {
        currentMetrics.drawCallCount = canvasMonitor.getCurrentDrawCallCount();
        currentMetrics.canvasMemory = canvasMonitor.getCanvasMemoryUsage();
      }
      
      setMetrics(currentMetrics);
    };
    
    // 每秒更新指标
    const interval = setInterval(updateMetrics, 1000);
    updateMetrics(); // 立即更新一次
    
    return () => clearInterval(interval);
  }, [isVisible, monitor, canvasMonitor]);
  
  if (!isVisible) {
    return (
      <button 
        className="performance-toggle"
        onClick={() => setIsVisible(true)}
      >
        📊
      </button>
    );
  }
  
  return (
    <div className="performance-dashboard">
      <div className="dashboard-header">
        <h3>Performance Monitor</h3>
        <button onClick={() => setIsVisible(false)}>×</button>
      </div>
      
      {metrics && (
        <div className="metrics-grid">
          <MetricCard
            title="Frame Rate"
            value={metrics.frameRate}
            unit="FPS"
            status={getFrameRateStatus(metrics.frameRate)}
          />
          
          <MetricCard
            title="Render Time"
            value={metrics.renderTime.toFixed(2)}
            unit="ms"
            status={getRenderTimeStatus(metrics.renderTime)}
          />
          
          <MetricCard
            title="Memory Usage"
            value={metrics.memoryUsage.toFixed(1)}
            unit="MB"
            status={getMemoryStatus(metrics.memoryUsage)}
          />
          
          <MetricCard
            title="Draw Calls"
            value={metrics.drawCallCount}
            unit="/sec"
            status={getDrawCallStatus(metrics.drawCallCount)}
          />
          
          <MetricCard
            title="Input Latency"
            value={metrics.inputLatency.toFixed(1)}
            unit="ms"
            status={getLatencyStatus(metrics.inputLatency)}
          />
          
          <MetricCard
            title="Elements"
            value={metrics.elementCount}
            unit=""
            status="neutral"
          />
        </div>
      )}
      
      <div className="dashboard-controls">
        <button onClick={() => monitor.startMonitoring()}>
          Start Monitoring
        </button>
        <button onClick={() => monitor.stopMonitoring()}>
          Stop Monitoring
        </button>
        <button onClick={() => exportPerformanceData(monitor)}>
          Export Data
        </button>
      </div>
    </div>
  );
};

const MetricCard: React.FC<{
  title: string;
  value: string | number;
  unit: string;
  status: 'good' | 'warning' | 'critical' | 'neutral';
}> = ({ title, value, unit, status }) => {
  return (
    <div className={`metric-card ${status}`}>
      <div className="metric-title">{title}</div>
      <div className="metric-value">
        {value} <span className="metric-unit">{unit}</span>
      </div>
    </div>
  );
};

// 性能状态判断函数
function getFrameRateStatus(fps: number): 'good' | 'warning' | 'critical' {
  if (fps >= 55) return 'good';
  if (fps >= 30) return 'warning';
  return 'critical';
}

function getRenderTimeStatus(time: number): 'good' | 'warning' | 'critical' {
  if (time <= 16) return 'good';  // 60 FPS
  if (time <= 33) return 'warning'; // 30 FPS
  return 'critical';
}

function getMemoryStatus(memory: number): 'good' | 'warning' | 'critical' {
  if (memory <= 50) return 'good';
  if (memory <= 100) return 'warning';
  return 'critical';
}

function getDrawCallStatus(calls: number): 'good' | 'warning' | 'critical' {
  if (calls <= 100) return 'good';
  if (calls <= 500) return 'warning';
  return 'critical';
}

function getLatencyStatus(latency: number): 'good' | 'warning' | 'critical' {
  if (latency <= 16) return 'good';
  if (latency <= 50) return 'warning';
  return 'critical';
}

// 导出性能数据
function exportPerformanceData(monitor: PerformanceMonitor): void {
  const history = monitor.getPerformanceHistory();
  const data = JSON.stringify(history, null, 2);
  
  const blob = new Blob([data], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = `performance-data-${Date.now()}.json`;
  a.click();
  
  URL.revokeObjectURL(url);
}
```

这是第10章第1节的内容，专注于性能监控与分析的基础部分。接下来我会继续创建后续的小节。