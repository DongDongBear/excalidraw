# ç¬¬åç« ç¬¬ä¸€èŠ‚ï¼šæ€§èƒ½ç›‘æ§ä¸åˆ†æ

## 10.1.1 æ€§èƒ½ç›‘æ§çš„é‡è¦æ€§

åœ¨ Excalidraw è¿™æ ·çš„å›¾å½¢ç¼–è¾‘å™¨ä¸­ï¼Œæ€§èƒ½ç›´æ¥å½±å“ç”¨æˆ·ä½“éªŒã€‚æµç•…çš„ç»˜åˆ¶ã€å¿«é€Ÿçš„å“åº”å’Œç¨³å®šçš„å¸§ç‡æ˜¯ç”¨æˆ·æ»¡æ„åº¦çš„å…³é”®æŒ‡æ ‡ã€‚

### æ€§èƒ½ç›‘æ§çš„ç›®æ ‡

```typescript
interface PerformanceMetrics {
  // æ¸²æŸ“æ€§èƒ½
  frameRate: number;           // å¸§ç‡ (FPS)
  renderTime: number;          // æ¸²æŸ“è€—æ—¶ (ms)
  drawCallCount: number;       // ç»˜åˆ¶è°ƒç”¨æ¬¡æ•°
  
  // å†…å­˜ä½¿ç”¨
  memoryUsage: number;         // å†…å­˜å ç”¨ (MB)
  canvasMemory: number;        // Canvaså†…å­˜å ç”¨
  elementCount: number;        // å…ƒç´ æ•°é‡
  
  // äº¤äº’å“åº”
  inputLatency: number;        // è¾“å…¥å»¶è¿Ÿ (ms)
  scrollPerformance: number;   // æ»šåŠ¨æµç•…åº¦
  toolSwitchTime: number;      // å·¥å…·åˆ‡æ¢è€—æ—¶
  
  // ç½‘ç»œæ€§èƒ½ï¼ˆåä½œæ¨¡å¼ï¼‰
  networkLatency: number;      // ç½‘ç»œå»¶è¿Ÿ
  syncTime: number;           // åŒæ­¥è€—æ—¶
  operationQueueSize: number; // æ“ä½œé˜Ÿåˆ—é•¿åº¦
}
```

## 10.1.2 åŸºç¡€æ€§èƒ½ç›‘æ§å™¨

```typescript
class PerformanceMonitor {
  private metrics: PerformanceMetrics;
  private observers: PerformanceObserver[] = [];
  private rafCallback: number | null = null;
  private isMonitoring = false;
  
  // å†å²æ•°æ®å­˜å‚¨
  private history: Array<{
    timestamp: number;
    metrics: PerformanceMetrics;
  }> = [];
  
  constructor() {
    this.metrics = this.initializeMetrics();
    this.setupPerformanceObservers();
  }
  
  // å¼€å§‹ç›‘æ§
  startMonitoring(): void {
    if (this.isMonitoring) return;
    
    this.isMonitoring = true;
    this.startFrameRateMonitoring();
    this.startMemoryMonitoring();
    this.startInputLatencyMonitoring();
    
    console.log('Performance monitoring started');
  }
  
  // åœæ­¢ç›‘æ§
  stopMonitoring(): void {
    if (!this.isMonitoring) return;
    
    this.isMonitoring = false;
    
    if (this.rafCallback) {
      cancelAnimationFrame(this.rafCallback);
      this.rafCallback = null;
    }
    
    this.observers.forEach(observer => observer.disconnect());
    this.observers = [];
    
    console.log('Performance monitoring stopped');
  }
  
  // è·å–å½“å‰æ€§èƒ½æŒ‡æ ‡
  getCurrentMetrics(): PerformanceMetrics {
    return { ...this.metrics };
  }
  
  // è·å–æ€§èƒ½å†å²
  getPerformanceHistory(timeRange?: number): Array<{
    timestamp: number;
    metrics: PerformanceMetrics;
  }> {
    if (!timeRange) {
      return [...this.history];
    }
    
    const cutoff = Date.now() - timeRange;
    return this.history.filter(entry => entry.timestamp >= cutoff);
  }
  
  private initializeMetrics(): PerformanceMetrics {
    return {
      frameRate: 0,
      renderTime: 0,
      drawCallCount: 0,
      memoryUsage: 0,
      canvasMemory: 0,
      elementCount: 0,
      inputLatency: 0,
      scrollPerformance: 0,
      toolSwitchTime: 0,
      networkLatency: 0,
      syncTime: 0,
      operationQueueSize: 0
    };
  }
  
  private setupPerformanceObservers(): void {
    // ç›‘æ§é•¿ä»»åŠ¡
    if ('PerformanceObserver' in window) {
      const longTaskObserver = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.duration > 50) { // è¶…è¿‡50msçš„ä»»åŠ¡
            console.warn(`Long task detected: ${entry.duration}ms`);
            this.recordLongTask(entry);
          }
        }
      });
      
      try {
        longTaskObserver.observe({ entryTypes: ['longtask'] });
        this.observers.push(longTaskObserver);
      } catch (e) {
        console.log('Long task observer not supported');
      }
    }
    
    // ç›‘æ§å¯¼èˆªæ—¶é—´
    if ('PerformanceObserver' in window) {
      const navigationObserver = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          this.recordNavigationTiming(entry as PerformanceNavigationTiming);
        }
      });
      
      try {
        navigationObserver.observe({ entryTypes: ['navigation'] });
        this.observers.push(navigationObserver);
      } catch (e) {
        console.log('Navigation observer not supported');
      }
    }
  }
  
  // å¸§ç‡ç›‘æ§
  private startFrameRateMonitoring(): void {
    let frameCount = 0;
    let lastTime = performance.now();
    let frameStartTime = performance.now();
    
    const measureFrame = (currentTime: number) => {
      if (!this.isMonitoring) return;
      
      frameCount++;
      const frameTime = currentTime - frameStartTime;
      
      // æ›´æ–°å¸§æ—¶é—´
      this.metrics.renderTime = frameTime;
      
      // æ¯ç§’è®¡ç®—ä¸€æ¬¡å¸§ç‡
      if (currentTime - lastTime >= 1000) {
        this.metrics.frameRate = frameCount;
        frameCount = 0;
        lastTime = currentTime;
        
        // è®°å½•å†å²æ•°æ®
        this.recordMetrics();
      }
      
      frameStartTime = currentTime;
      this.rafCallback = requestAnimationFrame(measureFrame);
    };
    
    this.rafCallback = requestAnimationFrame(measureFrame);
  }
  
  // å†…å­˜ç›‘æ§
  private startMemoryMonitoring(): void {
    const measureMemory = () => {
      if (!this.isMonitoring) return;
      
      // æµè§ˆå™¨å†…å­˜API
      if ('memory' in performance) {
        const memInfo = (performance as any).memory;
        this.metrics.memoryUsage = memInfo.usedJSHeapSize / (1024 * 1024); // MB
      }
      
      // å®šæœŸæµ‹é‡
      setTimeout(measureMemory, 5000); // æ¯5ç§’æµ‹é‡ä¸€æ¬¡
    };
    
    measureMemory();
  }
  
  // è¾“å…¥å»¶è¿Ÿç›‘æ§
  private startInputLatencyMonitoring(): void {
    let inputStartTime: number;
    
    // ç›‘å¬æŒ‡é’ˆäº‹ä»¶
    const handlePointerDown = () => {
      inputStartTime = performance.now();
    };
    
    const handlePointerMove = () => {
      if (inputStartTime) {
        const latency = performance.now() - inputStartTime;
        this.metrics.inputLatency = latency;
      }
    };
    
    document.addEventListener('pointerdown', handlePointerDown);
    document.addEventListener('pointermove', handlePointerMove);
    
    // æ¸…ç†å‡½æ•°ä¼šåœ¨åœæ­¢ç›‘æ§æ—¶è°ƒç”¨
    this.observers.push({
      disconnect: () => {
        document.removeEventListener('pointerdown', handlePointerDown);
        document.removeEventListener('pointermove', handlePointerMove);
      }
    } as any);
  }
  
  // è®°å½•é•¿ä»»åŠ¡
  private recordLongTask(entry: PerformanceEntry): void {
    // å¯ä»¥å‘é€åˆ°åˆ†ææœåŠ¡
    console.log('Long task:', {
      duration: entry.duration,
      startTime: entry.startTime,
      name: entry.name
    });
  }
  
  // è®°å½•å¯¼èˆªæ—¶é—´
  private recordNavigationTiming(timing: PerformanceNavigationTiming): void {
    const metrics = {
      domContentLoaded: timing.domContentLoadedEventEnd - timing.domContentLoadedEventStart,
      loadComplete: timing.loadEventEnd - timing.loadEventStart,
      domInteractive: timing.domInteractive - timing.navigationStart,
      firstPaint: this.getFirstPaintTime(),
      firstContentfulPaint: this.getFirstContentfulPaintTime()
    };
    
    console.log('Navigation timing:', metrics);
  }
  
  // è®°å½•å½“å‰æŒ‡æ ‡åˆ°å†å²
  private recordMetrics(): void {
    this.history.push({
      timestamp: Date.now(),
      metrics: { ...this.metrics }
    });
    
    // é™åˆ¶å†å²æ•°æ®å¤§å°
    if (this.history.length > 1000) {
      this.history = this.history.slice(-800);
    }
  }
  
  // è·å–é¦–æ¬¡ç»˜åˆ¶æ—¶é—´
  private getFirstPaintTime(): number {
    const paintEntries = performance.getEntriesByType('paint');
    const fpEntry = paintEntries.find(entry => entry.name === 'first-paint');
    return fpEntry ? fpEntry.startTime : 0;
  }
  
  // è·å–é¦–æ¬¡å†…å®¹ç»˜åˆ¶æ—¶é—´
  private getFirstContentfulPaintTime(): number {
    const paintEntries = performance.getEntriesByType('paint');
    const fcpEntry = paintEntries.find(entry => entry.name === 'first-contentful-paint');
    return fcpEntry ? fcpEntry.startTime : 0;
  }
}
```

## 10.1.3 Canvasç‰¹å®šæ€§èƒ½ç›‘æ§

```typescript
class CanvasPerformanceMonitor {
  private canvas: HTMLCanvasElement;
  private ctx: CanvasRenderingContext2D;
  private drawCallCount = 0;
  private lastDrawCallReset = Date.now();
  
  constructor(canvas: HTMLCanvasElement) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d')!;
    this.wrapCanvasAPIs();
  }
  
  // åŒ…è£…Canvas APIæ¥ç›‘æ§è°ƒç”¨
  private wrapCanvasAPIs(): void {
    const originalMethods = {
      fillRect: this.ctx.fillRect,
      strokeRect: this.ctx.strokeRect,
      fillText: this.ctx.fillText,
      strokeText: this.ctx.strokeText,
      drawImage: this.ctx.drawImage,
      fill: this.ctx.fill,
      stroke: this.ctx.stroke
    };
    
    // åŒ…è£…ç»˜åˆ¶æ–¹æ³•
    this.ctx.fillRect = (...args) => {
      this.recordDrawCall('fillRect');
      return originalMethods.fillRect.apply(this.ctx, args);
    };
    
    this.ctx.strokeRect = (...args) => {
      this.recordDrawCall('strokeRect');
      return originalMethods.strokeRect.apply(this.ctx, args);
    };
    
    this.ctx.fillText = (...args) => {
      this.recordDrawCall('fillText');
      return originalMethods.fillText.apply(this.ctx, args);
    };
    
    this.ctx.strokeText = (...args) => {
      this.recordDrawCall('strokeText');
      return originalMethods.strokeText.apply(this.ctx, args);
    };
    
    this.ctx.drawImage = (...args) => {
      this.recordDrawCall('drawImage');
      return originalMethods.drawImage.apply(this.ctx, args as any);
    };
    
    this.ctx.fill = (...args) => {
      this.recordDrawCall('fill');
      return originalMethods.fill.apply(this.ctx, args as any);
    };
    
    this.ctx.stroke = (...args) => {
      this.recordDrawCall('stroke');
      return originalMethods.stroke.apply(this.ctx, args);
    };
  }
  
  // è®°å½•ç»˜åˆ¶è°ƒç”¨
  private recordDrawCall(method: string): void {
    this.drawCallCount++;
    
    // æ¯ç§’é‡ç½®è®¡æ•°å™¨
    const now = Date.now();
    if (now - this.lastDrawCallReset >= 1000) {
      console.log(`Draw calls in last second: ${this.drawCallCount}`);
      this.drawCallCount = 0;
      this.lastDrawCallReset = now;
    }
  }
  
  // æµ‹é‡æ¸²æŸ“æ—¶é—´
  measureRenderTime<T>(renderFunction: () => T): { result: T; time: number } {
    const startTime = performance.now();
    const result = renderFunction();
    const endTime = performance.now();
    
    return {
      result,
      time: endTime - startTime
    };
  }
  
  // è·å–Canvaså†…å­˜ä½¿ç”¨ä¼°ç®—
  getCanvasMemoryUsage(): number {
    const { width, height } = this.canvas;
    // Canvasä½¿ç”¨RGBAï¼Œæ¯åƒç´ 4å­—èŠ‚
    const pixelMemory = width * height * 4;
    
    // è½¬æ¢ä¸ºMB
    return pixelMemory / (1024 * 1024);
  }
  
  // è·å–å½“å‰ç»˜åˆ¶è°ƒç”¨æ•°
  getCurrentDrawCallCount(): number {
    return this.drawCallCount;
  }
}
```

## 10.1.4 å®æ—¶æ€§èƒ½ä»ªè¡¨ç›˜

```typescript
interface PerformanceDashboardProps {
  monitor: PerformanceMonitor;
  canvasMonitor?: CanvasPerformanceMonitor;
}

const PerformanceDashboard: React.FC<PerformanceDashboardProps> = ({
  monitor,
  canvasMonitor
}) => {
  const [metrics, setMetrics] = useState<PerformanceMetrics | null>(null);
  const [isVisible, setIsVisible] = useState(false);
  
  useEffect(() => {
    if (!isVisible) return;
    
    const updateMetrics = () => {
      const currentMetrics = monitor.getCurrentMetrics();
      
      if (canvasMonitor) {
        currentMetrics.drawCallCount = canvasMonitor.getCurrentDrawCallCount();
        currentMetrics.canvasMemory = canvasMonitor.getCanvasMemoryUsage();
      }
      
      setMetrics(currentMetrics);
    };
    
    // æ¯ç§’æ›´æ–°æŒ‡æ ‡
    const interval = setInterval(updateMetrics, 1000);
    updateMetrics(); // ç«‹å³æ›´æ–°ä¸€æ¬¡
    
    return () => clearInterval(interval);
  }, [isVisible, monitor, canvasMonitor]);
  
  if (!isVisible) {
    return (
      <button 
        className="performance-toggle"
        onClick={() => setIsVisible(true)}
      >
        ğŸ“Š
      </button>
    );
  }
  
  return (
    <div className="performance-dashboard">
      <div className="dashboard-header">
        <h3>Performance Monitor</h3>
        <button onClick={() => setIsVisible(false)}>Ã—</button>
      </div>
      
      {metrics && (
        <div className="metrics-grid">
          <MetricCard
            title="Frame Rate"
            value={metrics.frameRate}
            unit="FPS"
            status={getFrameRateStatus(metrics.frameRate)}
          />
          
          <MetricCard
            title="Render Time"
            value={metrics.renderTime.toFixed(2)}
            unit="ms"
            status={getRenderTimeStatus(metrics.renderTime)}
          />
          
          <MetricCard
            title="Memory Usage"
            value={metrics.memoryUsage.toFixed(1)}
            unit="MB"
            status={getMemoryStatus(metrics.memoryUsage)}
          />
          
          <MetricCard
            title="Draw Calls"
            value={metrics.drawCallCount}
            unit="/sec"
            status={getDrawCallStatus(metrics.drawCallCount)}
          />
          
          <MetricCard
            title="Input Latency"
            value={metrics.inputLatency.toFixed(1)}
            unit="ms"
            status={getLatencyStatus(metrics.inputLatency)}
          />
          
          <MetricCard
            title="Elements"
            value={metrics.elementCount}
            unit=""
            status="neutral"
          />
        </div>
      )}
      
      <div className="dashboard-controls">
        <button onClick={() => monitor.startMonitoring()}>
          Start Monitoring
        </button>
        <button onClick={() => monitor.stopMonitoring()}>
          Stop Monitoring
        </button>
        <button onClick={() => exportPerformanceData(monitor)}>
          Export Data
        </button>
      </div>
    </div>
  );
};

const MetricCard: React.FC<{
  title: string;
  value: string | number;
  unit: string;
  status: 'good' | 'warning' | 'critical' | 'neutral';
}> = ({ title, value, unit, status }) => {
  return (
    <div className={`metric-card ${status}`}>
      <div className="metric-title">{title}</div>
      <div className="metric-value">
        {value} <span className="metric-unit">{unit}</span>
      </div>
    </div>
  );
};

// æ€§èƒ½çŠ¶æ€åˆ¤æ–­å‡½æ•°
function getFrameRateStatus(fps: number): 'good' | 'warning' | 'critical' {
  if (fps >= 55) return 'good';
  if (fps >= 30) return 'warning';
  return 'critical';
}

function getRenderTimeStatus(time: number): 'good' | 'warning' | 'critical' {
  if (time <= 16) return 'good';  // 60 FPS
  if (time <= 33) return 'warning'; // 30 FPS
  return 'critical';
}

function getMemoryStatus(memory: number): 'good' | 'warning' | 'critical' {
  if (memory <= 50) return 'good';
  if (memory <= 100) return 'warning';
  return 'critical';
}

function getDrawCallStatus(calls: number): 'good' | 'warning' | 'critical' {
  if (calls <= 100) return 'good';
  if (calls <= 500) return 'warning';
  return 'critical';
}

function getLatencyStatus(latency: number): 'good' | 'warning' | 'critical' {
  if (latency <= 16) return 'good';
  if (latency <= 50) return 'warning';
  return 'critical';
}

// å¯¼å‡ºæ€§èƒ½æ•°æ®
function exportPerformanceData(monitor: PerformanceMonitor): void {
  const history = monitor.getPerformanceHistory();
  const data = JSON.stringify(history, null, 2);
  
  const blob = new Blob([data], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = `performance-data-${Date.now()}.json`;
  a.click();
  
  URL.revokeObjectURL(url);
}
```

è¿™æ˜¯ç¬¬10ç« ç¬¬1èŠ‚çš„å†…å®¹ï¼Œä¸“æ³¨äºæ€§èƒ½ç›‘æ§ä¸åˆ†æçš„åŸºç¡€éƒ¨åˆ†ã€‚æ¥ä¸‹æ¥æˆ‘ä¼šç»§ç»­åˆ›å»ºåç»­çš„å°èŠ‚ã€‚