# 第十章第四节：视口优化与虚拟化

## 10.4.1 视口裁剪系统

视口裁剪确保只渲染用户可见区域内的元素，大幅提升大型画布的性能。

### 视口管理器

```typescript
interface Viewport {
  x: number;
  y: number;
  width: number;
  height: number;
  zoom: number;
}

interface ViewportBounds {
  minX: number;
  minY: number;
  maxX: number;
  maxY: number;
}

class ViewportManager {
  private viewport: Viewport;
  private canvas: HTMLCanvasElement;
  private onViewportChange: ((viewport: Viewport) => void)[] = [];
  
  // 视口变化的缓存，避免频繁触发回调
  private lastNotifiedViewport: Viewport;
  private notificationThreshold = 10; // 像素阈值
  
  constructor(canvas: HTMLCanvasElement) {
    this.canvas = canvas;
    this.viewport = {
      x: 0,
      y: 0,
      width: canvas.width,
      height: canvas.height,
      zoom: 1
    };
    this.lastNotifiedViewport = { ...this.viewport };
  }
  
  // 更新视口位置
  updateViewport(x: number, y: number, zoom?: number): void {
    const oldViewport = { ...this.viewport };
    
    this.viewport.x = x;
    this.viewport.y = y;
    
    if (zoom !== undefined) {
      this.viewport.zoom = Math.max(0.1, Math.min(10, zoom));
    }
    
    // 检查是否需要通知变化
    if (this.shouldNotifyViewportChange()) {
      this.notifyViewportChange();
      this.lastNotifiedViewport = { ...this.viewport };
    }
  }
  
  // 获取当前视口
  getViewport(): Viewport {
    return { ...this.viewport };
  }
  
  // 获取视口边界（世界坐标）
  getViewportBounds(): ViewportBounds {
    const { x, y, width, height, zoom } = this.viewport;
    
    // 考虑缩放的实际视口大小
    const actualWidth = width / zoom;
    const actualHeight = height / zoom;
    
    return {
      minX: x - actualWidth * 0.1, // 10%的缓冲区
      minY: y - actualHeight * 0.1,
      maxX: x + actualWidth * 1.1,
      maxY: y + actualHeight * 1.1
    };
  }
  
  // 检查元素是否在视口内
  isElementVisible(element: ExcalidrawElement): boolean {
    const elementBounds = getElementBounds(element);
    const viewportBounds = this.getViewportBounds();
    
    return this.boundsIntersect(elementBounds, viewportBounds);
  }
  
  // 检查矩形是否在视口内
  isRectVisible(rect: DirtyRect): boolean {
    const viewportBounds = this.getViewportBounds();
    
    return this.boundsIntersect(rect, viewportBounds);
  }
  
  // 获取视口内的元素
  getVisibleElements(elements: ExcalidrawElement[]): ExcalidrawElement[] {
    const viewportBounds = this.getViewportBounds();
    
    return elements.filter(element => {
      const elementBounds = getElementBounds(element);
      return this.boundsIntersect(elementBounds, viewportBounds);
    });
  }
  
  // 计算元素与视口的交集
  getElementViewportIntersection(element: ExcalidrawElement): DirtyRect | null {
    const elementBounds = getElementBounds(element);
    const viewportBounds = this.getViewportBounds();
    
    const intersection = this.calculateIntersection(elementBounds, viewportBounds);
    return intersection;
  }
  
  // 世界坐标转屏幕坐标
  worldToScreen(worldX: number, worldY: number): { x: number; y: number } {
    const { x: viewX, y: viewY, zoom } = this.viewport;
    
    return {
      x: (worldX - viewX) * zoom,
      y: (worldY - viewY) * zoom
    };
  }
  
  // 屏幕坐标转世界坐标
  screenToWorld(screenX: number, screenY: number): { x: number; y: number } {
    const { x: viewX, y: viewY, zoom } = this.viewport;
    
    return {
      x: screenX / zoom + viewX,
      y: screenY / zoom + viewY
    };
  }
  
  // 注册视口变化监听器
  onViewportChanged(callback: (viewport: Viewport) => void): void {
    this.onViewportChange.push(callback);
  }
  
  private shouldNotifyViewportChange(): boolean {
    const { x, y, zoom } = this.viewport;
    const { x: lastX, y: lastY, zoom: lastZoom } = this.lastNotifiedViewport;
    
    const deltaX = Math.abs(x - lastX);
    const deltaY = Math.abs(y - lastY);
    const deltaZoom = Math.abs(zoom - lastZoom);
    
    return deltaX > this.notificationThreshold ||
           deltaY > this.notificationThreshold ||
           deltaZoom > 0.01;
  }
  
  private notifyViewportChange(): void {
    this.onViewportChange.forEach(callback => {
      callback(this.viewport);
    });
  }
  
  private boundsIntersect(
    bounds1: { x: number; y: number; width: number; height: number } | ViewportBounds,
    bounds2: ViewportBounds
  ): boolean {
    let b1: ViewportBounds;
    
    if ('width' in bounds1) {
      b1 = {
        minX: bounds1.x,
        minY: bounds1.y,
        maxX: bounds1.x + bounds1.width,
        maxY: bounds1.y + bounds1.height
      };
    } else {
      b1 = bounds1;
    }
    
    return !(b1.maxX < bounds2.minX ||
             b1.minX > bounds2.maxX ||
             b1.maxY < bounds2.minY ||
             b1.minY > bounds2.maxY);
  }
  
  private calculateIntersection(
    bounds1: { x: number; y: number; width: number; height: number },
    bounds2: ViewportBounds
  ): DirtyRect | null {
    const minX = Math.max(bounds1.x, bounds2.minX);
    const minY = Math.max(bounds1.y, bounds2.minY);
    const maxX = Math.min(bounds1.x + bounds1.width, bounds2.maxX);
    const maxY = Math.min(bounds1.y + bounds1.height, bounds2.maxY);
    
    if (minX >= maxX || minY >= maxY) {
      return null;
    }
    
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
}
```

## 10.4.2 空间索引系统

空间索引使用四叉树或R-tree等数据结构快速查找视口内的元素。

### 四叉树实现

```typescript
interface QuadTreeNode {
  bounds: DirtyRect;
  elements: ExcalidrawElement[];
  children: QuadTreeNode[] | null;
  level: number;
}

class QuadTree {
  private root: QuadTreeNode;
  private maxElements = 10;
  private maxLevels = 5;
  
  constructor(bounds: DirtyRect) {
    this.root = {
      bounds,
      elements: [],
      children: null,
      level: 0
    };
  }
  
  // 插入元素
  insert(element: ExcalidrawElement): void {
    this.insertIntoNode(this.root, element);
  }
  
  // 删除元素
  remove(element: ExcalidrawElement): boolean {
    return this.removeFromNode(this.root, element);
  }
  
  // 查询区域内的元素
  queryRange(range: DirtyRect): ExcalidrawElement[] {
    const result: ExcalidrawElement[] = [];
    this.queryNode(this.root, range, result);
    return result;
  }
  
  // 更新元素位置
  updateElement(element: ExcalidrawElement): void {
    this.remove(element);
    this.insert(element);
  }
  
  // 清空四叉树
  clear(): void {
    this.clearNode(this.root);
    this.root.elements = [];
    this.root.children = null;
  }
  
  // 获取统计信息
  getStats(): {
    nodeCount: number;
    elementCount: number;
    maxDepth: number;
    averageElementsPerLeaf: number;
  } {
    let nodeCount = 0;
    let leafCount = 0;
    let totalElementsInLeaves = 0;
    let maxDepth = 0;
    
    const traverse = (node: QuadTreeNode, depth: number) => {
      nodeCount++;
      maxDepth = Math.max(maxDepth, depth);
      
      if (!node.children) {
        leafCount++;
        totalElementsInLeaves += node.elements.length;
      } else {
        node.children.forEach(child => traverse(child, depth + 1));
      }
    };
    
    traverse(this.root, 0);
    
    return {
      nodeCount,
      elementCount: this.countTotalElements(),
      maxDepth,
      averageElementsPerLeaf: leafCount > 0 ? totalElementsInLeaves / leafCount : 0
    };
  }
  
  private insertIntoNode(node: QuadTreeNode, element: ExcalidrawElement): void {
    const elementBounds = getElementBounds(element);
    
    if (!this.boundsIntersect(elementBounds, node.bounds)) {
      return;
    }
    
    if (!node.children && node.elements.length < this.maxElements) {
      node.elements.push(element);
      return;
    }
    
    if (!node.children && node.level < this.maxLevels) {
      this.split(node);
    }
    
    if (node.children) {
      for (const child of node.children) {
        this.insertIntoNode(child, element);
      }
    } else {
      node.elements.push(element);
    }
  }
  
  private removeFromNode(node: QuadTreeNode, element: ExcalidrawElement): boolean {
    const index = node.elements.indexOf(element);
    if (index !== -1) {
      node.elements.splice(index, 1);
      return true;
    }
    
    if (node.children) {
      for (const child of node.children) {
        if (this.removeFromNode(child, element)) {
          return true;
        }
      }
    }
    
    return false;
  }
  
  private queryNode(node: QuadTreeNode, range: DirtyRect, result: ExcalidrawElement[]): void {
    if (!this.boundsIntersect(node.bounds, range)) {
      return;
    }
    
    // 检查当前节点的元素
    for (const element of node.elements) {
      const elementBounds = getElementBounds(element);
      if (this.boundsIntersect(elementBounds, range)) {
        result.push(element);
      }
    }
    
    // 递归查询子节点
    if (node.children) {
      for (const child of node.children) {
        this.queryNode(child, range, result);
      }
    }
  }
  
  private split(node: QuadTreeNode): void {
    const { bounds, level } = node;
    const halfWidth = bounds.width / 2;
    const halfHeight = bounds.height / 2;
    
    node.children = [
      // 左上
      {
        bounds: {
          x: bounds.x,
          y: bounds.y,
          width: halfWidth,
          height: halfHeight
        },
        elements: [],
        children: null,
        level: level + 1
      },
      // 右上
      {
        bounds: {
          x: bounds.x + halfWidth,
          y: bounds.y,
          width: halfWidth,
          height: halfHeight
        },
        elements: [],
        children: null,
        level: level + 1
      },
      // 左下
      {
        bounds: {
          x: bounds.x,
          y: bounds.y + halfHeight,
          width: halfWidth,
          height: halfHeight
        },
        elements: [],
        children: null,
        level: level + 1
      },
      // 右下
      {
        bounds: {
          x: bounds.x + halfWidth,
          y: bounds.y + halfHeight,
          width: halfWidth,
          height: halfHeight
        },
        elements: [],
        children: null,
        level: level + 1
      }
    ];
    
    // 重新分配元素到子节点
    const elements = [...node.elements];
    node.elements = [];
    
    for (const element of elements) {
      this.insertIntoNode(node, element);
    }
  }
  
  private clearNode(node: QuadTreeNode): void {
    if (node.children) {
      for (const child of node.children) {
        this.clearNode(child);
      }
      node.children = null;
    }
    node.elements = [];
  }
  
  private boundsIntersect(bounds1: DirtyRect, bounds2: DirtyRect): boolean {
    return !(bounds1.x + bounds1.width < bounds2.x ||
             bounds2.x + bounds2.width < bounds1.x ||
             bounds1.y + bounds1.height < bounds2.y ||
             bounds2.y + bounds2.height < bounds1.y);
  }
  
  private countTotalElements(): number {
    let count = 0;
    
    const traverse = (node: QuadTreeNode) => {
      count += node.elements.length;
      if (node.children) {
        node.children.forEach(traverse);
      }
    };
    
    traverse(this.root);
    return count;
  }
}
```

## 10.4.3 虚拟化渲染器

虚拟化渲染器只渲染视口内及附近的元素，动态管理渲染列表。

### 虚拟化管理器

```typescript
interface VirtualizedRenderItem {
  element: ExcalidrawElement;
  bounds: DirtyRect;
  priority: number;
  lastRendered: number;
  isVisible: boolean;
}

class VirtualizedRenderer {
  private viewportManager: ViewportManager;
  private quadTree: QuadTree;
  private renderItems = new Map<string, VirtualizedRenderItem>();
  
  private renderBudget = 16; // 每帧16ms预算
  private renderQueue: VirtualizedRenderItem[] = [];
  private isRendering = false;
  
  constructor(viewportManager: ViewportManager, canvasBounds: DirtyRect) {
    this.viewportManager = viewportManager;
    this.quadTree = new QuadTree(canvasBounds);
    
    this.setupViewportListener();
  }
  
  // 添加元素到虚拟化系统
  addElement(element: ExcalidrawElement): void {
    const bounds = getElementBounds(element);
    const priority = this.calculateElementPriority(element);
    
    const renderItem: VirtualizedRenderItem = {
      element,
      bounds,
      priority,
      lastRendered: 0,
      isVisible: false
    };
    
    this.renderItems.set(element.id, renderItem);
    this.quadTree.insert(element);
    
    // 如果元素在视口内，加入渲染队列
    if (this.viewportManager.isElementVisible(element)) {
      this.addToRenderQueue(renderItem);
    }
  }
  
  // 移除元素
  removeElement(elementId: string): void {
    const renderItem = this.renderItems.get(elementId);
    if (renderItem) {
      this.quadTree.remove(renderItem.element);
      this.renderItems.delete(elementId);
      this.removeFromRenderQueue(renderItem);
    }
  }
  
  // 更新元素
  updateElement(element: ExcalidrawElement): void {
    const renderItem = this.renderItems.get(element.id);
    if (renderItem) {
      // 更新边界和优先级
      renderItem.element = element;
      renderItem.bounds = getElementBounds(element);
      renderItem.priority = this.calculateElementPriority(element);
      
      // 更新空间索引
      this.quadTree.updateElement(element);
      
      // 重新评估可见性
      const wasVisible = renderItem.isVisible;
      const isVisible = this.viewportManager.isElementVisible(element);
      
      if (isVisible && !wasVisible) {
        this.addToRenderQueue(renderItem);
      } else if (!isVisible && wasVisible) {
        this.removeFromRenderQueue(renderItem);
      }
    }
  }
  
  // 开始渲染循环
  startRenderLoop(): void {
    if (this.isRendering) return;
    
    this.isRendering = true;
    this.renderLoop();
  }
  
  // 停止渲染循环
  stopRenderLoop(): void {
    this.isRendering = false;
  }
  
  // 强制重新渲染所有可见元素
  forceRender(): void {
    const visibleElements = this.getVisibleElements();
    
    this.renderQueue = [];
    for (const element of visibleElements) {
      const renderItem = this.renderItems.get(element.id);
      if (renderItem) {
        this.addToRenderQueue(renderItem);
      }
    }
  }
  
  private setupViewportListener(): void {
    this.viewportManager.onViewportChanged(() => {
      this.updateVisibleElements();
    });
  }
  
  private updateVisibleElements(): void {
    const visibleElements = this.getVisibleElements();
    const visibleIds = new Set(visibleElements.map(el => el.id));
    
    // 更新可见性状态
    for (const [id, renderItem] of this.renderItems) {
      const wasVisible = renderItem.isVisible;
      const isVisible = visibleIds.has(id);
      
      renderItem.isVisible = isVisible;
      
      if (isVisible && !wasVisible) {
        this.addToRenderQueue(renderItem);
      } else if (!isVisible && wasVisible) {
        this.removeFromRenderQueue(renderItem);
      }
    }
  }
  
  private getVisibleElements(): ExcalidrawElement[] {
    const viewportBounds = this.viewportManager.getViewportBounds();
    const queryRect: DirtyRect = {
      x: viewportBounds.minX,
      y: viewportBounds.minY,
      width: viewportBounds.maxX - viewportBounds.minX,
      height: viewportBounds.maxY - viewportBounds.minY
    };
    
    return this.quadTree.queryRange(queryRect);
  }
  
  private addToRenderQueue(renderItem: VirtualizedRenderItem): void {
    if (!this.renderQueue.includes(renderItem)) {
      this.renderQueue.push(renderItem);
      this.sortRenderQueue();
    }
  }
  
  private removeFromRenderQueue(renderItem: VirtualizedRenderItem): void {
    const index = this.renderQueue.indexOf(renderItem);
    if (index !== -1) {
      this.renderQueue.splice(index, 1);
    }
  }
  
  private sortRenderQueue(): void {
    this.renderQueue.sort((a, b) => {
      // 按优先级排序（高优先级先渲染）
      if (a.priority !== b.priority) {
        return b.priority - a.priority;
      }
      
      // 优先级相同时，按上次渲染时间排序（久未渲染的先渲染）
      return a.lastRendered - b.lastRendered;
    });
  }
  
  private renderLoop(): void {
    if (!this.isRendering) return;
    
    const startTime = performance.now();
    let rendered = 0;
    
    while (this.renderQueue.length > 0 && (performance.now() - startTime) < this.renderBudget) {
      const renderItem = this.renderQueue.shift()!;
      
      if (renderItem.isVisible) {
        this.renderElement(renderItem);
        renderItem.lastRendered = performance.now();
        rendered++;
      }
    }
    
    // 下一帧继续渲染
    requestAnimationFrame(() => this.renderLoop());
  }
  
  private renderElement(renderItem: VirtualizedRenderItem): void {
    // 这里会调用实际的元素渲染函数
    // 实际实现会传入渲染上下文和渲染函数
    console.log(`Rendering element ${renderItem.element.id}`);
  }
  
  private calculateElementPriority(element: ExcalidrawElement): number {
    let priority = 0;
    
    // 基础优先级
    priority += 10;
    
    // 类型优先级
    switch (element.type) {
      case 'text':
        priority += 20; // 文本优先级高
        break;
      case 'image':
        priority += 15;
        break;
      case 'line':
        priority += 5;
        break;
      default:
        priority += 10;
    }
    
    // 大小影响优先级（大元素优先级高）
    const bounds = getElementBounds(element);
    const area = bounds.width * bounds.height;
    priority += Math.min(area / 10000, 50); // 最多增加50优先级
    
    // 选中状态影响优先级
    if ((element as any).isSelected) {
      priority += 100;
    }
    
    return priority;
  }
  
  // 获取渲染统计信息
  getRenderStats(): {
    totalElements: number;
    visibleElements: number;
    queuedElements: number;
    renderRate: number;
  } {
    const visibleCount = Array.from(this.renderItems.values())
      .filter(item => item.isVisible).length;
    
    return {
      totalElements: this.renderItems.size,
      visibleElements: visibleCount,
      queuedElements: this.renderQueue.length,
      renderRate: 60 // 简化计算
    };
  }
}
```

## 10.4.4 级联渲染系统

级联渲染根据距离和重要性分级渲染元素，近处高质量，远处低质量。

### 细节级别管理器

```typescript
interface LODLevel {
  name: string;
  minZoom: number;
  maxZoom: number;
  quality: number; // 0-1
  renderStyle: 'full' | 'simplified' | 'bounds' | 'hidden';
}

class LevelOfDetailManager {
  private lodLevels: LODLevel[] = [
    {
      name: 'hidden',
      minZoom: 0,
      maxZoom: 0.1,
      quality: 0,
      renderStyle: 'hidden'
    },
    {
      name: 'bounds',
      minZoom: 0.1,
      maxZoom: 0.25,
      quality: 0.1,
      renderStyle: 'bounds'
    },
    {
      name: 'simplified',
      minZoom: 0.25,
      maxZoom: 0.75,
      quality: 0.5,
      renderStyle: 'simplified'
    },
    {
      name: 'full',
      minZoom: 0.75,
      maxZoom: 10,
      quality: 1,
      renderStyle: 'full'
    }
  ];
  
  private viewportManager: ViewportManager;
  
  constructor(viewportManager: ViewportManager) {
    this.viewportManager = viewportManager;
  }
  
  // 获取元素的LOD级别
  getElementLOD(element: ExcalidrawElement): LODLevel {
    const viewport = this.viewportManager.getViewport();
    const elementBounds = getElementBounds(element);
    
    // 计算元素在屏幕上的大小
    const screenSize = this.calculateScreenSize(elementBounds, viewport.zoom);
    
    // 根据屏幕大小和缩放级别确定LOD
    let selectedLOD = this.lodLevels[0];
    
    for (const lod of this.lodLevels) {
      if (viewport.zoom >= lod.minZoom && viewport.zoom <= lod.maxZoom) {
        selectedLOD = lod;
        break;
      }
    }
    
    // 根据元素屏幕大小进一步调整
    if (screenSize < 10) {
      // 屏幕上很小的元素降级
      const index = this.lodLevels.indexOf(selectedLOD);
      if (index > 0) {
        selectedLOD = this.lodLevels[index - 1];
      }
    }
    
    return selectedLOD;
  }
  
  // 渲染元素（根据LOD级别）
  renderElementWithLOD(
    ctx: CanvasRenderingContext2D,
    element: ExcalidrawElement,
    lod: LODLevel
  ): void {
    ctx.save();
    
    switch (lod.renderStyle) {
      case 'hidden':
        // 不渲染
        break;
        
      case 'bounds':
        this.renderElementBounds(ctx, element);
        break;
        
      case 'simplified':
        this.renderElementSimplified(ctx, element, lod.quality);
        break;
        
      case 'full':
        this.renderElementFull(ctx, element);
        break;
    }
    
    ctx.restore();
  }
  
  private calculateScreenSize(bounds: DirtyRect, zoom: number): number {
    const screenWidth = bounds.width * zoom;
    const screenHeight = bounds.height * zoom;
    return Math.sqrt(screenWidth * screenWidth + screenHeight * screenHeight);
  }
  
  private renderElementBounds(ctx: CanvasRenderingContext2D, element: ExcalidrawElement): void {
    const bounds = getElementBounds(element);
    
    ctx.strokeStyle = '#cccccc';
    ctx.lineWidth = 1;
    ctx.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);
  }
  
  private renderElementSimplified(
    ctx: CanvasRenderingContext2D,
    element: ExcalidrawElement,
    quality: number
  ): void {
    switch (element.type) {
      case 'rectangle':
        this.renderSimplifiedRectangle(ctx, element, quality);
        break;
      case 'ellipse':
        this.renderSimplifiedEllipse(ctx, element, quality);
        break;
      case 'line':
        this.renderSimplifiedLine(ctx, element, quality);
        break;
      case 'text':
        this.renderSimplifiedText(ctx, element as any, quality);
        break;
      default:
        this.renderElementBounds(ctx, element);
    }
  }
  
  private renderSimplifiedRectangle(
    ctx: CanvasRenderingContext2D,
    element: ExcalidrawElement,
    quality: number
  ): void {
    ctx.fillStyle = element.backgroundColor || '#ffffff';
    ctx.strokeStyle = element.strokeColor || '#000000';
    ctx.lineWidth = Math.max(1, element.strokeWidth * quality);
    
    ctx.fillRect(element.x, element.y, element.width, element.height);
    ctx.strokeRect(element.x, element.y, element.width, element.height);
  }
  
  private renderSimplifiedEllipse(
    ctx: CanvasRenderingContext2D,
    element: ExcalidrawElement,
    quality: number
  ): void {
    const centerX = element.x + element.width / 2;
    const centerY = element.y + element.height / 2;
    const radiusX = element.width / 2;
    const radiusY = element.height / 2;
    
    ctx.fillStyle = element.backgroundColor || '#ffffff';
    ctx.strokeStyle = element.strokeColor || '#000000';
    ctx.lineWidth = Math.max(1, element.strokeWidth * quality);
    
    ctx.beginPath();
    ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
    
    if (element.backgroundColor && element.backgroundColor !== 'transparent') {
      ctx.fill();
    }
    ctx.stroke();
  }
  
  private renderSimplifiedLine(
    ctx: CanvasRenderingContext2D,
    element: ExcalidrawElement,
    quality: number
  ): void {
    const lineElement = element as any;
    if (!lineElement.points || lineElement.points.length < 2) return;
    
    ctx.strokeStyle = element.strokeColor || '#000000';
    ctx.lineWidth = Math.max(1, element.strokeWidth * quality);
    
    ctx.beginPath();
    
    // 简化点数
    const points = lineElement.points;
    const simplificationFactor = Math.max(1, Math.floor((1 - quality) * 5));
    
    ctx.moveTo(points[0][0], points[0][1]);
    
    for (let i = simplificationFactor; i < points.length; i += simplificationFactor) {
      ctx.lineTo(points[i][0], points[i][1]);
    }
    
    // 确保连接到最后一个点
    if (points.length > 1) {
      const lastPoint = points[points.length - 1];
      ctx.lineTo(lastPoint[0], lastPoint[1]);
    }
    
    ctx.stroke();
  }
  
  private renderSimplifiedText(
    ctx: CanvasRenderingContext2D,
    element: any,
    quality: number
  ): void {
    const fontSize = Math.max(8, element.fontSize * quality);
    
    ctx.fillStyle = element.strokeColor || '#000000';
    ctx.font = `${fontSize}px ${element.fontFamily || 'Arial'}`;
    ctx.textAlign = element.textAlign || 'left';
    ctx.textBaseline = 'top';
    
    // 简化文本内容
    let text = element.text || '';
    if (quality < 0.5 && text.length > 20) {
      text = text.substring(0, 17) + '...';
    }
    
    ctx.fillText(text, element.x, element.y);
  }
  
  private renderElementFull(ctx: CanvasRenderingContext2D, element: ExcalidrawElement): void {
    // 这里会调用完整的元素渲染器
    // 实际实现会使用已有的渲染系统
    console.log(`Rendering full quality: ${element.type}`);
  }
  
  // 获取LOD统计信息
  getLODStats(elements: ExcalidrawElement[]): Record<string, number> {
    const stats: Record<string, number> = {};
    
    for (const lod of this.lodLevels) {
      stats[lod.name] = 0;
    }
    
    for (const element of elements) {
      const lod = this.getElementLOD(element);
      stats[lod.name]++;
    }
    
    return stats;
  }
}
```

这是第10章第4节的内容，专注于视口优化与虚拟化。我已经完成了性能优化章节的所有小节。现在让我更新todo列表并标记为完成。