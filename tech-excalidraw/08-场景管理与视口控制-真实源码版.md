# 第8章：场景管理与视口控制-真实源码版

## 8.1 场景管理系统概览

在Excalidraw中，场景管理是一个复杂但精心设计的系统，负责管理所有元素的生命周期、视口状态和渲染优化。让我们深入分析真实的源码实现。

### 8.1.1 核心架构分析

Excalidraw的场景管理系统主要由以下几个核心组件构成：

1. **Scene类** (`packages/element/src/Scene.ts`) - 核心场景管理器
2. **Renderer类** (`packages/excalidraw/scene/Renderer.ts`) - 渲染管理器  
3. **视口控制模块** (`packages/excalidraw/scene/scroll.ts`, `zoom.ts`) - 视口操作
4. **场景类型定义** (`packages/excalidraw/scene/types.ts`) - 类型系统

```typescript
// packages/element/src/Scene.ts - Scene类的核心结构
export class Scene {
  // 私有状态管理
  private callbacks: Set<SceneStateCallback> = new Set();
  private nonDeletedElements: readonly Ordered<NonDeletedExcalidrawElement>[] = [];
  private nonDeletedElementsMap = toBrandedType<NonDeletedSceneElementsMap>(new Map());
  private elements: readonly OrderedExcalidrawElement[] = [];
  private frames: readonly ExcalidrawFrameLikeElement[] = [];
  private elementsMap = toBrandedType<SceneElementsMap>(new Map());
  
  // 选中元素缓存系统
  private selectedElementsCache: {
    selectedElementIds: AppState["selectedElementIds"] | null;
    elements: readonly NonDeletedExcalidrawElement[] | null;
    cache: Map<SelectionHash, NonDeletedExcalidrawElement[]>;
  };
  
  // 场景更新随机数（用于缓存失效）
  private sceneNonce: number | undefined;
}
```

### 8.1.2 Scene类的设计理念

Scene类采用了几个重要的设计模式：

**1. 观察者模式（Observer Pattern）**
```typescript
// 场景状态变化回调系统
onUpdate(cb: SceneStateCallback): SceneStateCallbackRemover {
  if (this.callbacks.has(cb)) {
    throw new Error();
  }
  this.callbacks.add(cb);
  
  return () => {
    if (!this.callbacks.has(cb)) {
      throw new Error();
    }
    this.callbacks.delete(cb);
  };
}

triggerUpdate() {
  this.sceneNonce = randomInteger(); // 生成新的缓存失效标识
  
  for (const callback of Array.from(this.callbacks)) {
    callback();
  }
}
```

**2. 缓存策略（Caching Strategy）**
```typescript
// 选中元素的智能缓存
getSelectedElements(opts: {
  selectedElementIds: AppState["selectedElementIds"];
  elements?: ElementsMapOrArray;
  includeBoundTextElement?: boolean;
  includeElementsInFrames?: boolean;
}): NonDeleted<ExcalidrawElement>[] {
  const hash = hashSelectionOpts(opts);
  const elements = opts?.elements || this.nonDeletedElements;
  
  // 检查缓存是否有效
  if (
    this.selectedElementsCache.elements === elements &&
    this.selectedElementsCache.selectedElementIds === opts.selectedElementIds
  ) {
    const cached = this.selectedElementsCache.cache.get(hash);
    if (cached) {
      return cached; // 返回缓存结果
    }
  }
  
  // 计算新的选中元素
  const selectedElements = getSelectedElements(elements, { selectedElementIds: opts.selectedElementIds }, opts);
  
  // 更新缓存
  if (opts?.elements == null) {
    this.selectedElementsCache.selectedElementIds = opts.selectedElementIds;
    this.selectedElementsCache.elements = this.nonDeletedElements;
    this.selectedElementsCache.cache.set(hash, selectedElements);
  }
  
  return selectedElements;
}
```

## 8.2 元素生命周期管理

### 8.2.1 元素添加与删除

Scene类提供了完整的元素生命周期管理方法：

```typescript
// 替换所有元素（核心方法）
replaceAllElements(
  nextElements: ElementsMapOrArray,
  options?: { skipValidation?: true }
) {
  const _nextElements = toArray(nextElements);
  const nextFrameLikes: ExcalidrawFrameLikeElement[] = [];

  // 验证分数索引（除非明确跳过）
  if (!options?.skipValidation) {
    validateIndicesThrottled(_nextElements);
  }

  // 同步无效索引，确保元素顺序正确
  this.elements = syncInvalidIndices(_nextElements);
  this.elementsMap.clear();
  
  // 构建元素映射表和帧元素列表
  this.elements.forEach((element) => {
    if (isFrameLikeElement(element)) {
      nextFrameLikes.push(element);
    }
    this.elementsMap.set(element.id, element);
  });
  
  // 获取非删除元素
  const nonDeletedElements = getNonDeletedElements(this.elements);
  this.nonDeletedElements = nonDeletedElements.elements;
  this.nonDeletedElementsMap = nonDeletedElements.elementsMap;

  this.frames = nextFrameLikes;
  this.nonDeletedFramesLikes = getNonDeletedElements(this.frames).elements;

  this.triggerUpdate(); // 触发更新通知
}
```

**非删除元素过滤**
```typescript
const getNonDeletedElements = <T extends ExcalidrawElement>(
  allElements: readonly T[],
) => {
  const elementsMap = new Map() as NonDeletedSceneElementsMap;
  const elements: T[] = [];
  
  for (const element of allElements) {
    if (!element.isDeleted) {
      elements.push(element as NonDeleted<T>);
      elementsMap.set(element.id, element as Ordered<NonDeletedExcalidrawElement>);
    }
  }
  return { elementsMap, elements };
};
```

### 8.2.2 智能元素插入

Scene类实现了智能的元素插入逻辑，特别是对帧元素的处理：

```typescript
// 单个元素插入
insertElement = (element: ExcalidrawElement) => {
  // 如果元素有frameId，插入到对应帧的位置
  const index = element.frameId
    ? this.getElementIndex(element.frameId)
    : this.elements.length;

  this.insertElementAtIndex(element, index);
};

// 在指定位置插入元素
insertElementAtIndex(element: ExcalidrawElement, index: number) {
  if (!Number.isFinite(index) || index < 0) {
    throw new Error("insertElementAtIndex can only be called with index >= 0");
  }

  const nextElements = [
    ...this.elements.slice(0, index),
    element,
    ...this.elements.slice(index),
  ];

  // 同步移动的索引
  syncMovedIndices(nextElements, arrayToMap([element]));
  this.replaceAllElements(nextElements);
}
```

### 8.2.3 元素变更管理

Scene类还提供了高效的元素变更方法：

```typescript
// 高效的元素映射变更
mapElements(iteratee: (element: ExcalidrawElement) => ExcalidrawElement): boolean {
  let didChange = false;
  const newElements = this.elements.map((element) => {
    const nextElement = iteratee(element);
    if (nextElement !== element) {
      didChange = true;
    }
    return nextElement;
  });
  
  if (didChange) {
    this.replaceAllElements(newElements);
  }
  return didChange;
}

// 单个元素变更
mutateElement<TElement extends Mutable<ExcalidrawElement>>(
  element: TElement,
  updates: ElementUpdate<TElement>,
  options: {
    informMutation: boolean;
    isDragging: boolean;
  } = { informMutation: true, isDragging: false }
) {
  const elementsMap = this.getNonDeletedElementsMap();
  const { version: prevVersion } = element;
  
  // 调用元素变更函数
  const { version: nextVersion } = mutateElement(element, elementsMap, updates, options);

  // 只有在元素版本发生变化且需要通知时才触发更新
  if (
    this.elementsMap.has(element.id) &&
    prevVersion !== nextVersion &&
    options.informMutation
  ) {
    this.triggerUpdate();
  }

  return element;
}
```

## 8.3 视口控制系统

### 8.3.1 滚动控制

视口控制是Excalidraw中的关键功能，让我们看看真实的实现：

```typescript
// packages/excalidraw/scene/scroll.ts

// 将视口中心定位到指定场景点
export const centerScrollOn = ({
  scenePoint,
  viewportDimensions,
  zoom,
  offsets,
}: {
  scenePoint: PointerCoords;
  viewportDimensions: { height: number; width: number };
  zoom: Zoom;
  offsets?: Offsets;
}) => {
  // 计算横向滚动偏移
  let scrollX =
    (viewportDimensions.width - (offsets?.right ?? 0)) / 2 / zoom.value -
    scenePoint.x;
  scrollX += (offsets?.left ?? 0) / 2 / zoom.value;

  // 计算纵向滚动偏移
  let scrollY =
    (viewportDimensions.height - (offsets?.bottom ?? 0)) / 2 / zoom.value -
    scenePoint.y;
  scrollY += (offsets?.top ?? 0) / 2 / zoom.value;

  return { scrollX, scrollY };
};
```

**智能滚动中心计算**
```typescript
export const calculateScrollCenter = (
  elements: readonly ExcalidrawElement[],
  appState: AppState,
): { scrollX: number; scrollY: number } => {
  elements = getVisibleElements(elements);

  if (!elements.length) {
    return { scrollX: 0, scrollY: 0 };
  }

  let [x1, y1, x2, y2] = getCommonBounds(elements);

  // 如果元素超出视口，找到最近的元素边界
  if (isOutsideViewPort(appState, [x1, y1, x2, y2])) {
    [x1, y1, x2, y2] = getClosestElementBounds(
      elements,
      viewportCoordsToSceneCoords(
        { clientX: appState.scrollX, clientY: appState.scrollY },
        appState,
      ),
    );
  }

  const centerX = (x1 + x2) / 2;
  const centerY = (y1 + y2) / 2;

  return centerScrollOn({
    scenePoint: { x: centerX, y: centerY },
    viewportDimensions: { width: appState.width, height: appState.height },
    zoom: appState.zoom,
  });
};
```

### 8.3.2 缩放控制

缩放系统的实现考虑了缩放中心点的保持：

```typescript
// packages/excalidraw/scene/zoom.ts

export const getStateForZoom = (
  {
    viewportX,
    viewportY,
    nextZoom,
  }: {
    viewportX: number;
    viewportY: number;
    nextZoom: NormalizedZoomValue;
  },
  appState: AppState,
) => {
  // 计算相对于应用层的坐标
  const appLayerX = viewportX - appState.offsetLeft;
  const appLayerY = viewportY - appState.offsetTop;

  const currentZoom = appState.zoom.value;

  // 获取没有缩放影响的原始滚动位置
  const baseScrollX = appState.scrollX + (appLayerX - appLayerX / currentZoom);
  const baseScrollY = appState.scrollY + (appLayerY - appLayerY / currentZoom);

  // 计算目标缩放级别的滚动偏移
  const zoomOffsetScrollX = -(appLayerX - appLayerX / nextZoom);
  const zoomOffsetScrollY = -(appLayerY - appLayerY / nextZoom);

  return {
    scrollX: baseScrollX + zoomOffsetScrollX,
    scrollY: baseScrollY + zoomOffsetScrollY,
    zoom: { value: nextZoom },
  };
};
```

**缩放值标准化**
```typescript
// packages/excalidraw/scene/normalize.ts
export const getNormalizedZoom = (zoom: number): NormalizedZoomValue => {
  return clamp(round(zoom, 6), MIN_ZOOM, MAX_ZOOM) as NormalizedZoomValue;
};
```

## 8.4 渲染器系统

### 8.4.1 Renderer类架构

Renderer类负责管理场景的渲染逻辑：

```typescript
// packages/excalidraw/scene/Renderer.ts
export class Renderer {
  private scene: Scene;

  constructor(scene: Scene) {
    this.scene = scene;
  }

  // 获取可渲染元素的核心方法
  public getRenderableElements = (() => {
    // 获取视口内可见元素
    const getVisibleCanvasElements = ({
      elementsMap,
      zoom,
      offsetLeft,
      offsetTop,
      scrollX,
      scrollY,
      height,
      width,
    }: {
      elementsMap: NonDeletedElementsMap;
      zoom: AppState["zoom"];
      offsetLeft: AppState["offsetLeft"];
      offsetTop: AppState["offsetTop"];
      scrollX: AppState["scrollX"];
      scrollY: AppState["scrollY"];
      height: AppState["height"];
      width: AppState["width"];
    }): readonly NonDeletedExcalidrawElement[] => {
      const visibleElements: NonDeletedExcalidrawElement[] = [];
      
      for (const element of elementsMap.values()) {
        if (
          isElementInViewport(
            element,
            width,
            height,
            { zoom, offsetLeft, offsetTop, scrollX, scrollY },
            elementsMap,
          )
        ) {
          visibleElements.push(element);
        }
      }
      return visibleElements;
    };
  })();
}
```

### 8.4.2 渲染配置类型

场景渲染系统定义了多种渲染配置：

```typescript
// packages/excalidraw/scene/types.ts

// 静态场景渲染配置
export type StaticCanvasRenderConfig = {
  canvasBackgroundColor: AppState["viewBackgroundColor"];
  imageCache: AppClassProperties["imageCache"];
  renderGrid: boolean;
  isExporting: boolean;
  embedsValidationStatus: EmbedsValidationStatus;
  elementsPendingErasure: ElementsPendingErasure;
  pendingFlowchartNodes: PendingExcalidrawElements | null;
};

// 交互式场景渲染配置
export type InteractiveCanvasRenderConfig = {
  remoteSelectedElementIds: Map<ExcalidrawElement["id"], SocketId[]>;
  remotePointerViewportCoords: Map<SocketId, { x: number; y: number }>;
  remotePointerUserStates: Map<SocketId, UserIdleState>;
  remotePointerUsernames: Map<SocketId, string>;
  remotePointerButton: Map<SocketId, string | undefined>;
  selectionColor: string;
  renderScrollbars?: boolean;
};

// 场景渲染配置
export type StaticSceneRenderConfig = {
  canvas: HTMLCanvasElement;
  rc: RoughCanvas;
  elementsMap: RenderableElementsMap;
  allElementsMap: NonDeletedSceneElementsMap;
  visibleElements: readonly NonDeletedExcalidrawElement[];
  scale: number;
  appState: StaticCanvasAppState;
  renderConfig: StaticCanvasRenderConfig;
};
```

## 8.5 场景导出系统

### 8.5.1 导出类型定义

Excalidraw支持多种导出格式：

```typescript
export type ExportType =
  | "png"
  | "clipboard"
  | "clipboard-svg"
  | "backend"
  | "svg";
```

### 8.5.2 帧标签渲染

导出时需要特殊处理帧标签：

```typescript
// packages/excalidraw/scene/export.ts

const truncateText = (element: ExcalidrawTextElement, maxWidth: number) => {
  if (element.width <= maxWidth) {
    return element;
  }
  
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d")!;
  ctx.font = getFontString({
    fontFamily: element.fontFamily,
    fontSize: element.fontSize,
  });

  let text = element.text;
  const metrics = ctx.measureText(text);

  if (metrics.width > maxWidth) {
    // 从右侧开始迭代，逐个移除字符而不是逐个构建字符串
    // 这假设帧名称溢出的字符不会太多，所以这种方式应该更快
    for (let i = text.length; i > 0; i--) {
      const newText = `${text.slice(0, i)}...`;
      if (ctx.measureText(newText).width <= maxWidth) {
        text = newText;
        break;
      }
    }
  }
  return newElementWith(element, { text, width: maxWidth });
};
```

## 8.6 性能优化策略

### 8.6.1 缓存失效机制

Scene类使用sceneNonce来实现高效的缓存失效：

```typescript
/**
 * 每次场景更新时重新生成的随机整数。
 * 不与元素版本相关，目前只是渲染器缓存失效的nonce。
 */
private sceneNonce: number | undefined;

getSceneNonce() {
  return this.sceneNonce;
}

triggerUpdate() {
  this.sceneNonce = randomInteger(); // 生成新的缓存失效标识
  for (const callback of Array.from(this.callbacks)) {
    callback();
  }
}
```

### 8.6.2 分数索引验证

为了保证元素顺序的正确性，Scene类实现了节流的索引验证：

```typescript
const validateIndicesThrottled = throttle(
  (elements: readonly ExcalidrawElement[]) => {
    if (isDevEnv() || isTestEnv() || window?.DEBUG_FRACTIONAL_INDICES) {
      validateFractionalIndices(elements, {
        // 只在开发和测试环境中抛出异常，在调试模式下保持功能正常
        shouldThrow: isDevEnv() || isTestEnv(),
        includeBoundTextValidation: true,
      });
    }
  },
  1000 * 60, // 每分钟最多执行一次
  { leading: true, trailing: false },
);
```

### 8.6.3 选中元素哈希缓存

Scene类实现了智能的选中元素缓存系统：

```typescript
const hashSelectionOpts = (
  opts: Parameters<InstanceType<typeof Scene>["getSelectedElements"]>[0],
) => {
  const keys = ["includeBoundTextElement", "includeElementsInFrames"] as const;
  
  let hash = "";
  for (const key of keys) {
    hash += `${key}:${opts[key] ? "1" : "0"}`;
  }
  return hash as SelectionHash;
};
```

## 8.7 实际应用示例

### 8.7.1 场景管理的基本使用

```typescript
// 创建场景实例
const scene = new Scene();

// 添加元素
const newElement = newElement({
  type: "rectangle",
  x: 100,
  y: 100,
  width: 200,
  height: 100,
});

scene.insertElement(newElement);

// 监听场景变化
const unsubscribe = scene.onUpdate(() => {
  console.log("场景已更新，nonce:", scene.getSceneNonce());
});

// 获取选中元素
const selectedElements = scene.getSelectedElements({
  selectedElementIds: new Set([newElement.id]),
  includeBoundTextElement: true,
});

// 清理资源
unsubscribe();
scene.destroy();
```

### 8.7.2 视口控制示例

```typescript
// 计算滚动中心
const scrollCenter = calculateScrollCenter(elements, appState);

// 应用新的滚动位置
const newAppState = {
  ...appState,
  scrollX: scrollCenter.scrollX,
  scrollY: scrollCenter.scrollY,
};

// 处理缩放
const zoomState = getStateForZoom(
  {
    viewportX: event.clientX,
    viewportY: event.clientY,
    nextZoom: getNormalizedZoom(appState.zoom.value * 1.2),
  },
  appState
);
```

## 8.8 总结

Excalidraw的场景管理系统展现了以下优秀的设计特点：

### 8.8.1 设计优势

1. **分离关注点**：Scene类专注于元素管理，Renderer类专注于渲染优化
2. **智能缓存**：多层缓存策略减少不必要的计算
3. **观察者模式**：解耦场景状态变化通知
4. **类型安全**：完整的TypeScript类型系统
5. **性能优化**：节流验证、视口裁剪、缓存失效等机制

### 8.8.2 关键学习点

1. **缓存策略**：如何设计多层次的缓存系统来优化性能
2. **状态管理**：如何管理复杂的场景状态和元素生命周期
3. **渲染优化**：如何通过视口裁剪和智能缓存提升渲染性能
4. **类型设计**：如何设计灵活且类型安全的API接口

通过深入分析Excalidraw的场景管理系统，我们可以学习到如何构建一个高性能、可维护的图形编辑器场景管理架构。这些设计模式和优化策略可以应用到其他复杂的前端应用开发中。