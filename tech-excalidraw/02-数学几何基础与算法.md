# 数学几何基础与算法
## 图形编辑器的数学内核

---

## 🎯 学习目标

通过本章学习，你将完全掌握：
- 2D 图形学的完整数学基础
- 向量运算与几何变换的实际应用
- 碰撞检测的各种算法实现
- 几何图形的数学建模和计算
- Excalidraw 中几何算法的实际运用

---

## 1. 坐标系统与基础概念

### 1.1 坐标系统的理解

在图形编程中，我们需要处理多个坐标系统：

```javascript
// 1. 世界坐标系（World Coordinates）
// - 图形的绝对位置
// - 不受视口影响
const worldPoint = { x: 1000, y: 500 };

// 2. 视口坐标系（Viewport Coordinates）  
// - 用户看到的坐标
// - 受缩放和平移影响
const viewportPoint = worldToViewport(worldPoint, viewport);

// 3. 屏幕坐标系（Screen Coordinates）
// - Canvas 上的像素位置
// - 受设备像素比影响
const screenPoint = viewportToScreen(viewportPoint, canvas);
```

### 1.2 坐标变换的实现

```javascript
class CoordinateSystem {
    constructor() {
        this.zoom = 1;
        this.offsetX = 0;
        this.offsetY = 0;
    }
    
    // 世界坐标 → 屏幕坐标
    worldToScreen(worldX, worldY) {
        return {
            x: (worldX + this.offsetX) * this.zoom,
            y: (worldY + this.offsetY) * this.zoom
        };
    }
    
    // 屏幕坐标 → 世界坐标
    screenToWorld(screenX, screenY) {
        return {
            x: screenX / this.zoom - this.offsetX,
            y: screenY / this.zoom - this.offsetY
        };
    }
    
    // 设置视口
    setViewport(centerX, centerY, zoom) {
        this.zoom = zoom;
        this.offsetX = centerX;
        this.offsetY = centerY;
    }
}
```

---

## 2. 向量数学详解

### 2.1 向量基础操作

向量是图形学的基础，让我们从最基本的操作开始：

```javascript
class Vector2 {
    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
    }
    
    // 向量加法
    add(other) {
        return new Vector2(this.x + other.x, this.y + other.y);
    }
    
    // 向量减法
    subtract(other) {
        return new Vector2(this.x - other.x, this.y - other.y);
    }
    
    // 标量乘法
    multiply(scalar) {
        return new Vector2(this.x * scalar, this.y * scalar);
    }
    
    // 向量长度（模）
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    
    // 向量长度的平方（避免开方运算）
    lengthSquared() {
        return this.x * this.x + this.y * this.y;
    }
    
    // 单位向量（归一化）
    normalize() {
        const len = this.length();
        if (len === 0) return new Vector2(0, 0);
        return new Vector2(this.x / len, this.y / len);
    }
    
    // 点积（数量积）
    dot(other) {
        return this.x * other.x + this.y * other.y;
    }
    
    // 叉积（向量积的 z 分量）
    cross(other) {
        return this.x * other.y - this.y * other.x;
    }
    
    // 两向量之间的角度
    angleTo(other) {
        const dot = this.dot(other);
        const lengths = this.length() * other.length();
        if (lengths === 0) return 0;
        return Math.acos(Math.max(-1, Math.min(1, dot / lengths)));
    }
    
    // 向量旋转
    rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return new Vector2(
            this.x * cos - this.y * sin,
            this.x * sin + this.y * cos
        );
    }
    
    // 垂直向量
    perpendicular() {
        return new Vector2(-this.y, this.x);
    }
    
    // 向量插值
    lerp(other, t) {
        return new Vector2(
            this.x + (other.x - this.x) * t,
            this.y + (other.y - this.y) * t
        );
    }
    
    // 向量投影
    project(onto) {
        const dot = this.dot(onto);
        const ontoLengthSq = onto.lengthSquared();
        if (ontoLengthSq === 0) return new Vector2(0, 0);
        
        const scalar = dot / ontoLengthSq;
        return onto.multiply(scalar);
    }
    
    // 向量反射
    reflect(normal) {
        const dot = this.dot(normal);
        return this.subtract(normal.multiply(2 * dot));
    }
    
    // 复制向量
    clone() {
        return new Vector2(this.x, this.y);
    }
    
    // 向量相等判断
    equals(other, tolerance = 0.0001) {
        return Math.abs(this.x - other.x) < tolerance &&
               Math.abs(this.y - other.y) < tolerance;
    }
    
    toString() {
        return `Vector2(${this.x.toFixed(2)}, ${this.y.toFixed(2)})`;
    }
}
```

### 2.2 向量的实际应用

```javascript
// 应用示例：计算物体运动
class MovableObject {
    constructor(x, y) {
        this.position = new Vector2(x, y);
        this.velocity = new Vector2(0, 0);
        this.acceleration = new Vector2(0, 0);
    }
    
    // 物理更新
    update(deltaTime) {
        // 速度 = 速度 + 加速度 * 时间
        this.velocity = this.velocity.add(
            this.acceleration.multiply(deltaTime)
        );
        
        // 位置 = 位置 + 速度 * 时间
        this.position = this.position.add(
            this.velocity.multiply(deltaTime)
        );
    }
    
    // 应用力（加速度）
    applyForce(force) {
        this.acceleration = this.acceleration.add(force);
    }
    
    // 朝向目标移动
    seekTarget(target, speed) {
        const direction = target.subtract(this.position).normalize();
        this.velocity = direction.multiply(speed);
    }
}
```

---

## 3. 几何变换矩阵

### 3.1 2D 变换矩阵详解

2D 变换使用 3x3 齐次坐标矩阵：

```
[x']   [a c e] [x]
[y'] = [b d f] [y]
[1 ]   [0 0 1] [1]
```

其中：
- a, d: 缩放
- b, c: 倾斜和旋转
- e, f: 平移

```javascript
class Transform2D {
    constructor(a = 1, b = 0, c = 0, d = 1, e = 0, f = 0) {
        this.a = a; this.b = b; this.c = c;
        this.d = d; this.e = e; this.f = f;
    }
    
    // 创建单位矩阵
    static identity() {
        return new Transform2D();
    }
    
    // 创建平移矩阵
    static translation(x, y) {
        return new Transform2D(1, 0, 0, 1, x, y);
    }
    
    // 创建旋转矩阵
    static rotation(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return new Transform2D(cos, sin, -sin, cos, 0, 0);
    }
    
    // 创建缩放矩阵
    static scale(sx, sy = sx) {
        return new Transform2D(sx, 0, 0, sy, 0, 0);
    }
    
    // 创建倾斜矩阵
    static skew(skewX, skewY) {
        return new Transform2D(
            1, Math.tan(skewY),
            Math.tan(skewX), 1,
            0, 0
        );
    }
    
    // 矩阵乘法
    multiply(other) {
        return new Transform2D(
            this.a * other.a + this.c * other.b,
            this.b * other.a + this.d * other.b,
            this.a * other.c + this.c * other.d,
            this.b * other.c + this.d * other.d,
            this.a * other.e + this.c * other.f + this.e,
            this.b * other.e + this.d * other.f + this.f
        );
    }
    
    // 变换点
    transformPoint(x, y) {
        return {
            x: this.a * x + this.c * y + this.e,
            y: this.b * x + this.d * y + this.f
        };
    }
    
    // 变换向量（忽略平移）
    transformVector(x, y) {
        return {
            x: this.a * x + this.c * y,
            y: this.b * x + this.d * y
        };
    }
    
    // 逆矩阵
    inverse() {
        const det = this.a * this.d - this.b * this.c;
        if (Math.abs(det) < 1e-10) {
            throw new Error('Matrix is not invertible');
        }
        
        const invDet = 1 / det;
        return new Transform2D(
            this.d * invDet,
            -this.b * invDet,
            -this.c * invDet,
            this.a * invDet,
            (this.c * this.f - this.d * this.e) * invDet,
            (this.b * this.e - this.a * this.f) * invDet
        );
    }
    
    // 获取变换的分解结果
    decompose() {
        const a = this.a, b = this.b, c = this.c, d = this.d;
        const e = this.e, f = this.f;
        
        // 平移
        const translation = { x: e, y: f };
        
        // 缩放
        const scaleX = Math.sqrt(a * a + b * b);
        const scaleY = Math.sqrt(c * c + d * d);
        
        // 旋转
        const rotation = Math.atan2(b, a);
        
        // 倾斜
        const skewX = Math.atan2(c, d) - rotation;
        
        return {
            translation,
            scale: { x: scaleX, y: scaleY },
            rotation,
            skew: { x: skewX, y: 0 }
        };
    }
    
    // 应用到 Canvas
    applyToCanvas(ctx) {
        ctx.setTransform(this.a, this.b, this.c, this.d, this.e, this.f);
    }
    
    toString() {
        return `Transform2D(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.e}, ${this.f})`;
    }
}
```

### 3.2 复合变换的处理

```javascript
// 围绕指定点旋转
function rotateAroundPoint(point, center, angle) {
    const transform = Transform2D.translation(-center.x, -center.y)
        .multiply(Transform2D.rotation(angle))
        .multiply(Transform2D.translation(center.x, center.y));
    
    return transform.transformPoint(point.x, point.y);
}

// 创建从一个矩形到另一个矩形的变换
function createRectToRectTransform(fromRect, toRect) {
    // 计算缩放
    const scaleX = toRect.width / fromRect.width;
    const scaleY = toRect.height / fromRect.height;
    
    // 计算平移
    const translateX = toRect.x - fromRect.x * scaleX;
    const translateY = toRect.y - fromRect.y * scaleY;
    
    return Transform2D.scale(scaleX, scaleY)
        .multiply(Transform2D.translation(translateX, translateY));
}
```

---

## 4. 碰撞检测算法大全

### 4.1 点与图形的碰撞检测

#### 点与矩形
```javascript
function pointInRect(px, py, rect) {
    return px >= rect.x && 
           px <= rect.x + rect.width &&
           py >= rect.y && 
           py <= rect.y + rect.height;
}

// 考虑旋转的矩形
function pointInRotatedRect(px, py, rect) {
    if (rect.angle === 0) {
        return pointInRect(px, py, rect);
    }
    
    // 将点转换到矩形的本地坐标系
    const center = {
        x: rect.x + rect.width / 2,
        y: rect.y + rect.height / 2
    };
    
    const cos = Math.cos(-rect.angle);
    const sin = Math.sin(-rect.angle);
    
    const dx = px - center.x;
    const dy = py - center.y;
    
    const localX = dx * cos - dy * sin;
    const localY = dx * sin + dy * cos;
    
    return localX >= -rect.width / 2 &&
           localX <= rect.width / 2 &&
           localY >= -rect.height / 2 &&
           localY <= rect.height / 2;
}
```

#### 点与圆形
```javascript
function pointInCircle(px, py, circle) {
    const dx = px - circle.x;
    const dy = py - circle.y;
    const distanceSquared = dx * dx + dy * dy;
    return distanceSquared <= circle.radius * circle.radius;
}
```

#### 点与椭圆
```javascript
function pointInEllipse(px, py, ellipse) {
    const dx = px - ellipse.centerX;
    const dy = py - ellipse.centerY;
    
    // 椭圆方程：(x/a)² + (y/b)² <= 1
    const normalizedX = dx / ellipse.radiusX;
    const normalizedY = dy / ellipse.radiusY;
    
    return normalizedX * normalizedX + normalizedY * normalizedY <= 1;
}

// 考虑旋转的椭圆
function pointInRotatedEllipse(px, py, ellipse) {
    if (ellipse.angle === 0) {
        return pointInEllipse(px, py, ellipse);
    }
    
    // 将点转换到椭圆的本地坐标系
    const cos = Math.cos(-ellipse.angle);
    const sin = Math.sin(-ellipse.angle);
    
    const dx = px - ellipse.centerX;
    const dy = py - ellipse.centerY;
    
    const localX = dx * cos - dy * sin;
    const localY = dx * sin + dy * cos;
    
    const normalizedX = localX / ellipse.radiusX;
    const normalizedY = localY / ellipse.radiusY;
    
    return normalizedX * normalizedX + normalizedY * normalizedY <= 1;
}
```

#### 点与线条
```javascript
function pointToLineDistance(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    
    if (lenSq === 0) {
        // 线段退化为点
        return Math.sqrt(A * A + B * B);
    }
    
    let param = dot / lenSq;
    
    let xx, yy;
    
    if (param < 0) {
        xx = x1;
        yy = y1;
    } else if (param > 1) {
        xx = x2;
        yy = y2;
    } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
    }
    
    const dx = px - xx;
    const dy = py - yy;
    
    return Math.sqrt(dx * dx + dy * dy);
}

function pointNearLine(px, py, x1, y1, x2, y2, tolerance = 5) {
    return pointToLineDistance(px, py, x1, y1, x2, y2) <= tolerance;
}
```

### 4.2 图形与图形的碰撞检测

#### AABB (轴对齐包围盒) 碰撞
```javascript
function aabbCollision(rect1, rect2) {
    return !(rect1.x > rect2.x + rect2.width ||
             rect1.x + rect1.width < rect2.x ||
             rect1.y > rect2.y + rect2.height ||
             rect1.y + rect1.height < rect2.y);
}
```

#### 圆形碰撞
```javascript
function circleCollision(circle1, circle2) {
    const dx = circle2.x - circle1.x;
    const dy = circle2.y - circle1.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance <= circle1.radius + circle2.radius;
}
```

#### 分离轴定理 (SAT) - 凸多边形碰撞
```javascript
class SATCollision {
    // 获取多边形在轴上的投影
    static getProjection(vertices, axis) {
        let min = Infinity;
        let max = -Infinity;
        
        for (const vertex of vertices) {
            const dot = vertex.x * axis.x + vertex.y * axis.y;
            min = Math.min(min, dot);
            max = Math.max(max, dot);
        }
        
        return { min, max };
    }
    
    // 检查投影是否重叠
    static projectionsOverlap(proj1, proj2) {
        return !(proj1.max < proj2.min || proj2.max < proj1.min);
    }
    
    // 获取多边形的法线轴
    static getAxes(vertices) {
        const axes = [];
        
        for (let i = 0; i < vertices.length; i++) {
            const current = vertices[i];
            const next = vertices[(i + 1) % vertices.length];
            
            // 边向量
            const edge = {
                x: next.x - current.x,
                y: next.y - current.y
            };
            
            // 法线（垂直向量）
            const normal = {
                x: -edge.y,
                y: edge.x
            };
            
            // 归一化
            const length = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
            if (length > 0) {
                axes.push({
                    x: normal.x / length,
                    y: normal.y / length
                });
            }
        }
        
        return axes;
    }
    
    // SAT 碰撞检测
    static checkCollision(vertices1, vertices2) {
        const axes1 = this.getAxes(vertices1);
        const axes2 = this.getAxes(vertices2);
        const allAxes = [...axes1, ...axes2];
        
        for (const axis of allAxes) {
            const proj1 = this.getProjection(vertices1, axis);
            const proj2 = this.getProjection(vertices2, axis);
            
            if (!this.projectionsOverlap(proj1, proj2)) {
                // 找到分离轴，没有碰撞
                return false;
            }
        }
        
        // 所有轴都重叠，发生碰撞
        return true;
    }
}
```

### 4.3 高级碰撞检测

#### 光线投射 (Ray Casting)
```javascript
class RayCasting {
    // 光线与线段相交
    static rayLineIntersection(rayStart, rayDirection, lineStart, lineEnd) {
        const dx = lineEnd.x - lineStart.x;
        const dy = lineEnd.y - lineStart.y;
        const det = rayDirection.x * dy - rayDirection.y * dx;
        
        if (Math.abs(det) < 1e-10) {
            // 平行，没有交点
            return null;
        }
        
        const u = ((lineStart.x - rayStart.x) * dy - (lineStart.y - rayStart.y) * dx) / det;
        const v = ((lineStart.x - rayStart.x) * rayDirection.y - (lineStart.y - rayStart.y) * rayDirection.x) / det;
        
        if (u >= 0 && v >= 0 && v <= 1) {
            // 有交点
            return {
                x: rayStart.x + u * rayDirection.x,
                y: rayStart.y + u * rayDirection.y,
                distance: u
            };
        }
        
        return null;
    }
    
    // 点是否在多边形内（射线法）
    static pointInPolygon(point, vertices) {
        let intersections = 0;
        const rayDirection = { x: 1, y: 0 }; // 向右的射线
        
        for (let i = 0; i < vertices.length; i++) {
            const current = vertices[i];
            const next = vertices[(i + 1) % vertices.length];
            
            const intersection = this.rayLineIntersection(
                point, rayDirection, current, next
            );
            
            if (intersection) {
                intersections++;
            }
        }
        
        // 奇数个交点表示在多边形内
        return intersections % 2 === 1;
    }
}
```

---

## 5. 几何计算算法

### 5.1 距离计算

```javascript
class DistanceCalculations {
    // 点到点距离
    static pointToPoint(p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    // 点到线段距离
    static pointToLineSegment(point, lineStart, lineEnd) {
        const A = point.x - lineStart.x;
        const B = point.y - lineStart.y;
        const C = lineEnd.x - lineStart.x;
        const D = lineEnd.y - lineStart.y;
        
        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        
        if (lenSq === 0) {
            return Math.sqrt(A * A + B * B);
        }
        
        let param = dot / lenSq;
        param = Math.max(0, Math.min(1, param)); // 限制在线段上
        
        const xx = lineStart.x + param * C;
        const yy = lineStart.y + param * D;
        
        const dx = point.x - xx;
        const dy = point.y - yy;
        
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    // 线段到线段距离
    static lineSegmentToLineSegment(line1Start, line1End, line2Start, line2End) {
        // 检查线段是否相交
        if (this.lineSegmentsIntersect(line1Start, line1End, line2Start, line2End)) {
            return 0;
        }
        
        // 计算四个端点到对方线段的最小距离
        const distances = [
            this.pointToLineSegment(line1Start, line2Start, line2End),
            this.pointToLineSegment(line1End, line2Start, line2End),
            this.pointToLineSegment(line2Start, line1Start, line1End),
            this.pointToLineSegment(line2End, line1Start, line1End)
        ];
        
        return Math.min(...distances);
    }
    
    // 线段相交检测
    static lineSegmentsIntersect(p1, q1, p2, q2) {
        const orientation = (p, q, r) => {
            const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
            if (val === 0) return 0; // 共线
            return val > 0 ? 1 : 2;  // 顺时针或逆时针
        };
        
        const onSegment = (p, q, r) => {
            return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&
                   q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
        };
        
        const o1 = orientation(p1, q1, p2);
        const o2 = orientation(p1, q1, q2);
        const o3 = orientation(p2, q2, p1);
        const o4 = orientation(p2, q2, q1);
        
        // 一般情况
        if (o1 !== o2 && o3 !== o4) return true;
        
        // 特殊情况
        if (o1 === 0 && onSegment(p1, p2, q1)) return true;
        if (o2 === 0 && onSegment(p1, q2, q1)) return true;
        if (o3 === 0 && onSegment(p2, p1, q2)) return true;
        if (o4 === 0 && onSegment(p2, q1, q2)) return true;
        
        return false;
    }
}
```

### 5.2 面积和周长计算

```javascript
class GeometryMeasurements {
    // 多边形面积（鞋带公式）
    static polygonArea(vertices) {
        let area = 0;
        const n = vertices.length;
        
        for (let i = 0; i < n; i++) {
            const j = (i + 1) % n;
            area += vertices[i].x * vertices[j].y;
            area -= vertices[j].x * vertices[i].y;
        }
        
        return Math.abs(area) / 2;
    }
    
    // 多边形周长
    static polygonPerimeter(vertices) {
        let perimeter = 0;
        const n = vertices.length;
        
        for (let i = 0; i < n; i++) {
            const j = (i + 1) % n;
            const dx = vertices[j].x - vertices[i].x;
            const dy = vertices[j].y - vertices[i].y;
            perimeter += Math.sqrt(dx * dx + dy * dy);
        }
        
        return perimeter;
    }
    
    // 多边形重心
    static polygonCentroid(vertices) {
        let cx = 0, cy = 0;
        let area = 0;
        const n = vertices.length;
        
        for (let i = 0; i < n; i++) {
            const j = (i + 1) % n;
            const cross = vertices[i].x * vertices[j].y - vertices[j].x * vertices[i].y;
            area += cross;
            cx += (vertices[i].x + vertices[j].x) * cross;
            cy += (vertices[i].y + vertices[j].y) * cross;
        }
        
        area /= 2;
        cx /= 6 * area;
        cy /= 6 * area;
        
        return { x: cx, y: cy };
    }
}
```

### 5.3 包围盒计算

```javascript
class BoundingBox {
    constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    
    // 添加点
    addPoint(x, y) {
        this.minX = Math.min(this.minX, x);
        this.minY = Math.min(this.minY, y);
        this.maxX = Math.max(this.maxX, x);
        this.maxY = Math.max(this.maxY, y);
        return this;
    }
    
    // 添加多个点
    addPoints(points) {
        for (const point of points) {
            this.addPoint(point.x, point.y);
        }
        return this;
    }
    
    // 合并包围盒
    union(other) {
        return new BoundingBox(
            Math.min(this.minX, other.minX),
            Math.min(this.minY, other.minY),
            Math.max(this.maxX, other.maxX),
            Math.max(this.maxY, other.maxY)
        );
    }
    
    // 包围盒相交
    intersects(other) {
        return !(this.maxX < other.minX || 
                 this.minX > other.maxX ||
                 this.maxY < other.minY || 
                 this.minY > other.maxY);
    }
    
    // 包含点
    containsPoint(x, y) {
        return x >= this.minX && x <= this.maxX &&
               y >= this.minY && y <= this.maxY;
    }
    
    // 获取尺寸
    get width() {
        return this.maxX - this.minX;
    }
    
    get height() {
        return this.maxY - this.minY;
    }
    
    get center() {
        return {
            x: (this.minX + this.maxX) / 2,
            y: (this.minY + this.maxY) / 2
        };
    }
    
    // 扩展包围盒
    expand(amount) {
        return new BoundingBox(
            this.minX - amount,
            this.minY - amount,
            this.maxX + amount,
            this.maxY + amount
        );
    }
    
    // 转换为矩形
    toRect() {
        return {
            x: this.minX,
            y: this.minY,
            width: this.width,
            height: this.height
        };
    }
    
    // 从元素计算包围盒
    static fromElement(element) {
        const bbox = new BoundingBox();
        
        switch (element.type) {
            case 'rectangle':
                bbox.addPoint(element.x, element.y);
                bbox.addPoint(element.x + element.width, element.y + element.height);
                break;
                
            case 'ellipse':
                bbox.addPoint(element.x, element.y);
                bbox.addPoint(element.x + element.width, element.y + element.height);
                break;
                
            case 'line':
            case 'freedraw':
                bbox.addPoints(element.points);
                break;
        }
        
        return bbox;
    }
}
```

---

## 6. 曲线数学

### 6.1 贝塞尔曲线

```javascript
class BezierCurve {
    // 二次贝塞尔曲线
    static quadratic(t, p0, p1, p2) {
        const u = 1 - t;
        const tt = t * t;
        const uu = u * u;
        
        return {
            x: uu * p0.x + 2 * u * t * p1.x + tt * p2.x,
            y: uu * p0.y + 2 * u * t * p1.y + tt * p2.y
        };
    }
    
    // 三次贝塞尔曲线
    static cubic(t, p0, p1, p2, p3) {
        const u = 1 - t;
        const tt = t * t;
        const uu = u * u;
        const ttt = tt * t;
        const uuu = uu * u;
        
        return {
            x: uuu * p0.x + 3 * uu * t * p1.x + 3 * u * tt * p2.x + ttt * p3.x,
            y: uuu * p0.y + 3 * uu * t * p1.y + 3 * u * tt * p2.y + ttt * p3.y
        };
    }
    
    // 获取曲线上的点（通用方法）
    static getPoint(t, controlPoints) {
        const n = controlPoints.length - 1;
        const binomialCoeff = (n, k) => {
            let result = 1;
            for (let i = 1; i <= k; i++) {
                result = result * (n - i + 1) / i;
            }
            return result;
        };
        
        let x = 0, y = 0;
        for (let i = 0; i <= n; i++) {
            const coeff = binomialCoeff(n, i) * Math.pow(1 - t, n - i) * Math.pow(t, i);
            x += coeff * controlPoints[i].x;
            y += coeff * controlPoints[i].y;
        }
        
        return { x, y };
    }
    
    // 曲线长度近似计算
    static approximateLength(controlPoints, steps = 100) {
        let length = 0;
        let prevPoint = this.getPoint(0, controlPoints);
        
        for (let i = 1; i <= steps; i++) {
            const t = i / steps;
            const currentPoint = this.getPoint(t, controlPoints);
            
            const dx = currentPoint.x - prevPoint.x;
            const dy = currentPoint.y - prevPoint.y;
            length += Math.sqrt(dx * dx + dy * dy);
            
            prevPoint = currentPoint;
        }
        
        return length;
    }
    
    // 曲线细分
    static subdivide(controlPoints, t = 0.5) {
        // De Casteljau's algorithm
        const n = controlPoints.length;
        const left = [];
        const right = [];
        
        let points = [...controlPoints];
        
        for (let level = 0; level < n; level++) {
            left.push(points[0]);
            right.unshift(points[points.length - 1]);
            
            const newPoints = [];
            for (let i = 0; i < points.length - 1; i++) {
                newPoints.push({
                    x: points[i].x * (1 - t) + points[i + 1].x * t,
                    y: points[i].y * (1 - t) + points[i + 1].y * t
                });
            }
            points = newPoints;
        }
        
        return { left, right };
    }
}
```

### 6.2 样条曲线

```javascript
class SplineCurve {
    // Catmull-Rom 样条
    static catmullRom(t, p0, p1, p2, p3) {
        const t2 = t * t;
        const t3 = t2 * t;
        
        return {
            x: 0.5 * ((2 * p1.x) +
                      (-p0.x + p2.x) * t +
                      (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 +
                      (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3),
            y: 0.5 * ((2 * p1.y) +
                      (-p0.y + p2.y) * t +
                      (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 +
                      (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3)
        };
    }
    
    // 生成平滑的样条曲线路径
    static generateSmoothPath(points, tension = 0.5) {
        if (points.length < 2) return points;
        
        const smoothPoints = [];
        const steps = 20; // 每段的细分数
        
        for (let i = 0; i < points.length - 1; i++) {
            const p0 = i > 0 ? points[i - 1] : points[i];
            const p1 = points[i];
            const p2 = points[i + 1];
            const p3 = i < points.length - 2 ? points[i + 2] : points[i + 1];
            
            for (let j = 0; j < steps; j++) {
                const t = j / steps;
                const smoothPoint = this.catmullRom(t, p0, p1, p2, p3);
                smoothPoints.push(smoothPoint);
            }
        }
        
        // 添加最后一个点
        smoothPoints.push(points[points.length - 1]);
        
        return smoothPoints;
    }
}
```

---

## 7. Excalidraw 中的几何应用

### 7.1 元素边界框计算

```javascript
class ExcalidrawGeometry {
    // 计算元素的精确边界框
    static getElementBounds(element) {
        const bbox = new BoundingBox();
        
        switch (element.type) {
            case 'rectangle':
            case 'ellipse':
            case 'diamond':
                return this.getShapeBounds(element);
                
            case 'line':
            case 'arrow':
                return this.getLinearElementBounds(element);
                
            case 'text':
                return this.getTextBounds(element);
                
            case 'freedraw':
                return this.getFreeDrawBounds(element);
                
            default:
                return bbox;
        }
    }
    
    static getShapeBounds(element) {
        const bbox = new BoundingBox();
        
        if (element.angle === 0) {
            bbox.addPoint(element.x, element.y);
            bbox.addPoint(element.x + element.width, element.y + element.height);
        } else {
            // 旋转后的边界框
            const center = {
                x: element.x + element.width / 2,
                y: element.y + element.height / 2
            };
            
            const corners = [
                { x: element.x, y: element.y },
                { x: element.x + element.width, y: element.y },
                { x: element.x + element.width, y: element.y + element.height },
                { x: element.x, y: element.y + element.height }
            ];
            
            for (const corner of corners) {
                const rotated = rotateAroundPoint(corner, center, element.angle);
                bbox.addPoint(rotated.x, rotated.y);
            }
        }
        
        return bbox;
    }
    
    static getLinearElementBounds(element) {
        const bbox = new BoundingBox();
        
        if (element.points && element.points.length > 0) {
            for (const point of element.points) {
                bbox.addPoint(element.x + point[0], element.y + point[1]);
            }
        }
        
        return bbox;
    }
    
    // 元素碰撞检测
    static hitTestElement(element, x, y, tolerance = 5) {
        switch (element.type) {
            case 'rectangle':
                return this.hitTestRectangle(element, x, y);
                
            case 'ellipse':
                return this.hitTestEllipse(element, x, y);
                
            case 'line':
            case 'arrow':
                return this.hitTestLine(element, x, y, tolerance);
                
            case 'text':
                return this.hitTestText(element, x, y);
                
            case 'freedraw':
                return this.hitTestFreeDraw(element, x, y, tolerance);
        }
        
        return false;
    }
    
    static hitTestRectangle(element, x, y) {
        if (element.angle === 0) {
            return pointInRect(x, y, element);
        } else {
            return pointInRotatedRect(x, y, element);
        }
    }
    
    static hitTestEllipse(element, x, y) {
        const centerX = element.x + element.width / 2;
        const centerY = element.y + element.height / 2;
        const radiusX = element.width / 2;
        const radiusY = element.height / 2;
        
        if (element.angle === 0) {
            return pointInEllipse(x, y, {
                centerX, centerY, radiusX, radiusY
            });
        } else {
            return pointInRotatedEllipse(x, y, {
                centerX, centerY, radiusX, radiusY,
                angle: element.angle
            });
        }
    }
    
    static hitTestLine(element, x, y, tolerance) {
        if (!element.points || element.points.length < 2) {
            return false;
        }
        
        for (let i = 0; i < element.points.length - 1; i++) {
            const p1 = element.points[i];
            const p2 = element.points[i + 1];
            
            const distance = pointToLineDistance(
                x, y,
                element.x + p1[0], element.y + p1[1],
                element.x + p2[0], element.y + p2[1]
            );
            
            if (distance <= tolerance) {
                return true;
            }
        }
        
        return false;
    }
}
```

### 7.2 多选框选择算法

```javascript
class SelectionBox {
    constructor(startX, startY) {
        this.startX = startX;
        this.startY = startY;
        this.endX = startX;
        this.endY = startY;
    }
    
    update(endX, endY) {
        this.endX = endX;
        this.endY = endY;
    }
    
    getBounds() {
        return {
            x: Math.min(this.startX, this.endX),
            y: Math.min(this.startY, this.endY),
            width: Math.abs(this.endX - this.startX),
            height: Math.abs(this.endY - this.startY)
        };
    }
    
    // 检查元素是否与选择框相交
    intersectsElement(element) {
        const selectionBounds = this.getBounds();
        const elementBounds = ExcalidrawGeometry.getElementBounds(element);
        
        return selectionBounds.x < elementBounds.maxX &&
               selectionBounds.x + selectionBounds.width > elementBounds.minX &&
               selectionBounds.y < elementBounds.maxY &&
               selectionBounds.y + selectionBounds.height > elementBounds.minY;
    }
    
    // 检查元素是否完全在选择框内
    containsElement(element) {
        const selectionBounds = this.getBounds();
        const elementBounds = ExcalidrawGeometry.getElementBounds(element);
        
        return selectionBounds.x <= elementBounds.minX &&
               selectionBounds.y <= elementBounds.minY &&
               selectionBounds.x + selectionBounds.width >= elementBounds.maxX &&
               selectionBounds.y + selectionBounds.height >= elementBounds.maxY;
    }
}
```

---

## 8. 实战：几何计算器

让我们构建一个几何计算器来应用这些数学知识：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>几何计算器</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .calculator {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .controls {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
        }
        
        .canvas-container {
            position: relative;
        }
        
        canvas {
            border: 1px solid #ccc;
            cursor: crosshair;
        }
        
        .result {
            margin-top: 10px;
            padding: 10px;
            background: #e7f3ff;
            border-radius: 4px;
        }
        
        button {
            margin: 5px;
            padding: 8px 16px;
        }
        
        button.active {
            background: #007bff;
            color: white;
        }
    </style>
</head>
<body>
    <h1>几何计算器</h1>
    
    <div class="calculator">
        <div class="controls">
            <h3>工具</h3>
            <button id="point" class="active">点</button>
            <button id="line">线段</button>
            <button id="rectangle">矩形</button>
            <button id="circle">圆形</button>
            <button id="polygon">多边形</button>
            <button id="clear">清空</button>
            
            <h3>测量</h3>
            <button id="distance">距离</button>
            <button id="area">面积</button>
            <button id="angle">角度</button>
            <button id="intersection">相交检测</button>
            
            <div class="result" id="result">
                点击工具开始绘制几何图形
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="canvas" width="600" height="400"></canvas>
        </div>
    </div>

    <script>
        class GeometryCalculator {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                
                this.shapes = [];
                this.currentTool = 'point';
                this.tempShape = null;
                this.isDrawing = false;
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                // 工具切换
                document.querySelectorAll('button[id]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        if (['point', 'line', 'rectangle', 'circle', 'polygon'].includes(e.target.id)) {
                            this.setTool(e.target.id);
                        } else {
                            this.handleAction(e.target.id);
                        }
                    });
                });
                
                // Canvas 事件
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.canvas.addEventListener('dblclick', this.handleDoubleClick.bind(this));
            }
            
            setTool(tool) {
                this.currentTool = tool;
                document.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                document.getElementById(tool).classList.add('active');
                this.updateResult(`工具：${tool}`);
            }
            
            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            handleMouseDown(e) {
                const pos = this.getMousePos(e);
                this.isDrawing = true;
                
                switch (this.currentTool) {
                    case 'point':
                        this.addPoint(pos);
                        break;
                    case 'line':
                        this.startLine(pos);
                        break;
                    case 'rectangle':
                        this.startRectangle(pos);
                        break;
                    case 'circle':
                        this.startCircle(pos);
                        break;
                    case 'polygon':
                        this.addPolygonPoint(pos);
                        break;
                }
            }
            
            handleMouseMove(e) {
                if (!this.isDrawing || !this.tempShape) return;
                
                const pos = this.getMousePos(e);
                
                switch (this.currentTool) {
                    case 'line':
                        this.tempShape.end = pos;
                        break;
                    case 'rectangle':
                        this.tempShape.width = pos.x - this.tempShape.x;
                        this.tempShape.height = pos.y - this.tempShape.y;
                        break;
                    case 'circle':
                        const dx = pos.x - this.tempShape.center.x;
                        const dy = pos.y - this.tempShape.center.y;
                        this.tempShape.radius = Math.sqrt(dx * dx + dy * dy);
                        break;
                }
                
                this.render();
            }
            
            handleMouseUp(e) {
                if (!this.tempShape) return;
                
                switch (this.currentTool) {
                    case 'line':
                    case 'rectangle':
                    case 'circle':
                        this.shapes.push(this.tempShape);
                        this.tempShape = null;
                        break;
                }
                
                this.isDrawing = false;
                this.render();
            }
            
            handleDoubleClick(e) {
                if (this.currentTool === 'polygon' && this.tempShape) {
                    this.shapes.push(this.tempShape);
                    this.tempShape = null;
                    this.render();
                }
            }
            
            addPoint(pos) {
                this.shapes.push({
                    type: 'point',
                    x: pos.x,
                    y: pos.y
                });
                this.render();
                this.updateResult(`点: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)})`);
            }
            
            startLine(pos) {
                this.tempShape = {
                    type: 'line',
                    start: pos,
                    end: pos
                };
            }
            
            startRectangle(pos) {
                this.tempShape = {
                    type: 'rectangle',
                    x: pos.x,
                    y: pos.y,
                    width: 0,
                    height: 0
                };
            }
            
            startCircle(pos) {
                this.tempShape = {
                    type: 'circle',
                    center: pos,
                    radius: 0
                };
            }
            
            addPolygonPoint(pos) {
                if (!this.tempShape) {
                    this.tempShape = {
                        type: 'polygon',
                        points: [pos]
                    };
                } else if (this.tempShape.type === 'polygon') {
                    this.tempShape.points.push(pos);
                }
                this.render();
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // 绘制已完成的图形
                for (const shape of this.shapes) {
                    this.drawShape(shape, '#000000');
                }
                
                // 绘制临时图形
                if (this.tempShape) {
                    this.drawShape(this.tempShape, '#ff0000');
                }
            }
            
            drawShape(shape, color) {
                this.ctx.strokeStyle = color;
                this.ctx.fillStyle = color + '20';
                this.ctx.lineWidth = 2;
                
                switch (shape.type) {
                    case 'point':
                        this.ctx.beginPath();
                        this.ctx.arc(shape.x, shape.y, 3, 0, 2 * Math.PI);
                        this.ctx.fill();
                        break;
                        
                    case 'line':
                        this.ctx.beginPath();
                        this.ctx.moveTo(shape.start.x, shape.start.y);
                        this.ctx.lineTo(shape.end.x, shape.end.y);
                        this.ctx.stroke();
                        break;
                        
                    case 'rectangle':
                        this.ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
                        this.ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
                        break;
                        
                    case 'circle':
                        this.ctx.beginPath();
                        this.ctx.arc(shape.center.x, shape.center.y, shape.radius, 0, 2 * Math.PI);
                        this.ctx.stroke();
                        this.ctx.fill();
                        break;
                        
                    case 'polygon':
                        if (shape.points.length > 1) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(shape.points[0].x, shape.points[0].y);
                            for (let i = 1; i < shape.points.length; i++) {
                                this.ctx.lineTo(shape.points[i].x, shape.points[i].y);
                            }
                            if (this.shapes.includes(shape)) {
                                this.ctx.closePath();
                                this.ctx.fill();
                            }
                            this.ctx.stroke();
                        }
                        break;
                }
            }
            
            handleAction(action) {
                switch (action) {
                    case 'clear':
                        this.shapes = [];
                        this.tempShape = null;
                        this.render();
                        break;
                    case 'distance':
                        this.calculateDistance();
                        break;
                    case 'area':
                        this.calculateArea();
                        break;
                    case 'intersection':
                        this.checkIntersections();
                        break;
                }
            }
            
            calculateDistance() {
                const lines = this.shapes.filter(s => s.type === 'line');
                const points = this.shapes.filter(s => s.type === 'point');
                
                let result = '距离计算:\n';
                
                if (lines.length > 0) {
                    lines.forEach((line, i) => {
                        const dx = line.end.x - line.start.x;
                        const dy = line.end.y - line.start.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        result += `线段 ${i + 1}: ${length.toFixed(2)}px\n`;
                    });
                }
                
                if (points.length >= 2) {
                    for (let i = 0; i < points.length - 1; i++) {
                        for (let j = i + 1; j < points.length; j++) {
                            const dist = DistanceCalculations.pointToPoint(points[i], points[j]);
                            result += `点 ${i + 1} 到点 ${j + 1}: ${dist.toFixed(2)}px\n`;
                        }
                    }
                }
                
                this.updateResult(result);
            }
            
            calculateArea() {
                let result = '面积计算:\n';
                
                this.shapes.forEach((shape, i) => {
                    let area = 0;
                    
                    switch (shape.type) {
                        case 'rectangle':
                            area = Math.abs(shape.width * shape.height);
                            result += `矩形 ${i + 1}: ${area.toFixed(2)}px²\n`;
                            break;
                        case 'circle':
                            area = Math.PI * shape.radius * shape.radius;
                            result += `圆形 ${i + 1}: ${area.toFixed(2)}px²\n`;
                            break;
                        case 'polygon':
                            if (shape.points.length >= 3) {
                                area = GeometryMeasurements.polygonArea(shape.points);
                                result += `多边形 ${i + 1}: ${area.toFixed(2)}px²\n`;
                            }
                            break;
                    }
                });
                
                this.updateResult(result);
            }
            
            updateResult(text) {
                document.getElementById('result').textContent = text;
            }
        }
        
        // 初始化计算器
        const calculator = new GeometryCalculator('canvas');
        
        // 添加之前定义的工具类...
        // (Vector2, Transform2D, DistanceCalculations, GeometryMeasurements 等)
    </script>
</body>
</html>
```

---

## 🎯 本章总结

通过本章学习，你应该掌握了：

✅ **数学基础**
- 坐标系统和变换
- 向量运算的完整实现
- 几何变换矩阵的使用

✅ **碰撞检测算法**
- 点与各种图形的碰撞检测
- 图形间的碰撞检测
- SAT 分离轴定理的应用

✅ **几何计算**
- 距离、面积、周长计算
- 包围盒计算和优化
- 曲线数学（贝塞尔曲线、样条曲线）

✅ **实际应用**
- Excalidraw 中的几何算法
- 多选框选择算法
- 完整的几何计算器项目

这些数学基础将为后续章节的事件系统、渲染引擎等高级功能提供坚实支撑。下一章我们将学习如何构建强大的事件交互系统。