# æ•°å­¦å‡ ä½•åŸºç¡€ä¸ç®—æ³•
## å›¾å½¢ç¼–è¾‘å™¨çš„æ•°å­¦å†…æ ¸

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œä½ å°†å®Œå…¨æŒæ¡ï¼š
- 2D å›¾å½¢å­¦çš„å®Œæ•´æ•°å­¦åŸºç¡€
- å‘é‡è¿ç®—ä¸å‡ ä½•å˜æ¢çš„å®é™…åº”ç”¨
- ç¢°æ’æ£€æµ‹çš„å„ç§ç®—æ³•å®ç°
- å‡ ä½•å›¾å½¢çš„æ•°å­¦å»ºæ¨¡å’Œè®¡ç®—
- Excalidraw ä¸­å‡ ä½•ç®—æ³•çš„å®é™…è¿ç”¨

---

## 1. åæ ‡ç³»ç»Ÿä¸åŸºç¡€æ¦‚å¿µ

### 1.1 åæ ‡ç³»ç»Ÿçš„ç†è§£

åœ¨å›¾å½¢ç¼–ç¨‹ä¸­ï¼Œæˆ‘ä»¬éœ€è¦å¤„ç†å¤šä¸ªåæ ‡ç³»ç»Ÿï¼š

```javascript
// 1. ä¸–ç•Œåæ ‡ç³»ï¼ˆWorld Coordinatesï¼‰
// - å›¾å½¢çš„ç»å¯¹ä½ç½®
// - ä¸å—è§†å£å½±å“
const worldPoint = { x: 1000, y: 500 };

// 2. è§†å£åæ ‡ç³»ï¼ˆViewport Coordinatesï¼‰  
// - ç”¨æˆ·çœ‹åˆ°çš„åæ ‡
// - å—ç¼©æ”¾å’Œå¹³ç§»å½±å“
const viewportPoint = worldToViewport(worldPoint, viewport);

// 3. å±å¹•åæ ‡ç³»ï¼ˆScreen Coordinatesï¼‰
// - Canvas ä¸Šçš„åƒç´ ä½ç½®
// - å—è®¾å¤‡åƒç´ æ¯”å½±å“
const screenPoint = viewportToScreen(viewportPoint, canvas);
```

### 1.2 åæ ‡å˜æ¢çš„å®ç°

```javascript
class CoordinateSystem {
    constructor() {
        this.zoom = 1;
        this.offsetX = 0;
        this.offsetY = 0;
    }
    
    // ä¸–ç•Œåæ ‡ â†’ å±å¹•åæ ‡
    worldToScreen(worldX, worldY) {
        return {
            x: (worldX + this.offsetX) * this.zoom,
            y: (worldY + this.offsetY) * this.zoom
        };
    }
    
    // å±å¹•åæ ‡ â†’ ä¸–ç•Œåæ ‡
    screenToWorld(screenX, screenY) {
        return {
            x: screenX / this.zoom - this.offsetX,
            y: screenY / this.zoom - this.offsetY
        };
    }
    
    // è®¾ç½®è§†å£
    setViewport(centerX, centerY, zoom) {
        this.zoom = zoom;
        this.offsetX = centerX;
        this.offsetY = centerY;
    }
}
```

---

## 2. å‘é‡æ•°å­¦è¯¦è§£

### 2.1 å‘é‡åŸºç¡€æ“ä½œ

å‘é‡æ˜¯å›¾å½¢å­¦çš„åŸºç¡€ï¼Œè®©æˆ‘ä»¬ä»æœ€åŸºæœ¬çš„æ“ä½œå¼€å§‹ï¼š

```javascript
class Vector2 {
    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
    }
    
    // å‘é‡åŠ æ³•
    add(other) {
        return new Vector2(this.x + other.x, this.y + other.y);
    }
    
    // å‘é‡å‡æ³•
    subtract(other) {
        return new Vector2(this.x - other.x, this.y - other.y);
    }
    
    // æ ‡é‡ä¹˜æ³•
    multiply(scalar) {
        return new Vector2(this.x * scalar, this.y * scalar);
    }
    
    // å‘é‡é•¿åº¦ï¼ˆæ¨¡ï¼‰
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    
    // å‘é‡é•¿åº¦çš„å¹³æ–¹ï¼ˆé¿å…å¼€æ–¹è¿ç®—ï¼‰
    lengthSquared() {
        return this.x * this.x + this.y * this.y;
    }
    
    // å•ä½å‘é‡ï¼ˆå½’ä¸€åŒ–ï¼‰
    normalize() {
        const len = this.length();
        if (len === 0) return new Vector2(0, 0);
        return new Vector2(this.x / len, this.y / len);
    }
    
    // ç‚¹ç§¯ï¼ˆæ•°é‡ç§¯ï¼‰
    dot(other) {
        return this.x * other.x + this.y * other.y;
    }
    
    // å‰ç§¯ï¼ˆå‘é‡ç§¯çš„ z åˆ†é‡ï¼‰
    cross(other) {
        return this.x * other.y - this.y * other.x;
    }
    
    // ä¸¤å‘é‡ä¹‹é—´çš„è§’åº¦
    angleTo(other) {
        const dot = this.dot(other);
        const lengths = this.length() * other.length();
        if (lengths === 0) return 0;
        return Math.acos(Math.max(-1, Math.min(1, dot / lengths)));
    }
    
    // å‘é‡æ—‹è½¬
    rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return new Vector2(
            this.x * cos - this.y * sin,
            this.x * sin + this.y * cos
        );
    }
    
    // å‚ç›´å‘é‡
    perpendicular() {
        return new Vector2(-this.y, this.x);
    }
    
    // å‘é‡æ’å€¼
    lerp(other, t) {
        return new Vector2(
            this.x + (other.x - this.x) * t,
            this.y + (other.y - this.y) * t
        );
    }
    
    // å‘é‡æŠ•å½±
    project(onto) {
        const dot = this.dot(onto);
        const ontoLengthSq = onto.lengthSquared();
        if (ontoLengthSq === 0) return new Vector2(0, 0);
        
        const scalar = dot / ontoLengthSq;
        return onto.multiply(scalar);
    }
    
    // å‘é‡åå°„
    reflect(normal) {
        const dot = this.dot(normal);
        return this.subtract(normal.multiply(2 * dot));
    }
    
    // å¤åˆ¶å‘é‡
    clone() {
        return new Vector2(this.x, this.y);
    }
    
    // å‘é‡ç›¸ç­‰åˆ¤æ–­
    equals(other, tolerance = 0.0001) {
        return Math.abs(this.x - other.x) < tolerance &&
               Math.abs(this.y - other.y) < tolerance;
    }
    
    toString() {
        return `Vector2(${this.x.toFixed(2)}, ${this.y.toFixed(2)})`;
    }
}
```

### 2.2 å‘é‡çš„å®é™…åº”ç”¨

```javascript
// åº”ç”¨ç¤ºä¾‹ï¼šè®¡ç®—ç‰©ä½“è¿åŠ¨
class MovableObject {
    constructor(x, y) {
        this.position = new Vector2(x, y);
        this.velocity = new Vector2(0, 0);
        this.acceleration = new Vector2(0, 0);
    }
    
    // ç‰©ç†æ›´æ–°
    update(deltaTime) {
        // é€Ÿåº¦ = é€Ÿåº¦ + åŠ é€Ÿåº¦ * æ—¶é—´
        this.velocity = this.velocity.add(
            this.acceleration.multiply(deltaTime)
        );
        
        // ä½ç½® = ä½ç½® + é€Ÿåº¦ * æ—¶é—´
        this.position = this.position.add(
            this.velocity.multiply(deltaTime)
        );
    }
    
    // åº”ç”¨åŠ›ï¼ˆåŠ é€Ÿåº¦ï¼‰
    applyForce(force) {
        this.acceleration = this.acceleration.add(force);
    }
    
    // æœå‘ç›®æ ‡ç§»åŠ¨
    seekTarget(target, speed) {
        const direction = target.subtract(this.position).normalize();
        this.velocity = direction.multiply(speed);
    }
}
```

---

## 3. å‡ ä½•å˜æ¢çŸ©é˜µ

### 3.1 2D å˜æ¢çŸ©é˜µè¯¦è§£

2D å˜æ¢ä½¿ç”¨ 3x3 é½æ¬¡åæ ‡çŸ©é˜µï¼š

```
[x']   [a c e] [x]
[y'] = [b d f] [y]
[1 ]   [0 0 1] [1]
```

å…¶ä¸­ï¼š
- a, d: ç¼©æ”¾
- b, c: å€¾æ–œå’Œæ—‹è½¬
- e, f: å¹³ç§»

```javascript
class Transform2D {
    constructor(a = 1, b = 0, c = 0, d = 1, e = 0, f = 0) {
        this.a = a; this.b = b; this.c = c;
        this.d = d; this.e = e; this.f = f;
    }
    
    // åˆ›å»ºå•ä½çŸ©é˜µ
    static identity() {
        return new Transform2D();
    }
    
    // åˆ›å»ºå¹³ç§»çŸ©é˜µ
    static translation(x, y) {
        return new Transform2D(1, 0, 0, 1, x, y);
    }
    
    // åˆ›å»ºæ—‹è½¬çŸ©é˜µ
    static rotation(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return new Transform2D(cos, sin, -sin, cos, 0, 0);
    }
    
    // åˆ›å»ºç¼©æ”¾çŸ©é˜µ
    static scale(sx, sy = sx) {
        return new Transform2D(sx, 0, 0, sy, 0, 0);
    }
    
    // åˆ›å»ºå€¾æ–œçŸ©é˜µ
    static skew(skewX, skewY) {
        return new Transform2D(
            1, Math.tan(skewY),
            Math.tan(skewX), 1,
            0, 0
        );
    }
    
    // çŸ©é˜µä¹˜æ³•
    multiply(other) {
        return new Transform2D(
            this.a * other.a + this.c * other.b,
            this.b * other.a + this.d * other.b,
            this.a * other.c + this.c * other.d,
            this.b * other.c + this.d * other.d,
            this.a * other.e + this.c * other.f + this.e,
            this.b * other.e + this.d * other.f + this.f
        );
    }
    
    // å˜æ¢ç‚¹
    transformPoint(x, y) {
        return {
            x: this.a * x + this.c * y + this.e,
            y: this.b * x + this.d * y + this.f
        };
    }
    
    // å˜æ¢å‘é‡ï¼ˆå¿½ç•¥å¹³ç§»ï¼‰
    transformVector(x, y) {
        return {
            x: this.a * x + this.c * y,
            y: this.b * x + this.d * y
        };
    }
    
    // é€†çŸ©é˜µ
    inverse() {
        const det = this.a * this.d - this.b * this.c;
        if (Math.abs(det) < 1e-10) {
            throw new Error('Matrix is not invertible');
        }
        
        const invDet = 1 / det;
        return new Transform2D(
            this.d * invDet,
            -this.b * invDet,
            -this.c * invDet,
            this.a * invDet,
            (this.c * this.f - this.d * this.e) * invDet,
            (this.b * this.e - this.a * this.f) * invDet
        );
    }
    
    // è·å–å˜æ¢çš„åˆ†è§£ç»“æœ
    decompose() {
        const a = this.a, b = this.b, c = this.c, d = this.d;
        const e = this.e, f = this.f;
        
        // å¹³ç§»
        const translation = { x: e, y: f };
        
        // ç¼©æ”¾
        const scaleX = Math.sqrt(a * a + b * b);
        const scaleY = Math.sqrt(c * c + d * d);
        
        // æ—‹è½¬
        const rotation = Math.atan2(b, a);
        
        // å€¾æ–œ
        const skewX = Math.atan2(c, d) - rotation;
        
        return {
            translation,
            scale: { x: scaleX, y: scaleY },
            rotation,
            skew: { x: skewX, y: 0 }
        };
    }
    
    // åº”ç”¨åˆ° Canvas
    applyToCanvas(ctx) {
        ctx.setTransform(this.a, this.b, this.c, this.d, this.e, this.f);
    }
    
    toString() {
        return `Transform2D(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.e}, ${this.f})`;
    }
}
```

### 3.2 å¤åˆå˜æ¢çš„å¤„ç†

```javascript
// å›´ç»•æŒ‡å®šç‚¹æ—‹è½¬
function rotateAroundPoint(point, center, angle) {
    const transform = Transform2D.translation(-center.x, -center.y)
        .multiply(Transform2D.rotation(angle))
        .multiply(Transform2D.translation(center.x, center.y));
    
    return transform.transformPoint(point.x, point.y);
}

// åˆ›å»ºä»ä¸€ä¸ªçŸ©å½¢åˆ°å¦ä¸€ä¸ªçŸ©å½¢çš„å˜æ¢
function createRectToRectTransform(fromRect, toRect) {
    // è®¡ç®—ç¼©æ”¾
    const scaleX = toRect.width / fromRect.width;
    const scaleY = toRect.height / fromRect.height;
    
    // è®¡ç®—å¹³ç§»
    const translateX = toRect.x - fromRect.x * scaleX;
    const translateY = toRect.y - fromRect.y * scaleY;
    
    return Transform2D.scale(scaleX, scaleY)
        .multiply(Transform2D.translation(translateX, translateY));
}
```

---

## 4. ç¢°æ’æ£€æµ‹ç®—æ³•å¤§å…¨

### 4.1 ç‚¹ä¸å›¾å½¢çš„ç¢°æ’æ£€æµ‹

#### ç‚¹ä¸çŸ©å½¢
```javascript
function pointInRect(px, py, rect) {
    return px >= rect.x && 
           px <= rect.x + rect.width &&
           py >= rect.y && 
           py <= rect.y + rect.height;
}

// è€ƒè™‘æ—‹è½¬çš„çŸ©å½¢
function pointInRotatedRect(px, py, rect) {
    if (rect.angle === 0) {
        return pointInRect(px, py, rect);
    }
    
    // å°†ç‚¹è½¬æ¢åˆ°çŸ©å½¢çš„æœ¬åœ°åæ ‡ç³»
    const center = {
        x: rect.x + rect.width / 2,
        y: rect.y + rect.height / 2
    };
    
    const cos = Math.cos(-rect.angle);
    const sin = Math.sin(-rect.angle);
    
    const dx = px - center.x;
    const dy = py - center.y;
    
    const localX = dx * cos - dy * sin;
    const localY = dx * sin + dy * cos;
    
    return localX >= -rect.width / 2 &&
           localX <= rect.width / 2 &&
           localY >= -rect.height / 2 &&
           localY <= rect.height / 2;
}
```

#### ç‚¹ä¸åœ†å½¢
```javascript
function pointInCircle(px, py, circle) {
    const dx = px - circle.x;
    const dy = py - circle.y;
    const distanceSquared = dx * dx + dy * dy;
    return distanceSquared <= circle.radius * circle.radius;
}
```

#### ç‚¹ä¸æ¤­åœ†
```javascript
function pointInEllipse(px, py, ellipse) {
    const dx = px - ellipse.centerX;
    const dy = py - ellipse.centerY;
    
    // æ¤­åœ†æ–¹ç¨‹ï¼š(x/a)Â² + (y/b)Â² <= 1
    const normalizedX = dx / ellipse.radiusX;
    const normalizedY = dy / ellipse.radiusY;
    
    return normalizedX * normalizedX + normalizedY * normalizedY <= 1;
}

// è€ƒè™‘æ—‹è½¬çš„æ¤­åœ†
function pointInRotatedEllipse(px, py, ellipse) {
    if (ellipse.angle === 0) {
        return pointInEllipse(px, py, ellipse);
    }
    
    // å°†ç‚¹è½¬æ¢åˆ°æ¤­åœ†çš„æœ¬åœ°åæ ‡ç³»
    const cos = Math.cos(-ellipse.angle);
    const sin = Math.sin(-ellipse.angle);
    
    const dx = px - ellipse.centerX;
    const dy = py - ellipse.centerY;
    
    const localX = dx * cos - dy * sin;
    const localY = dx * sin + dy * cos;
    
    const normalizedX = localX / ellipse.radiusX;
    const normalizedY = localY / ellipse.radiusY;
    
    return normalizedX * normalizedX + normalizedY * normalizedY <= 1;
}
```

#### ç‚¹ä¸çº¿æ¡
```javascript
function pointToLineDistance(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    
    if (lenSq === 0) {
        // çº¿æ®µé€€åŒ–ä¸ºç‚¹
        return Math.sqrt(A * A + B * B);
    }
    
    let param = dot / lenSq;
    
    let xx, yy;
    
    if (param < 0) {
        xx = x1;
        yy = y1;
    } else if (param > 1) {
        xx = x2;
        yy = y2;
    } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
    }
    
    const dx = px - xx;
    const dy = py - yy;
    
    return Math.sqrt(dx * dx + dy * dy);
}

function pointNearLine(px, py, x1, y1, x2, y2, tolerance = 5) {
    return pointToLineDistance(px, py, x1, y1, x2, y2) <= tolerance;
}
```

### 4.2 å›¾å½¢ä¸å›¾å½¢çš„ç¢°æ’æ£€æµ‹

#### AABB (è½´å¯¹é½åŒ…å›´ç›’) ç¢°æ’
```javascript
function aabbCollision(rect1, rect2) {
    return !(rect1.x > rect2.x + rect2.width ||
             rect1.x + rect1.width < rect2.x ||
             rect1.y > rect2.y + rect2.height ||
             rect1.y + rect1.height < rect2.y);
}
```

#### åœ†å½¢ç¢°æ’
```javascript
function circleCollision(circle1, circle2) {
    const dx = circle2.x - circle1.x;
    const dy = circle2.y - circle1.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance <= circle1.radius + circle2.radius;
}
```

#### åˆ†ç¦»è½´å®šç† (SAT) - å‡¸å¤šè¾¹å½¢ç¢°æ’
```javascript
class SATCollision {
    // è·å–å¤šè¾¹å½¢åœ¨è½´ä¸Šçš„æŠ•å½±
    static getProjection(vertices, axis) {
        let min = Infinity;
        let max = -Infinity;
        
        for (const vertex of vertices) {
            const dot = vertex.x * axis.x + vertex.y * axis.y;
            min = Math.min(min, dot);
            max = Math.max(max, dot);
        }
        
        return { min, max };
    }
    
    // æ£€æŸ¥æŠ•å½±æ˜¯å¦é‡å 
    static projectionsOverlap(proj1, proj2) {
        return !(proj1.max < proj2.min || proj2.max < proj1.min);
    }
    
    // è·å–å¤šè¾¹å½¢çš„æ³•çº¿è½´
    static getAxes(vertices) {
        const axes = [];
        
        for (let i = 0; i < vertices.length; i++) {
            const current = vertices[i];
            const next = vertices[(i + 1) % vertices.length];
            
            // è¾¹å‘é‡
            const edge = {
                x: next.x - current.x,
                y: next.y - current.y
            };
            
            // æ³•çº¿ï¼ˆå‚ç›´å‘é‡ï¼‰
            const normal = {
                x: -edge.y,
                y: edge.x
            };
            
            // å½’ä¸€åŒ–
            const length = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
            if (length > 0) {
                axes.push({
                    x: normal.x / length,
                    y: normal.y / length
                });
            }
        }
        
        return axes;
    }
    
    // SAT ç¢°æ’æ£€æµ‹
    static checkCollision(vertices1, vertices2) {
        const axes1 = this.getAxes(vertices1);
        const axes2 = this.getAxes(vertices2);
        const allAxes = [...axes1, ...axes2];
        
        for (const axis of allAxes) {
            const proj1 = this.getProjection(vertices1, axis);
            const proj2 = this.getProjection(vertices2, axis);
            
            if (!this.projectionsOverlap(proj1, proj2)) {
                // æ‰¾åˆ°åˆ†ç¦»è½´ï¼Œæ²¡æœ‰ç¢°æ’
                return false;
            }
        }
        
        // æ‰€æœ‰è½´éƒ½é‡å ï¼Œå‘ç”Ÿç¢°æ’
        return true;
    }
}
```

### 4.3 é«˜çº§ç¢°æ’æ£€æµ‹

#### å…‰çº¿æŠ•å°„ (Ray Casting)
```javascript
class RayCasting {
    // å…‰çº¿ä¸çº¿æ®µç›¸äº¤
    static rayLineIntersection(rayStart, rayDirection, lineStart, lineEnd) {
        const dx = lineEnd.x - lineStart.x;
        const dy = lineEnd.y - lineStart.y;
        const det = rayDirection.x * dy - rayDirection.y * dx;
        
        if (Math.abs(det) < 1e-10) {
            // å¹³è¡Œï¼Œæ²¡æœ‰äº¤ç‚¹
            return null;
        }
        
        const u = ((lineStart.x - rayStart.x) * dy - (lineStart.y - rayStart.y) * dx) / det;
        const v = ((lineStart.x - rayStart.x) * rayDirection.y - (lineStart.y - rayStart.y) * rayDirection.x) / det;
        
        if (u >= 0 && v >= 0 && v <= 1) {
            // æœ‰äº¤ç‚¹
            return {
                x: rayStart.x + u * rayDirection.x,
                y: rayStart.y + u * rayDirection.y,
                distance: u
            };
        }
        
        return null;
    }
    
    // ç‚¹æ˜¯å¦åœ¨å¤šè¾¹å½¢å†…ï¼ˆå°„çº¿æ³•ï¼‰
    static pointInPolygon(point, vertices) {
        let intersections = 0;
        const rayDirection = { x: 1, y: 0 }; // å‘å³çš„å°„çº¿
        
        for (let i = 0; i < vertices.length; i++) {
            const current = vertices[i];
            const next = vertices[(i + 1) % vertices.length];
            
            const intersection = this.rayLineIntersection(
                point, rayDirection, current, next
            );
            
            if (intersection) {
                intersections++;
            }
        }
        
        // å¥‡æ•°ä¸ªäº¤ç‚¹è¡¨ç¤ºåœ¨å¤šè¾¹å½¢å†…
        return intersections % 2 === 1;
    }
}
```

---

## 5. å‡ ä½•è®¡ç®—ç®—æ³•

### 5.1 è·ç¦»è®¡ç®—

```javascript
class DistanceCalculations {
    // ç‚¹åˆ°ç‚¹è·ç¦»
    static pointToPoint(p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    // ç‚¹åˆ°çº¿æ®µè·ç¦»
    static pointToLineSegment(point, lineStart, lineEnd) {
        const A = point.x - lineStart.x;
        const B = point.y - lineStart.y;
        const C = lineEnd.x - lineStart.x;
        const D = lineEnd.y - lineStart.y;
        
        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        
        if (lenSq === 0) {
            return Math.sqrt(A * A + B * B);
        }
        
        let param = dot / lenSq;
        param = Math.max(0, Math.min(1, param)); // é™åˆ¶åœ¨çº¿æ®µä¸Š
        
        const xx = lineStart.x + param * C;
        const yy = lineStart.y + param * D;
        
        const dx = point.x - xx;
        const dy = point.y - yy;
        
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    // çº¿æ®µåˆ°çº¿æ®µè·ç¦»
    static lineSegmentToLineSegment(line1Start, line1End, line2Start, line2End) {
        // æ£€æŸ¥çº¿æ®µæ˜¯å¦ç›¸äº¤
        if (this.lineSegmentsIntersect(line1Start, line1End, line2Start, line2End)) {
            return 0;
        }
        
        // è®¡ç®—å››ä¸ªç«¯ç‚¹åˆ°å¯¹æ–¹çº¿æ®µçš„æœ€å°è·ç¦»
        const distances = [
            this.pointToLineSegment(line1Start, line2Start, line2End),
            this.pointToLineSegment(line1End, line2Start, line2End),
            this.pointToLineSegment(line2Start, line1Start, line1End),
            this.pointToLineSegment(line2End, line1Start, line1End)
        ];
        
        return Math.min(...distances);
    }
    
    // çº¿æ®µç›¸äº¤æ£€æµ‹
    static lineSegmentsIntersect(p1, q1, p2, q2) {
        const orientation = (p, q, r) => {
            const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
            if (val === 0) return 0; // å…±çº¿
            return val > 0 ? 1 : 2;  // é¡ºæ—¶é’ˆæˆ–é€†æ—¶é’ˆ
        };
        
        const onSegment = (p, q, r) => {
            return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&
                   q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
        };
        
        const o1 = orientation(p1, q1, p2);
        const o2 = orientation(p1, q1, q2);
        const o3 = orientation(p2, q2, p1);
        const o4 = orientation(p2, q2, q1);
        
        // ä¸€èˆ¬æƒ…å†µ
        if (o1 !== o2 && o3 !== o4) return true;
        
        // ç‰¹æ®Šæƒ…å†µ
        if (o1 === 0 && onSegment(p1, p2, q1)) return true;
        if (o2 === 0 && onSegment(p1, q2, q1)) return true;
        if (o3 === 0 && onSegment(p2, p1, q2)) return true;
        if (o4 === 0 && onSegment(p2, q1, q2)) return true;
        
        return false;
    }
}
```

### 5.2 é¢ç§¯å’Œå‘¨é•¿è®¡ç®—

```javascript
class GeometryMeasurements {
    // å¤šè¾¹å½¢é¢ç§¯ï¼ˆé‹å¸¦å…¬å¼ï¼‰
    static polygonArea(vertices) {
        let area = 0;
        const n = vertices.length;
        
        for (let i = 0; i < n; i++) {
            const j = (i + 1) % n;
            area += vertices[i].x * vertices[j].y;
            area -= vertices[j].x * vertices[i].y;
        }
        
        return Math.abs(area) / 2;
    }
    
    // å¤šè¾¹å½¢å‘¨é•¿
    static polygonPerimeter(vertices) {
        let perimeter = 0;
        const n = vertices.length;
        
        for (let i = 0; i < n; i++) {
            const j = (i + 1) % n;
            const dx = vertices[j].x - vertices[i].x;
            const dy = vertices[j].y - vertices[i].y;
            perimeter += Math.sqrt(dx * dx + dy * dy);
        }
        
        return perimeter;
    }
    
    // å¤šè¾¹å½¢é‡å¿ƒ
    static polygonCentroid(vertices) {
        let cx = 0, cy = 0;
        let area = 0;
        const n = vertices.length;
        
        for (let i = 0; i < n; i++) {
            const j = (i + 1) % n;
            const cross = vertices[i].x * vertices[j].y - vertices[j].x * vertices[i].y;
            area += cross;
            cx += (vertices[i].x + vertices[j].x) * cross;
            cy += (vertices[i].y + vertices[j].y) * cross;
        }
        
        area /= 2;
        cx /= 6 * area;
        cy /= 6 * area;
        
        return { x: cx, y: cy };
    }
}
```

### 5.3 åŒ…å›´ç›’è®¡ç®—

```javascript
class BoundingBox {
    constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    
    // æ·»åŠ ç‚¹
    addPoint(x, y) {
        this.minX = Math.min(this.minX, x);
        this.minY = Math.min(this.minY, y);
        this.maxX = Math.max(this.maxX, x);
        this.maxY = Math.max(this.maxY, y);
        return this;
    }
    
    // æ·»åŠ å¤šä¸ªç‚¹
    addPoints(points) {
        for (const point of points) {
            this.addPoint(point.x, point.y);
        }
        return this;
    }
    
    // åˆå¹¶åŒ…å›´ç›’
    union(other) {
        return new BoundingBox(
            Math.min(this.minX, other.minX),
            Math.min(this.minY, other.minY),
            Math.max(this.maxX, other.maxX),
            Math.max(this.maxY, other.maxY)
        );
    }
    
    // åŒ…å›´ç›’ç›¸äº¤
    intersects(other) {
        return !(this.maxX < other.minX || 
                 this.minX > other.maxX ||
                 this.maxY < other.minY || 
                 this.minY > other.maxY);
    }
    
    // åŒ…å«ç‚¹
    containsPoint(x, y) {
        return x >= this.minX && x <= this.maxX &&
               y >= this.minY && y <= this.maxY;
    }
    
    // è·å–å°ºå¯¸
    get width() {
        return this.maxX - this.minX;
    }
    
    get height() {
        return this.maxY - this.minY;
    }
    
    get center() {
        return {
            x: (this.minX + this.maxX) / 2,
            y: (this.minY + this.maxY) / 2
        };
    }
    
    // æ‰©å±•åŒ…å›´ç›’
    expand(amount) {
        return new BoundingBox(
            this.minX - amount,
            this.minY - amount,
            this.maxX + amount,
            this.maxY + amount
        );
    }
    
    // è½¬æ¢ä¸ºçŸ©å½¢
    toRect() {
        return {
            x: this.minX,
            y: this.minY,
            width: this.width,
            height: this.height
        };
    }
    
    // ä»å…ƒç´ è®¡ç®—åŒ…å›´ç›’
    static fromElement(element) {
        const bbox = new BoundingBox();
        
        switch (element.type) {
            case 'rectangle':
                bbox.addPoint(element.x, element.y);
                bbox.addPoint(element.x + element.width, element.y + element.height);
                break;
                
            case 'ellipse':
                bbox.addPoint(element.x, element.y);
                bbox.addPoint(element.x + element.width, element.y + element.height);
                break;
                
            case 'line':
            case 'freedraw':
                bbox.addPoints(element.points);
                break;
        }
        
        return bbox;
    }
}
```

---

## 6. æ›²çº¿æ•°å­¦

### 6.1 è´å¡å°”æ›²çº¿

```javascript
class BezierCurve {
    // äºŒæ¬¡è´å¡å°”æ›²çº¿
    static quadratic(t, p0, p1, p2) {
        const u = 1 - t;
        const tt = t * t;
        const uu = u * u;
        
        return {
            x: uu * p0.x + 2 * u * t * p1.x + tt * p2.x,
            y: uu * p0.y + 2 * u * t * p1.y + tt * p2.y
        };
    }
    
    // ä¸‰æ¬¡è´å¡å°”æ›²çº¿
    static cubic(t, p0, p1, p2, p3) {
        const u = 1 - t;
        const tt = t * t;
        const uu = u * u;
        const ttt = tt * t;
        const uuu = uu * u;
        
        return {
            x: uuu * p0.x + 3 * uu * t * p1.x + 3 * u * tt * p2.x + ttt * p3.x,
            y: uuu * p0.y + 3 * uu * t * p1.y + 3 * u * tt * p2.y + ttt * p3.y
        };
    }
    
    // è·å–æ›²çº¿ä¸Šçš„ç‚¹ï¼ˆé€šç”¨æ–¹æ³•ï¼‰
    static getPoint(t, controlPoints) {
        const n = controlPoints.length - 1;
        const binomialCoeff = (n, k) => {
            let result = 1;
            for (let i = 1; i <= k; i++) {
                result = result * (n - i + 1) / i;
            }
            return result;
        };
        
        let x = 0, y = 0;
        for (let i = 0; i <= n; i++) {
            const coeff = binomialCoeff(n, i) * Math.pow(1 - t, n - i) * Math.pow(t, i);
            x += coeff * controlPoints[i].x;
            y += coeff * controlPoints[i].y;
        }
        
        return { x, y };
    }
    
    // æ›²çº¿é•¿åº¦è¿‘ä¼¼è®¡ç®—
    static approximateLength(controlPoints, steps = 100) {
        let length = 0;
        let prevPoint = this.getPoint(0, controlPoints);
        
        for (let i = 1; i <= steps; i++) {
            const t = i / steps;
            const currentPoint = this.getPoint(t, controlPoints);
            
            const dx = currentPoint.x - prevPoint.x;
            const dy = currentPoint.y - prevPoint.y;
            length += Math.sqrt(dx * dx + dy * dy);
            
            prevPoint = currentPoint;
        }
        
        return length;
    }
    
    // æ›²çº¿ç»†åˆ†
    static subdivide(controlPoints, t = 0.5) {
        // De Casteljau's algorithm
        const n = controlPoints.length;
        const left = [];
        const right = [];
        
        let points = [...controlPoints];
        
        for (let level = 0; level < n; level++) {
            left.push(points[0]);
            right.unshift(points[points.length - 1]);
            
            const newPoints = [];
            for (let i = 0; i < points.length - 1; i++) {
                newPoints.push({
                    x: points[i].x * (1 - t) + points[i + 1].x * t,
                    y: points[i].y * (1 - t) + points[i + 1].y * t
                });
            }
            points = newPoints;
        }
        
        return { left, right };
    }
}
```

### 6.2 æ ·æ¡æ›²çº¿

```javascript
class SplineCurve {
    // Catmull-Rom æ ·æ¡
    static catmullRom(t, p0, p1, p2, p3) {
        const t2 = t * t;
        const t3 = t2 * t;
        
        return {
            x: 0.5 * ((2 * p1.x) +
                      (-p0.x + p2.x) * t +
                      (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 +
                      (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3),
            y: 0.5 * ((2 * p1.y) +
                      (-p0.y + p2.y) * t +
                      (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 +
                      (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3)
        };
    }
    
    // ç”Ÿæˆå¹³æ»‘çš„æ ·æ¡æ›²çº¿è·¯å¾„
    static generateSmoothPath(points, tension = 0.5) {
        if (points.length < 2) return points;
        
        const smoothPoints = [];
        const steps = 20; // æ¯æ®µçš„ç»†åˆ†æ•°
        
        for (let i = 0; i < points.length - 1; i++) {
            const p0 = i > 0 ? points[i - 1] : points[i];
            const p1 = points[i];
            const p2 = points[i + 1];
            const p3 = i < points.length - 2 ? points[i + 2] : points[i + 1];
            
            for (let j = 0; j < steps; j++) {
                const t = j / steps;
                const smoothPoint = this.catmullRom(t, p0, p1, p2, p3);
                smoothPoints.push(smoothPoint);
            }
        }
        
        // æ·»åŠ æœ€åä¸€ä¸ªç‚¹
        smoothPoints.push(points[points.length - 1]);
        
        return smoothPoints;
    }
}
```

---

## 7. Excalidraw ä¸­çš„å‡ ä½•åº”ç”¨

### 7.1 å…ƒç´ è¾¹ç•Œæ¡†è®¡ç®—

```javascript
class ExcalidrawGeometry {
    // è®¡ç®—å…ƒç´ çš„ç²¾ç¡®è¾¹ç•Œæ¡†
    static getElementBounds(element) {
        const bbox = new BoundingBox();
        
        switch (element.type) {
            case 'rectangle':
            case 'ellipse':
            case 'diamond':
                return this.getShapeBounds(element);
                
            case 'line':
            case 'arrow':
                return this.getLinearElementBounds(element);
                
            case 'text':
                return this.getTextBounds(element);
                
            case 'freedraw':
                return this.getFreeDrawBounds(element);
                
            default:
                return bbox;
        }
    }
    
    static getShapeBounds(element) {
        const bbox = new BoundingBox();
        
        if (element.angle === 0) {
            bbox.addPoint(element.x, element.y);
            bbox.addPoint(element.x + element.width, element.y + element.height);
        } else {
            // æ—‹è½¬åçš„è¾¹ç•Œæ¡†
            const center = {
                x: element.x + element.width / 2,
                y: element.y + element.height / 2
            };
            
            const corners = [
                { x: element.x, y: element.y },
                { x: element.x + element.width, y: element.y },
                { x: element.x + element.width, y: element.y + element.height },
                { x: element.x, y: element.y + element.height }
            ];
            
            for (const corner of corners) {
                const rotated = rotateAroundPoint(corner, center, element.angle);
                bbox.addPoint(rotated.x, rotated.y);
            }
        }
        
        return bbox;
    }
    
    static getLinearElementBounds(element) {
        const bbox = new BoundingBox();
        
        if (element.points && element.points.length > 0) {
            for (const point of element.points) {
                bbox.addPoint(element.x + point[0], element.y + point[1]);
            }
        }
        
        return bbox;
    }
    
    // å…ƒç´ ç¢°æ’æ£€æµ‹
    static hitTestElement(element, x, y, tolerance = 5) {
        switch (element.type) {
            case 'rectangle':
                return this.hitTestRectangle(element, x, y);
                
            case 'ellipse':
                return this.hitTestEllipse(element, x, y);
                
            case 'line':
            case 'arrow':
                return this.hitTestLine(element, x, y, tolerance);
                
            case 'text':
                return this.hitTestText(element, x, y);
                
            case 'freedraw':
                return this.hitTestFreeDraw(element, x, y, tolerance);
        }
        
        return false;
    }
    
    static hitTestRectangle(element, x, y) {
        if (element.angle === 0) {
            return pointInRect(x, y, element);
        } else {
            return pointInRotatedRect(x, y, element);
        }
    }
    
    static hitTestEllipse(element, x, y) {
        const centerX = element.x + element.width / 2;
        const centerY = element.y + element.height / 2;
        const radiusX = element.width / 2;
        const radiusY = element.height / 2;
        
        if (element.angle === 0) {
            return pointInEllipse(x, y, {
                centerX, centerY, radiusX, radiusY
            });
        } else {
            return pointInRotatedEllipse(x, y, {
                centerX, centerY, radiusX, radiusY,
                angle: element.angle
            });
        }
    }
    
    static hitTestLine(element, x, y, tolerance) {
        if (!element.points || element.points.length < 2) {
            return false;
        }
        
        for (let i = 0; i < element.points.length - 1; i++) {
            const p1 = element.points[i];
            const p2 = element.points[i + 1];
            
            const distance = pointToLineDistance(
                x, y,
                element.x + p1[0], element.y + p1[1],
                element.x + p2[0], element.y + p2[1]
            );
            
            if (distance <= tolerance) {
                return true;
            }
        }
        
        return false;
    }
}
```

### 7.2 å¤šé€‰æ¡†é€‰æ‹©ç®—æ³•

```javascript
class SelectionBox {
    constructor(startX, startY) {
        this.startX = startX;
        this.startY = startY;
        this.endX = startX;
        this.endY = startY;
    }
    
    update(endX, endY) {
        this.endX = endX;
        this.endY = endY;
    }
    
    getBounds() {
        return {
            x: Math.min(this.startX, this.endX),
            y: Math.min(this.startY, this.endY),
            width: Math.abs(this.endX - this.startX),
            height: Math.abs(this.endY - this.startY)
        };
    }
    
    // æ£€æŸ¥å…ƒç´ æ˜¯å¦ä¸é€‰æ‹©æ¡†ç›¸äº¤
    intersectsElement(element) {
        const selectionBounds = this.getBounds();
        const elementBounds = ExcalidrawGeometry.getElementBounds(element);
        
        return selectionBounds.x < elementBounds.maxX &&
               selectionBounds.x + selectionBounds.width > elementBounds.minX &&
               selectionBounds.y < elementBounds.maxY &&
               selectionBounds.y + selectionBounds.height > elementBounds.minY;
    }
    
    // æ£€æŸ¥å…ƒç´ æ˜¯å¦å®Œå…¨åœ¨é€‰æ‹©æ¡†å†…
    containsElement(element) {
        const selectionBounds = this.getBounds();
        const elementBounds = ExcalidrawGeometry.getElementBounds(element);
        
        return selectionBounds.x <= elementBounds.minX &&
               selectionBounds.y <= elementBounds.minY &&
               selectionBounds.x + selectionBounds.width >= elementBounds.maxX &&
               selectionBounds.y + selectionBounds.height >= elementBounds.maxY;
    }
}
```

---

## 8. å®æˆ˜ï¼šå‡ ä½•è®¡ç®—å™¨

è®©æˆ‘ä»¬æ„å»ºä¸€ä¸ªå‡ ä½•è®¡ç®—å™¨æ¥åº”ç”¨è¿™äº›æ•°å­¦çŸ¥è¯†ï¼š

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‡ ä½•è®¡ç®—å™¨</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .calculator {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .controls {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
        }
        
        .canvas-container {
            position: relative;
        }
        
        canvas {
            border: 1px solid #ccc;
            cursor: crosshair;
        }
        
        .result {
            margin-top: 10px;
            padding: 10px;
            background: #e7f3ff;
            border-radius: 4px;
        }
        
        button {
            margin: 5px;
            padding: 8px 16px;
        }
        
        button.active {
            background: #007bff;
            color: white;
        }
    </style>
</head>
<body>
    <h1>å‡ ä½•è®¡ç®—å™¨</h1>
    
    <div class="calculator">
        <div class="controls">
            <h3>å·¥å…·</h3>
            <button id="point" class="active">ç‚¹</button>
            <button id="line">çº¿æ®µ</button>
            <button id="rectangle">çŸ©å½¢</button>
            <button id="circle">åœ†å½¢</button>
            <button id="polygon">å¤šè¾¹å½¢</button>
            <button id="clear">æ¸…ç©º</button>
            
            <h3>æµ‹é‡</h3>
            <button id="distance">è·ç¦»</button>
            <button id="area">é¢ç§¯</button>
            <button id="angle">è§’åº¦</button>
            <button id="intersection">ç›¸äº¤æ£€æµ‹</button>
            
            <div class="result" id="result">
                ç‚¹å‡»å·¥å…·å¼€å§‹ç»˜åˆ¶å‡ ä½•å›¾å½¢
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="canvas" width="600" height="400"></canvas>
        </div>
    </div>

    <script>
        class GeometryCalculator {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                
                this.shapes = [];
                this.currentTool = 'point';
                this.tempShape = null;
                this.isDrawing = false;
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                // å·¥å…·åˆ‡æ¢
                document.querySelectorAll('button[id]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        if (['point', 'line', 'rectangle', 'circle', 'polygon'].includes(e.target.id)) {
                            this.setTool(e.target.id);
                        } else {
                            this.handleAction(e.target.id);
                        }
                    });
                });
                
                // Canvas äº‹ä»¶
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.canvas.addEventListener('dblclick', this.handleDoubleClick.bind(this));
            }
            
            setTool(tool) {
                this.currentTool = tool;
                document.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                document.getElementById(tool).classList.add('active');
                this.updateResult(`å·¥å…·ï¼š${tool}`);
            }
            
            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            handleMouseDown(e) {
                const pos = this.getMousePos(e);
                this.isDrawing = true;
                
                switch (this.currentTool) {
                    case 'point':
                        this.addPoint(pos);
                        break;
                    case 'line':
                        this.startLine(pos);
                        break;
                    case 'rectangle':
                        this.startRectangle(pos);
                        break;
                    case 'circle':
                        this.startCircle(pos);
                        break;
                    case 'polygon':
                        this.addPolygonPoint(pos);
                        break;
                }
            }
            
            handleMouseMove(e) {
                if (!this.isDrawing || !this.tempShape) return;
                
                const pos = this.getMousePos(e);
                
                switch (this.currentTool) {
                    case 'line':
                        this.tempShape.end = pos;
                        break;
                    case 'rectangle':
                        this.tempShape.width = pos.x - this.tempShape.x;
                        this.tempShape.height = pos.y - this.tempShape.y;
                        break;
                    case 'circle':
                        const dx = pos.x - this.tempShape.center.x;
                        const dy = pos.y - this.tempShape.center.y;
                        this.tempShape.radius = Math.sqrt(dx * dx + dy * dy);
                        break;
                }
                
                this.render();
            }
            
            handleMouseUp(e) {
                if (!this.tempShape) return;
                
                switch (this.currentTool) {
                    case 'line':
                    case 'rectangle':
                    case 'circle':
                        this.shapes.push(this.tempShape);
                        this.tempShape = null;
                        break;
                }
                
                this.isDrawing = false;
                this.render();
            }
            
            handleDoubleClick(e) {
                if (this.currentTool === 'polygon' && this.tempShape) {
                    this.shapes.push(this.tempShape);
                    this.tempShape = null;
                    this.render();
                }
            }
            
            addPoint(pos) {
                this.shapes.push({
                    type: 'point',
                    x: pos.x,
                    y: pos.y
                });
                this.render();
                this.updateResult(`ç‚¹: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)})`);
            }
            
            startLine(pos) {
                this.tempShape = {
                    type: 'line',
                    start: pos,
                    end: pos
                };
            }
            
            startRectangle(pos) {
                this.tempShape = {
                    type: 'rectangle',
                    x: pos.x,
                    y: pos.y,
                    width: 0,
                    height: 0
                };
            }
            
            startCircle(pos) {
                this.tempShape = {
                    type: 'circle',
                    center: pos,
                    radius: 0
                };
            }
            
            addPolygonPoint(pos) {
                if (!this.tempShape) {
                    this.tempShape = {
                        type: 'polygon',
                        points: [pos]
                    };
                } else if (this.tempShape.type === 'polygon') {
                    this.tempShape.points.push(pos);
                }
                this.render();
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ç»˜åˆ¶å·²å®Œæˆçš„å›¾å½¢
                for (const shape of this.shapes) {
                    this.drawShape(shape, '#000000');
                }
                
                // ç»˜åˆ¶ä¸´æ—¶å›¾å½¢
                if (this.tempShape) {
                    this.drawShape(this.tempShape, '#ff0000');
                }
            }
            
            drawShape(shape, color) {
                this.ctx.strokeStyle = color;
                this.ctx.fillStyle = color + '20';
                this.ctx.lineWidth = 2;
                
                switch (shape.type) {
                    case 'point':
                        this.ctx.beginPath();
                        this.ctx.arc(shape.x, shape.y, 3, 0, 2 * Math.PI);
                        this.ctx.fill();
                        break;
                        
                    case 'line':
                        this.ctx.beginPath();
                        this.ctx.moveTo(shape.start.x, shape.start.y);
                        this.ctx.lineTo(shape.end.x, shape.end.y);
                        this.ctx.stroke();
                        break;
                        
                    case 'rectangle':
                        this.ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
                        this.ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
                        break;
                        
                    case 'circle':
                        this.ctx.beginPath();
                        this.ctx.arc(shape.center.x, shape.center.y, shape.radius, 0, 2 * Math.PI);
                        this.ctx.stroke();
                        this.ctx.fill();
                        break;
                        
                    case 'polygon':
                        if (shape.points.length > 1) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(shape.points[0].x, shape.points[0].y);
                            for (let i = 1; i < shape.points.length; i++) {
                                this.ctx.lineTo(shape.points[i].x, shape.points[i].y);
                            }
                            if (this.shapes.includes(shape)) {
                                this.ctx.closePath();
                                this.ctx.fill();
                            }
                            this.ctx.stroke();
                        }
                        break;
                }
            }
            
            handleAction(action) {
                switch (action) {
                    case 'clear':
                        this.shapes = [];
                        this.tempShape = null;
                        this.render();
                        break;
                    case 'distance':
                        this.calculateDistance();
                        break;
                    case 'area':
                        this.calculateArea();
                        break;
                    case 'intersection':
                        this.checkIntersections();
                        break;
                }
            }
            
            calculateDistance() {
                const lines = this.shapes.filter(s => s.type === 'line');
                const points = this.shapes.filter(s => s.type === 'point');
                
                let result = 'è·ç¦»è®¡ç®—:\n';
                
                if (lines.length > 0) {
                    lines.forEach((line, i) => {
                        const dx = line.end.x - line.start.x;
                        const dy = line.end.y - line.start.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        result += `çº¿æ®µ ${i + 1}: ${length.toFixed(2)}px\n`;
                    });
                }
                
                if (points.length >= 2) {
                    for (let i = 0; i < points.length - 1; i++) {
                        for (let j = i + 1; j < points.length; j++) {
                            const dist = DistanceCalculations.pointToPoint(points[i], points[j]);
                            result += `ç‚¹ ${i + 1} åˆ°ç‚¹ ${j + 1}: ${dist.toFixed(2)}px\n`;
                        }
                    }
                }
                
                this.updateResult(result);
            }
            
            calculateArea() {
                let result = 'é¢ç§¯è®¡ç®—:\n';
                
                this.shapes.forEach((shape, i) => {
                    let area = 0;
                    
                    switch (shape.type) {
                        case 'rectangle':
                            area = Math.abs(shape.width * shape.height);
                            result += `çŸ©å½¢ ${i + 1}: ${area.toFixed(2)}pxÂ²\n`;
                            break;
                        case 'circle':
                            area = Math.PI * shape.radius * shape.radius;
                            result += `åœ†å½¢ ${i + 1}: ${area.toFixed(2)}pxÂ²\n`;
                            break;
                        case 'polygon':
                            if (shape.points.length >= 3) {
                                area = GeometryMeasurements.polygonArea(shape.points);
                                result += `å¤šè¾¹å½¢ ${i + 1}: ${area.toFixed(2)}pxÂ²\n`;
                            }
                            break;
                    }
                });
                
                this.updateResult(result);
            }
            
            updateResult(text) {
                document.getElementById('result').textContent = text;
            }
        }
        
        // åˆå§‹åŒ–è®¡ç®—å™¨
        const calculator = new GeometryCalculator('canvas');
        
        // æ·»åŠ ä¹‹å‰å®šä¹‰çš„å·¥å…·ç±»...
        // (Vector2, Transform2D, DistanceCalculations, GeometryMeasurements ç­‰)
    </script>
</body>
</html>
```

---

## ğŸ¯ æœ¬ç« æ€»ç»“

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œä½ åº”è¯¥æŒæ¡äº†ï¼š

âœ… **æ•°å­¦åŸºç¡€**
- åæ ‡ç³»ç»Ÿå’Œå˜æ¢
- å‘é‡è¿ç®—çš„å®Œæ•´å®ç°
- å‡ ä½•å˜æ¢çŸ©é˜µçš„ä½¿ç”¨

âœ… **ç¢°æ’æ£€æµ‹ç®—æ³•**
- ç‚¹ä¸å„ç§å›¾å½¢çš„ç¢°æ’æ£€æµ‹
- å›¾å½¢é—´çš„ç¢°æ’æ£€æµ‹
- SAT åˆ†ç¦»è½´å®šç†çš„åº”ç”¨

âœ… **å‡ ä½•è®¡ç®—**
- è·ç¦»ã€é¢ç§¯ã€å‘¨é•¿è®¡ç®—
- åŒ…å›´ç›’è®¡ç®—å’Œä¼˜åŒ–
- æ›²çº¿æ•°å­¦ï¼ˆè´å¡å°”æ›²çº¿ã€æ ·æ¡æ›²çº¿ï¼‰

âœ… **å®é™…åº”ç”¨**
- Excalidraw ä¸­çš„å‡ ä½•ç®—æ³•
- å¤šé€‰æ¡†é€‰æ‹©ç®—æ³•
- å®Œæ•´çš„å‡ ä½•è®¡ç®—å™¨é¡¹ç›®

è¿™äº›æ•°å­¦åŸºç¡€å°†ä¸ºåç»­ç« èŠ‚çš„äº‹ä»¶ç³»ç»Ÿã€æ¸²æŸ“å¼•æ“ç­‰é«˜çº§åŠŸèƒ½æä¾›åšå®æ”¯æ’‘ã€‚ä¸‹ä¸€ç« æˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•æ„å»ºå¼ºå¤§çš„äº‹ä»¶äº¤äº’ç³»ç»Ÿã€‚