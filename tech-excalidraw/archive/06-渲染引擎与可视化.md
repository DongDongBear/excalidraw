# 第6章：渲染引擎与可视化

## 学习目标
通过本章学习，你将掌握：
- Canvas渲染管线的设计与优化
- 分层渲染架构
- 脏矩形更新和增量渲染
- 渲染批处理和命令模式
- 视口管理和虚拟化
- 动画系统实现
- WebGL加速渲染
- 渲染性能分析和优化
- 导出和打印系统

## 6.1 渲染引擎架构设计

### 6.1.1 渲染管线概述

构建一个高性能的渲染引擎需要精心设计的渲染管线。

```javascript
// 渲染引擎核心
class RenderEngine {
    constructor(canvas, options = {}) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d', {
            alpha: options.alpha ?? true,
            desynchronized: options.desynchronized ?? true, // 异步渲染
            willReadFrequently: options.willReadFrequently ?? false
        });
        
        // 渲染配置
        this.config = {
            enableLayering: options.enableLayering ?? true,
            enableCaching: options.enableCaching ?? true,
            enableCulling: options.enableCulling ?? true,
            enableBatching: options.enableBatching ?? true,
            enableWebGL: options.enableWebGL ?? false,
            maxFPS: options.maxFPS ?? 60,
            adaptiveQuality: options.adaptiveQuality ?? true
        };
        
        // 渲染状态
        this.state = {
            isRendering: false,
            lastRenderTime: 0,
            frameCount: 0,
            averageFPS: 0,
            renderQuality: 'high', // 'low' | 'medium' | 'high'
            isDirty: true
        };
        
        // 渲染组件
        this.viewport = new Viewport(canvas);
        this.layerManager = new LayerManager(this);
        this.cacheManager = new CacheManager(this);
        this.batchRenderer = new BatchRenderer(this);
        this.cullingSystem = new CullingSystem(this);
        this.dirtyRectManager = new DirtyRectManager(this);
        
        // 渲染队列
        this.renderQueue = [];
        this.immediateRenderQueue = [];
        
        // 性能监控
        this.performanceMonitor = new PerformanceMonitor(this);
        
        // 初始化
        this.initialize();
    }
    
    initialize() {
        // 设置Canvas属性
        this.setupCanvas();
        
        // 初始化WebGL（如果启用）
        if (this.config.enableWebGL) {
            this.initializeWebGL();
        }
        
        // 启动渲染循环
        this.startRenderLoop();
    }
    
    setupCanvas() {
        // 设置高DPI支持
        const dpr = window.devicePixelRatio || 1;
        const rect = this.canvas.getBoundingClientRect();
        
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
        
        // 应用缩放
        this.ctx.scale(dpr, dpr);
        
        // 设置默认样式
        this.ctx.imageSmoothingEnabled = true;
        this.ctx.imageSmoothingQuality = 'high';
    }
    
    initializeWebGL() {
        try {
            this.webglRenderer = new WebGLRenderer(this.canvas);
            console.log('WebGL renderer initialized');
        } catch (error) {
            console.warn('Failed to initialize WebGL, falling back to Canvas 2D', error);
            this.config.enableWebGL = false;
        }
    }
    
    // 主渲染循环
    startRenderLoop() {
        const targetFrameTime = 1000 / this.config.maxFPS;
        let lastFrameTime = 0;
        
        const renderFrame = (timestamp) => {
            const deltaTime = timestamp - lastFrameTime;
            
            // 帧率限制
            if (deltaTime >= targetFrameTime) {
                this.performanceMonitor.startFrame();
                
                // 更新动画
                this.updateAnimations(deltaTime);
                
                // 执行渲染
                if (this.state.isDirty || this.hasActiveAnimations()) {
                    this.render();
                }
                
                this.performanceMonitor.endFrame();
                
                // 自适应质量调整
                if (this.config.adaptiveQuality) {
                    this.adjustRenderQuality();
                }
                
                lastFrameTime = timestamp;
            }
            
            requestAnimationFrame(renderFrame);
        };
        
        requestAnimationFrame(renderFrame);
    }
    
    // 核心渲染方法
    render() {
        if (this.state.isRendering) return;
        
        this.state.isRendering = true;
        
        try {
            // 准备渲染
            this.prepareRender();
            
            // 执行渲染管线
            if (this.config.enableLayering) {
                this.renderLayered();
            } else {
                this.renderImmediate();
            }
            
            // 后处理
            this.postProcess();
            
            // 标记为干净
            this.state.isDirty = false;
            
        } finally {
            this.state.isRendering = false;
            this.state.frameCount++;
        }
    }
    
    prepareRender() {
        // 收集渲染命令
        this.collectRenderCommands();
        
        // 执行视锥裁剪
        if (this.config.enableCulling) {
            this.cullingSystem.cull();
        }
        
        // 准备批处理
        if (this.config.enableBatching) {
            this.batchRenderer.prepareBatches();
        }
    }
    
    renderLayered() {
        const layers = this.layerManager.getLayers();
        
        layers.forEach(layer => {
            if (layer.visible) {
                this.renderLayer(layer);
            }
        });
    }
    
    renderLayer(layer) {
        const ctx = layer.getContext();
        
        // 清除层
        if (layer.needsClear) {
            this.clearLayer(layer);
        }
        
        // 渲染层内容
        layer.elements.forEach(element => {
            this.renderElement(ctx, element);
        });
        
        // 合成到主画布
        if (layer !== this.layerManager.mainLayer) {
            this.compositeLayer(layer);
        }
    }
    
    renderImmediate() {
        // 清除画布
        this.clear();
        
        // 直接渲染所有元素
        this.renderQueue.forEach(command => {
            this.executeRenderCommand(this.ctx, command);
        });
    }
    
    renderElement(ctx, element) {
        ctx.save();
        
        try {
            // 应用变换
            this.applyTransform(ctx, element);
            
            // 应用样式
            this.applyStyle(ctx, element);
            
            // 检查缓存
            if (this.config.enableCaching && element.cacheable) {
                this.renderCached(ctx, element);
            } else {
                this.renderDirect(ctx, element);
            }
            
        } finally {
            ctx.restore();
        }
    }
    
    renderCached(ctx, element) {
        let cache = this.cacheManager.getCache(element);
        
        if (!cache || cache.isDirty) {
            cache = this.cacheManager.createCache(element);
            this.renderToCache(cache, element);
        }
        
        // 绘制缓存
        ctx.drawImage(cache.canvas, 0, 0);
    }
    
    renderToCache(cache, element) {
        const ctx = cache.context;
        
        // 清除缓存画布
        ctx.clearRect(0, 0, cache.canvas.width, cache.canvas.height);
        
        // 渲染到缓存
        this.renderDirect(ctx, element);
        
        cache.isDirty = false;
    }
    
    renderDirect(ctx, element) {
        // 直接渲染元素
        element.render(ctx, this.viewport);
    }
    
    // 变换和样式
    applyTransform(ctx, element) {
        const transform = element.getTransformMatrix();
        ctx.setTransform(transform);
    }
    
    applyStyle(ctx, element) {
        const style = element.computedStyle || element.style;
        
        if (style.opacity !== undefined) {
            ctx.globalAlpha = style.opacity;
        }
        
        if (style.compositeOperation) {
            ctx.globalCompositeOperation = style.compositeOperation;
        }
        
        if (style.filter) {
            ctx.filter = style.filter;
        }
    }
    
    // 清除方法
    clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    
    clearLayer(layer) {
        const ctx = layer.getContext();
        ctx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
    }
    
    // 层合成
    compositeLayer(layer) {
        this.ctx.save();
        
        // 应用层混合模式
        if (layer.blendMode) {
            this.ctx.globalCompositeOperation = layer.blendMode;
        }
        
        // 应用层透明度
        if (layer.opacity !== undefined) {
            this.ctx.globalAlpha = layer.opacity;
        }
        
        // 绘制层到主画布
        this.ctx.drawImage(layer.canvas, 0, 0);
        
        this.ctx.restore();
    }
    
    // 后处理
    postProcess() {
        // 应用全局效果
        if (this.config.postProcessing) {
            this.applyPostProcessing();
        }
    }
    
    applyPostProcessing() {
        // 例如：应用全局滤镜
        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        
        // 处理像素数据...
        
        this.ctx.putImageData(imageData, 0, 0);
    }
    
    // 渲染命令收集
    collectRenderCommands() {
        this.renderQueue = [];
        
        // 从元素管理器收集渲染命令
        const elements = this.getVisibleElements();
        
        elements.forEach(element => {
            const command = this.createRenderCommand(element);
            this.renderQueue.push(command);
        });
        
        // 排序渲染队列（按z-index）
        this.renderQueue.sort((a, b) => a.zIndex - b.zIndex);
    }
    
    createRenderCommand(element) {
        return {
            type: 'render',
            element: element,
            zIndex: element.zIndex || 0,
            bounds: element.getBoundingBox(),
            transform: element.getTransformMatrix(),
            style: element.computedStyle || element.style
        };
    }
    
    executeRenderCommand(ctx, command) {
        switch (command.type) {
            case 'render':
                this.renderElement(ctx, command.element);
                break;
            case 'clear':
                this.clear();
                break;
            case 'composite':
                this.compositeLayer(command.layer);
                break;
        }
    }
    
    // 动画更新
    updateAnimations(deltaTime) {
        // 更新所有活动动画
        if (this.animationManager) {
            this.animationManager.update(deltaTime);
        }
    }
    
    hasActiveAnimations() {
        return this.animationManager?.hasActiveAnimations() || false;
    }
    
    // 质量调整
    adjustRenderQuality() {
        const fps = this.performanceMonitor.getCurrentFPS();
        const targetFPS = this.config.maxFPS;
        
        if (fps < targetFPS * 0.8) {
            // 降低质量
            if (this.state.renderQuality === 'high') {
                this.state.renderQuality = 'medium';
            } else if (this.state.renderQuality === 'medium') {
                this.state.renderQuality = 'low';
            }
        } else if (fps > targetFPS * 0.95) {
            // 提高质量
            if (this.state.renderQuality === 'low') {
                this.state.renderQuality = 'medium';
            } else if (this.state.renderQuality === 'medium') {
                this.state.renderQuality = 'high';
            }
        }
        
        this.applyQualitySettings();
    }
    
    applyQualitySettings() {
        switch (this.state.renderQuality) {
            case 'low':
                this.ctx.imageSmoothingEnabled = false;
                this.config.enableCaching = false;
                this.config.enableLayering = false;
                break;
                
            case 'medium':
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'low';
                this.config.enableCaching = true;
                this.config.enableLayering = false;
                break;
                
            case 'high':
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'high';
                this.config.enableCaching = true;
                this.config.enableLayering = true;
                break;
        }
    }
    
    // 公共API
    markDirty(rect = null) {
        this.state.isDirty = true;
        
        if (rect && this.dirtyRectManager) {
            this.dirtyRectManager.addDirtyRect(rect);
        }
    }
    
    forceRender() {
        this.state.isDirty = true;
        this.render();
    }
    
    getVisibleElements() {
        // 从元素管理器获取可见元素
        // 这里需要与元素管理器集成
        return [];
    }
    
    destroy() {
        // 清理资源
        this.layerManager.destroy();
        this.cacheManager.destroy();
        
        if (this.webglRenderer) {
            this.webglRenderer.destroy();
        }
    }
}
```

### 6.1.2 视口管理系统

实现灵活的视口管理，支持平移、缩放和旋转。

```javascript
// 视口管理器
class Viewport {
    constructor(canvas) {
        this.canvas = canvas;
        
        // 视口变换参数
        this.transform = {
            x: 0,          // 平移X
            y: 0,          // 平移Y
            scale: 1,      // 缩放
            rotation: 0    // 旋转（弧度）
        };
        
        // 视口边界
        this.bounds = {
            left: 0,
            top: 0,
            right: canvas.width,
            bottom: canvas.height,
            width: canvas.width,
            height: canvas.height
        };
        
        // 缩放限制
        this.constraints = {
            minScale: 0.1,
            maxScale: 10,
            minX: -Infinity,
            maxX: Infinity,
            minY: -Infinity,
            maxY: Infinity
        };
        
        // 平滑过渡
        this.animation = {
            active: false,
            startTime: 0,
            duration: 300,
            from: null,
            to: null,
            easing: 'easeInOutCubic'
        };
        
        // 虚拟化配置
        this.virtualization = {
            enabled: true,
            margin: 100 // 视口外边距
        };
        
        this.updateBounds();
    }
    
    // 获取变换矩阵
    getTransformMatrix() {
        const matrix = new DOMMatrix();
        
        // 应用变换
        matrix.translateSelf(this.transform.x, this.transform.y);
        
        if (this.transform.rotation !== 0) {
            const centerX = this.bounds.width / 2;
            const centerY = this.bounds.height / 2;
            
            matrix.translateSelf(centerX, centerY);
            matrix.rotateSelf(this.transform.rotation * 180 / Math.PI);
            matrix.translateSelf(-centerX, -centerY);
        }
        
        matrix.scaleSelf(this.transform.scale, this.transform.scale);
        
        return matrix;
    }
    
    // 获取逆变换矩阵
    getInverseTransformMatrix() {
        return this.getTransformMatrix().inverse();
    }
    
    // 坐标转换
    screenToWorld(screenPoint) {
        const inverseMatrix = this.getInverseTransformMatrix();
        const point = new DOMPoint(screenPoint.x, screenPoint.y);
        const worldPoint = inverseMatrix.transformPoint(point);
        
        return {
            x: worldPoint.x,
            y: worldPoint.y
        };
    }
    
    worldToScreen(worldPoint) {
        const matrix = this.getTransformMatrix();
        const point = new DOMPoint(worldPoint.x, worldPoint.y);
        const screenPoint = matrix.transformPoint(point);
        
        return {
            x: screenPoint.x,
            y: screenPoint.y
        };
    }
    
    // 视口操作
    pan(dx, dy) {
        const newX = this.transform.x + dx;
        const newY = this.transform.y + dy;
        
        // 应用约束
        this.transform.x = Math.max(this.constraints.minX, Math.min(this.constraints.maxX, newX));
        this.transform.y = Math.max(this.constraints.minY, Math.min(this.constraints.maxY, newY));
        
        this.updateBounds();
        this.onTransformChange();
    }
    
    zoom(scaleFactor, center = null) {
        const oldScale = this.transform.scale;
        const newScale = Math.max(
            this.constraints.minScale,
            Math.min(this.constraints.maxScale, oldScale * scaleFactor)
        );
        
        if (newScale === oldScale) return;
        
        if (center) {
            // 以指定点为中心缩放
            const worldCenter = this.screenToWorld(center);
            
            this.transform.scale = newScale;
            
            const newScreenCenter = this.worldToScreen(worldCenter);
            const dx = center.x - newScreenCenter.x;
            const dy = center.y - newScreenCenter.y;
            
            this.transform.x += dx;
            this.transform.y += dy;
        } else {
            // 以视口中心缩放
            this.transform.scale = newScale;
        }
        
        this.updateBounds();
        this.onTransformChange();
    }
    
    rotate(angle, center = null) {
        this.transform.rotation += angle;
        
        // 限制在 0-2π 范围
        while (this.transform.rotation < 0) {
            this.transform.rotation += Math.PI * 2;
        }
        while (this.transform.rotation > Math.PI * 2) {
            this.transform.rotation -= Math.PI * 2;
        }
        
        this.updateBounds();
        this.onTransformChange();
    }
    
    // 重置视口
    reset() {
        this.transform = {
            x: 0,
            y: 0,
            scale: 1,
            rotation: 0
        };
        
        this.updateBounds();
        this.onTransformChange();
    }
    
    // 适应内容
    fitToContent(contentBounds, padding = 50) {
        if (!contentBounds) return;
        
        const viewportWidth = this.canvas.width - padding * 2;
        const viewportHeight = this.canvas.height - padding * 2;
        
        const scaleX = viewportWidth / contentBounds.width;
        const scaleY = viewportHeight / contentBounds.height;
        const scale = Math.min(scaleX, scaleY, 1);
        
        const centerX = contentBounds.left + contentBounds.width / 2;
        const centerY = contentBounds.top + contentBounds.height / 2;
        
        this.transform.scale = scale;
        this.transform.x = this.canvas.width / 2 - centerX * scale;
        this.transform.y = this.canvas.height / 2 - centerY * scale;
        
        this.updateBounds();
        this.onTransformChange();
    }
    
    // 动画过渡
    animateTo(targetTransform, duration = 300, easing = 'easeInOutCubic') {
        this.animation = {
            active: true,
            startTime: performance.now(),
            duration: duration,
            from: { ...this.transform },
            to: targetTransform,
            easing: easing
        };
        
        this.runAnimation();
    }
    
    runAnimation() {
        if (!this.animation.active) return;
        
        const now = performance.now();
        const elapsed = now - this.animation.startTime;
        const progress = Math.min(elapsed / this.animation.duration, 1);
        
        // 应用缓动函数
        const easedProgress = this.applyEasing(progress, this.animation.easing);
        
        // 插值变换参数
        this.transform.x = this.lerp(this.animation.from.x, this.animation.to.x, easedProgress);
        this.transform.y = this.lerp(this.animation.from.y, this.animation.to.y, easedProgress);
        this.transform.scale = this.lerp(this.animation.from.scale, this.animation.to.scale, easedProgress);
        this.transform.rotation = this.lerpAngle(this.animation.from.rotation, this.animation.to.rotation, easedProgress);
        
        this.updateBounds();
        this.onTransformChange();
        
        if (progress < 1) {
            requestAnimationFrame(() => this.runAnimation());
        } else {
            this.animation.active = false;
        }
    }
    
    // 缓动函数
    applyEasing(t, type) {
        switch (type) {
            case 'linear':
                return t;
            
            case 'easeInQuad':
                return t * t;
            
            case 'easeOutQuad':
                return t * (2 - t);
            
            case 'easeInOutQuad':
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            
            case 'easeInCubic':
                return t * t * t;
            
            case 'easeOutCubic':
                return (--t) * t * t + 1;
            
            case 'easeInOutCubic':
                return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
            
            case 'easeInOutElastic':
                if (t === 0 || t === 1) return t;
                const p = 0.3 * 1.5;
                if (t < 0.5) {
                    return -0.5 * Math.pow(2, 10 * (t * 2 - 1)) * 
                           Math.sin(((t * 2 - 1) - p / 4) * (2 * Math.PI) / p);
                }
                return Math.pow(2, -10 * (t * 2 - 1)) * 
                       Math.sin(((t * 2 - 1) - p / 4) * (2 * Math.PI) / p) * 0.5 + 1;
            
            default:
                return t;
        }
    }
    
    // 插值函数
    lerp(a, b, t) {
        return a + (b - a) * t;
    }
    
    lerpAngle(a, b, t) {
        let diff = b - a;
        
        // 选择最短路径
        while (diff > Math.PI) diff -= Math.PI * 2;
        while (diff < -Math.PI) diff += Math.PI * 2;
        
        return a + diff * t;
    }
    
    // 更新视口边界
    updateBounds() {
        const inverseMatrix = this.getInverseTransformMatrix();
        
        // 计算世界坐标中的视口边界
        const topLeft = inverseMatrix.transformPoint(new DOMPoint(0, 0));
        const topRight = inverseMatrix.transformPoint(new DOMPoint(this.canvas.width, 0));
        const bottomLeft = inverseMatrix.transformPoint(new DOMPoint(0, this.canvas.height));
        const bottomRight = inverseMatrix.transformPoint(new DOMPoint(this.canvas.width, this.canvas.height));
        
        // 找出边界框
        const xs = [topLeft.x, topRight.x, bottomLeft.x, bottomRight.x];
        const ys = [topLeft.y, topRight.y, bottomLeft.y, bottomRight.y];
        
        this.bounds = {
            left: Math.min(...xs),
            top: Math.min(...ys),
            right: Math.max(...xs),
            bottom: Math.max(...ys),
            width: Math.max(...xs) - Math.min(...xs),
            height: Math.max(...ys) - Math.min(...ys)
        };
        
        // 添加虚拟化边距
        if (this.virtualization.enabled) {
            const margin = this.virtualization.margin / this.transform.scale;
            this.bounds.left -= margin;
            this.bounds.top -= margin;
            this.bounds.right += margin;
            this.bounds.bottom += margin;
            this.bounds.width += margin * 2;
            this.bounds.height += margin * 2;
        }
    }
    
    // 检查元素是否在视口内
    isInViewport(bounds) {
        return !(bounds.right < this.bounds.left ||
                bounds.left > this.bounds.right ||
                bounds.bottom < this.bounds.top ||
                bounds.top > this.bounds.bottom);
    }
    
    // 获取视口内的元素
    getVisibleElements(elements) {
        return elements.filter(element => {
            const bounds = element.getBoundingBox();
            return this.isInViewport(bounds);
        });
    }
    
    // 事件回调
    onTransformChange() {
        // 触发视口变化事件
        if (this.onChange) {
            this.onChange(this.transform);
        }
    }
    
    // 设置约束
    setConstraints(constraints) {
        Object.assign(this.constraints, constraints);
    }
    
    // 获取视口信息
    getInfo() {
        return {
            transform: { ...this.transform },
            bounds: { ...this.bounds },
            screenSize: {
                width: this.canvas.width,
                height: this.canvas.height
            },
            worldVisible: {
                width: this.bounds.width,
                height: this.bounds.height
            }
        };
    }
}
```

## 6.2 分层渲染系统

### 6.2.1 层管理器

实现多层渲染架构，优化渲染性能。

```javascript
// 层管理器
class LayerManager {
    constructor(renderEngine) {
        this.renderEngine = renderEngine;
        this.layers = new Map();
        this.layerOrder = [];
        
        // 默认层
        this.createDefaultLayers();
    }
    
    createDefaultLayers() {
        // 背景层 - 很少变化
        this.createLayer('background', {
            zIndex: 0,
            cacheable: true,
            clearBeforeRender: false
        });
        
        // 网格层
        this.createLayer('grid', {
            zIndex: 1,
            cacheable: true,
            clearBeforeRender: false
        });
        
        // 主内容层
        this.createLayer('main', {
            zIndex: 10,
            cacheable: false,
            clearBeforeRender: true
        });
        
        // 选择层
        this.createLayer('selection', {
            zIndex: 20,
            cacheable: false,
            clearBeforeRender: true
        });
        
        // 工具层（临时绘制）
        this.createLayer('tools', {
            zIndex: 30,
            cacheable: false,
            clearBeforeRender: true
        });
        
        // UI层
        this.createLayer('ui', {
            zIndex: 100,
            cacheable: false,
            clearBeforeRender: true
        });
        
        // 设置主层
        this.mainLayer = this.layers.get('main');
    }
    
    createLayer(name, options = {}) {
        const layer = new RenderLayer(name, options);
        
        this.layers.set(name, layer);
        this.layerOrder.push(layer);
        
        // 按z-index排序
        this.layerOrder.sort((a, b) => a.zIndex - b.zIndex);
        
        return layer;
    }
    
    removeLayer(name) {
        const layer = this.layers.get(name);
        if (!layer) return;
        
        this.layers.delete(name);
        const index = this.layerOrder.indexOf(layer);
        if (index > -1) {
            this.layerOrder.splice(index, 1);
        }
        
        layer.destroy();
    }
    
    getLayer(name) {
        return this.layers.get(name);
    }
    
    getLayers() {
        return this.layerOrder;
    }
    
    // 分配元素到层
    assignElementToLayer(element, layerName = 'main') {
        const layer = this.layers.get(layerName);
        if (layer) {
            layer.addElement(element);
        }
    }
    
    // 移动元素到不同层
    moveElementToLayer(element, fromLayerName, toLayerName) {
        const fromLayer = this.layers.get(fromLayerName);
        const toLayer = this.layers.get(toLayerName);
        
        if (fromLayer && toLayer) {
            fromLayer.removeElement(element);
            toLayer.addElement(element);
        }
    }
    
    // 清空所有层
    clearAll() {
        this.layers.forEach(layer => layer.clear());
    }
    
    // 渲染所有层
    renderAll(mainContext) {
        this.layerOrder.forEach(layer => {
            if (layer.visible && layer.needsRender) {
                layer.render();
                
                // 合成到主画布
                if (layer !== this.mainLayer) {
                    this.compositeLayer(mainContext, layer);
                }
            }
        });
    }
    
    compositeLayer(mainContext, layer) {
        mainContext.save();
        
        // 应用层属性
        if (layer.opacity !== 1) {
            mainContext.globalAlpha = layer.opacity;
        }
        
        if (layer.blendMode) {
            mainContext.globalCompositeOperation = layer.blendMode;
        }
        
        // 绘制层
        mainContext.drawImage(layer.canvas, 0, 0);
        
        mainContext.restore();
    }
    
    destroy() {
        this.layers.forEach(layer => layer.destroy());
        this.layers.clear();
        this.layerOrder = [];
    }
}

// 渲染层
class RenderLayer {
    constructor(name, options = {}) {
        this.name = name;
        this.zIndex = options.zIndex || 0;
        this.visible = options.visible ?? true;
        this.opacity = options.opacity ?? 1;
        this.blendMode = options.blendMode || 'source-over';
        this.cacheable = options.cacheable ?? false;
        this.clearBeforeRender = options.clearBeforeRender ?? true;
        
        // 创建离屏画布
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');
        
        // 元素列表
        this.elements = [];
        this.elementMap = new Map();
        
        // 状态
        this.needsRender = true;
        this.needsClear = true;
        
        // 缓存
        this.cache = null;
        this.cacheValid = false;
        
        this.updateCanvasSize();
    }
    
    updateCanvasSize() {
        // 匹配主画布大小
        const mainCanvas = document.querySelector('canvas');
        if (mainCanvas) {
            this.canvas.width = mainCanvas.width;
            this.canvas.height = mainCanvas.height;
        }
    }
    
    addElement(element) {
        if (!this.elementMap.has(element.id)) {
            this.elements.push(element);
            this.elementMap.set(element.id, element);
            this.invalidate();
        }
    }
    
    removeElement(element) {
        const index = this.elements.indexOf(element);
        if (index > -1) {
            this.elements.splice(index, 1);
            this.elementMap.delete(element.id);
            this.invalidate();
        }
    }
    
    clear() {
        this.elements = [];
        this.elementMap.clear();
        this.invalidate();
    }
    
    invalidate() {
        this.needsRender = true;
        this.cacheValid = false;
        
        if (this.clearBeforeRender) {
            this.needsClear = true;
        }
    }
    
    render() {
        if (!this.needsRender) return;
        
        // 使用缓存
        if (this.cacheable && this.cacheValid) {
            return;
        }
        
        // 清除画布
        if (this.needsClear) {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.needsClear = false;
        }
        
        // 排序元素
        const sortedElements = [...this.elements].sort((a, b) => {
            return (a.zIndex || 0) - (b.zIndex || 0);
        });
        
        // 渲染元素
        sortedElements.forEach(element => {
            if (element.visible !== false) {
                this.renderElement(element);
            }
        });
        
        // 更新缓存
        if (this.cacheable) {
            this.updateCache();
        }
        
        this.needsRender = false;
    }
    
    renderElement(element) {
        this.ctx.save();
        
        try {
            // 应用元素变换
            if (element.getTransformMatrix) {
                const matrix = element.getTransformMatrix();
                this.ctx.setTransform(matrix);
            }
            
            // 渲染元素
            element.render(this.ctx);
            
        } catch (error) {
            console.error(`Error rendering element ${element.id}:`, error);
        } finally {
            this.ctx.restore();
        }
    }
    
    updateCache() {
        if (!this.cache) {
            this.cache = document.createElement('canvas');
            this.cache.width = this.canvas.width;
            this.cache.height = this.canvas.height;
        }
        
        const cacheCtx = this.cache.getContext('2d');
        cacheCtx.clearRect(0, 0, this.cache.width, this.cache.height);
        cacheCtx.drawImage(this.canvas, 0, 0);
        
        this.cacheValid = true;
    }
    
    getContext() {
        return this.ctx;
    }
    
    setVisible(visible) {
        this.visible = visible;
        if (visible) {
            this.invalidate();
        }
    }
    
    setOpacity(opacity) {
        this.opacity = Math.max(0, Math.min(1, opacity));
    }
    
    setBlendMode(mode) {
        this.blendMode = mode;
    }
    
    destroy() {
        this.clear();
        this.canvas = null;
        this.ctx = null;
        this.cache = null;
    }
}
```

### 6.2.2 脏矩形更新系统

实现脏矩形算法，只更新变化的区域。

```javascript
// 脏矩形管理器
class DirtyRectManager {
    constructor(renderEngine) {
        this.renderEngine = renderEngine;
        this.dirtyRects = [];
        this.unionRect = null;
        
        // 配置
        this.config = {
            enabled: true,
            maxRects: 10,
            mergeThreshold: 0.5, // 合并阈值
            expandPadding: 2 // 扩展边距
        };
    }
    
    // 添加脏矩形
    addDirtyRect(rect) {
        if (!this.config.enabled) return;
        
        // 扩展矩形
        const expandedRect = this.expandRect(rect, this.config.expandPadding);
        
        // 尝试合并
        let merged = false;
        for (let i = 0; i < this.dirtyRects.length; i++) {
            if (this.shouldMerge(this.dirtyRects[i], expandedRect)) {
                this.dirtyRects[i] = this.mergeRects(this.dirtyRects[i], expandedRect);
                merged = true;
                break;
            }
        }
        
        if (!merged) {
            this.dirtyRects.push(expandedRect);
        }
        
        // 限制数量
        if (this.dirtyRects.length > this.config.maxRects) {
            this.optimizeDirtyRects();
        }
        
        // 更新联合矩形
        this.updateUnionRect();
    }
    
    // 标记元素为脏
    markElementDirty(element) {
        const bounds = element.getBoundingBox();
        this.addDirtyRect(bounds);
        
        // 如果元素之前的位置也需要清除
        if (element._previousBounds) {
            this.addDirtyRect(element._previousBounds);
        }
    }
    
    // 获取脏矩形列表
    getDirtyRects() {
        if (this.dirtyRects.length === 0) {
            return [];
        }
        
        // 如果脏矩形覆盖了大部分画布，返回整个画布
        if (this.unionRect && this.isMostlyDirty()) {
            return [{
                x: 0,
                y: 0,
                width: this.renderEngine.canvas.width,
                height: this.renderEngine.canvas.height
            }];
        }
        
        return this.dirtyRects;
    }
    
    // 清除脏矩形
    clear() {
        this.dirtyRects = [];
        this.unionRect = null;
    }
    
    // 应用脏矩形渲染
    renderDirtyRects(ctx, renderCallback) {
        const dirtyRects = this.getDirtyRects();
        
        if (dirtyRects.length === 0) return;
        
        dirtyRects.forEach(rect => {
            ctx.save();
            
            // 设置裁剪区域
            ctx.beginPath();
            ctx.rect(rect.x, rect.y, rect.width, rect.height);
            ctx.clip();
            
            // 清除区域
            ctx.clearRect(rect.x, rect.y, rect.width, rect.height);
            
            // 渲染区域内的元素
            renderCallback(rect);
            
            ctx.restore();
        });
        
        // 清除脏矩形
        this.clear();
    }
    
    // 检查是否应该合并矩形
    shouldMerge(rect1, rect2) {
        // 检查重叠
        if (this.rectsOverlap(rect1, rect2)) {
            return true;
        }
        
        // 检查距离
        const distance = this.rectDistance(rect1, rect2);
        const threshold = Math.min(rect1.width, rect1.height, rect2.width, rect2.height) * this.config.mergeThreshold;
        
        return distance < threshold;
    }
    
    // 合并矩形
    mergeRects(rect1, rect2) {
        const left = Math.min(rect1.x, rect2.x);
        const top = Math.min(rect1.y, rect2.y);
        const right = Math.max(rect1.x + rect1.width, rect2.x + rect2.width);
        const bottom = Math.max(rect1.y + rect1.height, rect2.y + rect2.height);
        
        return {
            x: left,
            y: top,
            width: right - left,
            height: bottom - top
        };
    }
    
    // 优化脏矩形
    optimizeDirtyRects() {
        // 合并所有重叠或接近的矩形
        let optimized = [];
        
        for (const rect of this.dirtyRects) {
            let merged = false;
            
            for (let i = 0; i < optimized.length; i++) {
                if (this.shouldMerge(optimized[i], rect)) {
                    optimized[i] = this.mergeRects(optimized[i], rect);
                    merged = true;
                    break;
                }
            }
            
            if (!merged) {
                optimized.push(rect);
            }
        }
        
        this.dirtyRects = optimized;
        
        // 如果还是太多，合并成一个大矩形
        if (this.dirtyRects.length > this.config.maxRects) {
            this.dirtyRects = [this.unionRect];
        }
    }
    
    // 更新联合矩形
    updateUnionRect() {
        if (this.dirtyRects.length === 0) {
            this.unionRect = null;
            return;
        }
        
        let left = Infinity, top = Infinity, right = -Infinity, bottom = -Infinity;
        
        for (const rect of this.dirtyRects) {
            left = Math.min(left, rect.x);
            top = Math.min(top, rect.y);
            right = Math.max(right, rect.x + rect.width);
            bottom = Math.max(bottom, rect.y + rect.height);
        }
        
        this.unionRect = {
            x: left,
            y: top,
            width: right - left,
            height: bottom - top
        };
    }
    
    // 检查是否大部分画布都脏了
    isMostlyDirty() {
        if (!this.unionRect) return false;
        
        const canvasArea = this.renderEngine.canvas.width * this.renderEngine.canvas.height;
        const dirtyArea = this.unionRect.width * this.unionRect.height;
        
        return dirtyArea > canvasArea * 0.7; // 70%以上
    }
    
    // 工具函数
    expandRect(rect, padding) {
        return {
            x: rect.x - padding,
            y: rect.y - padding,
            width: rect.width + padding * 2,
            height: rect.height + padding * 2
        };
    }
    
    rectsOverlap(rect1, rect2) {
        return !(rect1.x + rect1.width < rect2.x ||
                rect2.x + rect2.width < rect1.x ||
                rect1.y + rect1.height < rect2.y ||
                rect2.y + rect2.height < rect1.y);
    }
    
    rectDistance(rect1, rect2) {
        const dx = Math.max(0, Math.max(rect1.x - (rect2.x + rect2.width), rect2.x - (rect1.x + rect1.width)));
        const dy = Math.max(0, Math.max(rect1.y - (rect2.y + rect2.height), rect2.y - (rect1.y + rect1.height)));
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    // 调试渲染
    renderDebug(ctx) {
        ctx.save();
        
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        
        this.dirtyRects.forEach(rect => {
            ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
        });
        
        if (this.unionRect) {
            ctx.strokeStyle = 'blue';
            ctx.strokeRect(this.unionRect.x, this.unionRect.y, this.unionRect.width, this.unionRect.height);
        }
        
        ctx.restore();
    }
}
```

## 6.3 渲染优化技术

### 6.3.1 缓存管理系统

实现智能缓存管理，提升渲染性能。

```javascript
// 缓存管理器
class CacheManager {
    constructor(renderEngine) {
        this.renderEngine = renderEngine;
        this.caches = new Map();
        
        // 配置
        this.config = {
            maxCacheSize: 100 * 1024 * 1024, // 100MB
            maxCacheCount: 100,
            autoEvict: true,
            cacheScale: 1 // 缓存分辨率比例
        };
        
        // 统计
        this.stats = {
            hits: 0,
            misses: 0,
            currentSize: 0,
            cacheCount: 0
        };
        
        // LRU记录
        this.accessOrder = new Map();
    }
    
    // 获取缓存
    getCache(element) {
        const key = this.getCacheKey(element);
        const cache = this.caches.get(key);
        
        if (cache && this.isCacheValid(cache, element)) {
            // 更新访问时间
            this.accessOrder.set(key, Date.now());
            this.stats.hits++;
            return cache;
        }
        
        this.stats.misses++;
        return null;
    }
    
    // 创建缓存
    createCache(element) {
        const key = this.getCacheKey(element);
        
        // 计算缓存大小
        const bounds = element.getBoundingBox();
        const scale = this.config.cacheScale;
        const width = Math.ceil(bounds.width * scale);
        const height = Math.ceil(bounds.height * scale);
        
        // 创建离屏画布
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        
        const ctx = canvas.getContext('2d');
        
        // 应用缩放
        if (scale !== 1) {
            ctx.scale(scale, scale);
        }
        
        // 平移到原点
        ctx.translate(-bounds.x, -bounds.y);
        
        // 创建缓存对象
        const cache = {
            key: key,
            canvas: canvas,
            context: ctx,
            bounds: { ...bounds },
            version: element.version || 0,
            timestamp: Date.now(),
            size: width * height * 4, // 估算内存大小
            isDirty: false,
            element: new WeakRef(element) // 弱引用
        };
        
        // 检查缓存限制
        if (this.config.autoEvict) {
            this.ensureCacheLimit(cache.size);
        }
        
        // 添加缓存
        this.caches.set(key, cache);
        this.accessOrder.set(key, Date.now());
        
        // 更新统计
        this.stats.currentSize += cache.size;
        this.stats.cacheCount++;
        
        return cache;
    }
    
    // 使缓存失效
    invalidateCache(element) {
        const key = this.getCacheKey(element);
        const cache = this.caches.get(key);
        
        if (cache) {
            cache.isDirty = true;
        }
    }
    
    // 删除缓存
    removeCache(element) {
        const key = this.getCacheKey(element);
        const cache = this.caches.get(key);
        
        if (cache) {
            this.caches.delete(key);
            this.accessOrder.delete(key);
            
            // 更新统计
            this.stats.currentSize -= cache.size;
            this.stats.cacheCount--;
            
            // 清理画布
            cache.canvas = null;
            cache.context = null;
        }
    }
    
    // 清空所有缓存
    clearAll() {
        this.caches.forEach(cache => {
            cache.canvas = null;
            cache.context = null;
        });
        
        this.caches.clear();
        this.accessOrder.clear();
        
        this.stats.currentSize = 0;
        this.stats.cacheCount = 0;
    }
    
    // 检查缓存是否有效
    isCacheValid(cache, element) {
        // 检查版本
        if (cache.version !== (element.version || 0)) {
            return false;
        }
        
        // 检查脏标记
        if (cache.isDirty) {
            return false;
        }
        
        // 检查边界是否变化
        const currentBounds = element.getBoundingBox();
        if (!this.boundsEqual(cache.bounds, currentBounds)) {
            return false;
        }
        
        return true;
    }
    
    // 获取缓存键
    getCacheKey(element) {
        return `${element.type}_${element.id}`;
    }
    
    // 确保缓存限制
    ensureCacheLimit(newCacheSize) {
        // 检查数量限制
        while (this.stats.cacheCount >= this.config.maxCacheCount) {
            this.evictLRU();
        }
        
        // 检查大小限制
        while (this.stats.currentSize + newCacheSize > this.config.maxCacheSize) {
            this.evictLRU();
        }
    }
    
    // 驱逐最少使用的缓存
    evictLRU() {
        let oldestKey = null;
        let oldestTime = Infinity;
        
        for (const [key, time] of this.accessOrder) {
            if (time < oldestTime) {
                oldestTime = time;
                oldestKey = key;
            }
        }
        
        if (oldestKey) {
            const cache = this.caches.get(oldestKey);
            if (cache) {
                const element = cache.element.deref();
                if (element) {
                    this.removeCache(element);
                } else {
                    // 元素已被垃圾回收
                    this.caches.delete(oldestKey);
                    this.accessOrder.delete(oldestKey);
                    this.stats.currentSize -= cache.size;
                    this.stats.cacheCount--;
                }
            }
        }
    }
    
    // 比较边界
    boundsEqual(bounds1, bounds2) {
        return bounds1.x === bounds2.x &&
               bounds1.y === bounds2.y &&
               bounds1.width === bounds2.width &&
               bounds1.height === bounds2.height;
    }
    
    // 获取缓存统计
    getStats() {
        const hitRate = this.stats.hits + this.stats.misses > 0
            ? this.stats.hits / (this.stats.hits + this.stats.misses)
            : 0;
            
        return {
            ...this.stats,
            hitRate: hitRate,
            sizeMB: this.stats.currentSize / (1024 * 1024)
        };
    }
    
    // 优化缓存策略
    optimizeCacheStrategy() {
        const stats = this.getStats();
        
        // 根据命中率调整缓存大小
        if (stats.hitRate < 0.5) {
            // 命中率低，可能需要更多缓存
            this.config.maxCacheCount = Math.min(this.config.maxCacheCount * 1.5, 200);
        } else if (stats.hitRate > 0.9 && this.stats.cacheCount > 50) {
            // 命中率高，可以减少缓存
            this.config.maxCacheCount = Math.max(this.config.maxCacheCount * 0.8, 50);
        }
        
        // 根据内存使用调整缓存质量
        if (stats.sizeMB > 80) {
            this.config.cacheScale = Math.max(this.config.cacheScale * 0.8, 0.5);
        } else if (stats.sizeMB < 30) {
            this.config.cacheScale = Math.min(this.config.cacheScale * 1.2, 2);
        }
    }
    
    // 预缓存
    precache(elements) {
        const viewport = this.renderEngine.viewport;
        
        // 只预缓存视口附近的元素
        elements.forEach(element => {
            const bounds = element.getBoundingBox();
            
            // 检查是否在扩展视口内
            const expandedViewport = {
                left: viewport.bounds.left - 100,
                top: viewport.bounds.top - 100,
                right: viewport.bounds.right + 100,
                bottom: viewport.bounds.bottom + 100
            };
            
            if (this.isInBounds(bounds, expandedViewport)) {
                // 如果没有缓存，创建它
                if (!this.getCache(element)) {
                    const cache = this.createCache(element);
                    
                    // 异步渲染到缓存
                    requestIdleCallback(() => {
                        element.render(cache.context);
                    });
                }
            }
        });
    }
    
    isInBounds(rect, bounds) {
        return !(rect.x + rect.width < bounds.left ||
                rect.x > bounds.right ||
                rect.y + rect.height < bounds.top ||
                rect.y > bounds.bottom);
    }
    
    destroy() {
        this.clearAll();
    }
}
```

### 6.3.2 批处理渲染器

实现渲染命令批处理，减少状态切换。

```javascript
// 批处理渲染器
class BatchRenderer {
    constructor(renderEngine) {
        this.renderEngine = renderEngine;
        this.batches = new Map();
        
        // 批处理类型
        this.batchTypes = {
            FILL: 'fill',
            STROKE: 'stroke',
            IMAGE: 'image',
            TEXT: 'text'
        };
        
        // 批处理缓冲区
        this.buffers = {
            fill: [],
            stroke: [],
            image: [],
            text: []
        };
        
        // 统计
        this.stats = {
            batchCount: 0,
            drawCalls: 0,
            savedDrawCalls: 0
        };
    }
    
    // 准备批处理
    prepareBatches() {
        // 清空缓冲区
        this.clearBuffers();
        
        // 收集可批处理的元素
        const elements = this.renderEngine.getVisibleElements();
        
        elements.forEach(element => {
            this.addToBatch(element);
        });
        
        // 优化批次
        this.optimizeBatches();
    }
    
    // 添加到批处理
    addToBatch(element) {
        const style = element.style || {};
        
        // 根据样式分类
        if (style.fill && style.fill !== 'transparent') {
            this.addToFillBatch(element, style);
        }
        
        if (style.stroke && style.stroke !== 'transparent') {
            this.addToStrokeBatch(element, style);
        }
        
        if (element.type === 'image') {
            this.addToImageBatch(element);
        }
        
        if (element.type === 'text') {
            this.addToTextBatch(element, style);
        }
    }
    
    // 添加到填充批次
    addToFillBatch(element, style) {
        const key = this.getFillBatchKey(style);
        
        if (!this.batches.has(key)) {
            this.batches.set(key, {
                type: this.batchTypes.FILL,
                style: {
                    fillStyle: style.fill,
                    globalAlpha: style.opacity || 1
                },
                elements: []
            });
        }
        
        this.batches.get(key).elements.push(element);
    }
    
    // 添加到描边批次
    addToStrokeBatch(element, style) {
        const key = this.getStrokeBatchKey(style);
        
        if (!this.batches.has(key)) {
            this.batches.set(key, {
                type: this.batchTypes.STROKE,
                style: {
                    strokeStyle: style.stroke,
                    lineWidth: style.strokeWidth || 1,
                    lineCap: style.lineCap || 'butt',
                    lineJoin: style.lineJoin || 'miter',
                    globalAlpha: style.opacity || 1
                },
                elements: []
            });
        }
        
        this.batches.get(key).elements.push(element);
    }
    
    // 添加到图片批次
    addToImageBatch(element) {
        const key = 'image_batch';
        
        if (!this.batches.has(key)) {
            this.batches.set(key, {
                type: this.batchTypes.IMAGE,
                elements: []
            });
        }
        
        this.batches.get(key).elements.push(element);
    }
    
    // 添加到文本批次
    addToTextBatch(element, style) {
        const key = this.getTextBatchKey(style);
        
        if (!this.batches.has(key)) {
            this.batches.set(key, {
                type: this.batchTypes.TEXT,
                style: {
                    font: element.getFontString(),
                    fillStyle: style.fill || '#000',
                    textAlign: element.textAlign || 'left',
                    textBaseline: element.textBaseline || 'alphabetic',
                    globalAlpha: style.opacity || 1
                },
                elements: []
            });
        }
        
        this.batches.get(key).elements.push(element);
    }
    
    // 生成批处理键
    getFillBatchKey(style) {
        return `fill_${style.fill}_${style.opacity || 1}`;
    }
    
    getStrokeBatchKey(style) {
        return `stroke_${style.stroke}_${style.strokeWidth}_${style.opacity || 1}`;
    }
    
    getTextBatchKey(style) {
        return `text_${style.font}_${style.fill}_${style.opacity || 1}`;
    }
    
    // 优化批次
    optimizeBatches() {
        // 合并小批次
        const minBatchSize = 5;
        const smallBatches = [];
        
        this.batches.forEach((batch, key) => {
            if (batch.elements.length < minBatchSize) {
                smallBatches.push(key);
            }
        });
        
        // 将小批次合并或转为直接渲染
        smallBatches.forEach(key => {
            const batch = this.batches.get(key);
            
            // 查找可合并的批次
            let merged = false;
            this.batches.forEach((otherBatch, otherKey) => {
                if (key !== otherKey && 
                    batch.type === otherBatch.type &&
                    this.canMergeBatches(batch, otherBatch)) {
                    
                    otherBatch.elements.push(...batch.elements);
                    this.batches.delete(key);
                    merged = true;
                }
            });
            
            if (!merged && batch.elements.length < 2) {
                // 太小的批次不值得批处理
                this.batches.delete(key);
            }
        });
        
        this.stats.batchCount = this.batches.size;
    }
    
    // 检查是否可以合并批次
    canMergeBatches(batch1, batch2) {
        if (batch1.type !== batch2.type) return false;
        
        // 比较样式
        const style1 = batch1.style;
        const style2 = batch2.style;
        
        switch (batch1.type) {
            case this.batchTypes.FILL:
                return style1.fillStyle === style2.fillStyle &&
                       style1.globalAlpha === style2.globalAlpha;
                       
            case this.batchTypes.STROKE:
                return style1.strokeStyle === style2.strokeStyle &&
                       style1.lineWidth === style2.lineWidth &&
                       style1.globalAlpha === style2.globalAlpha;
                       
            case this.batchTypes.TEXT:
                return style1.font === style2.font &&
                       style1.fillStyle === style2.fillStyle &&
                       style1.globalAlpha === style2.globalAlpha;
                       
            default:
                return false;
        }
    }
    
    // 执行批渲染
    renderBatches(ctx) {
        let drawCalls = 0;
        
        // 按类型顺序渲染
        const renderOrder = [
            this.batchTypes.FILL,
            this.batchTypes.STROKE,
            this.batchTypes.IMAGE,
            this.batchTypes.TEXT
        ];
        
        renderOrder.forEach(type => {
            this.batches.forEach(batch => {
                if (batch.type === type) {
                    this.renderBatch(ctx, batch);
                    drawCalls++;
                }
            });
        });
        
        this.stats.drawCalls = drawCalls;
        this.updateStats();
    }
    
    // 渲染单个批次
    renderBatch(ctx, batch) {
        ctx.save();
        
        // 应用批次样式
        if (batch.style) {
            Object.assign(ctx, batch.style);
        }
        
        // 根据类型渲染
        switch (batch.type) {
            case this.batchTypes.FILL:
                this.renderFillBatch(ctx, batch);
                break;
                
            case this.batchTypes.STROKE:
                this.renderStrokeBatch(ctx, batch);
                break;
                
            case this.batchTypes.IMAGE:
                this.renderImageBatch(ctx, batch);
                break;
                
            case this.batchTypes.TEXT:
                this.renderTextBatch(ctx, batch);
                break;
        }
        
        ctx.restore();
    }
    
    // 渲染填充批次
    renderFillBatch(ctx, batch) {
        ctx.beginPath();
        
        batch.elements.forEach(element => {
            this.addElementPathToContext(ctx, element);
        });
        
        ctx.fill();
    }
    
    // 渲染描边批次
    renderStrokeBatch(ctx, batch) {
        ctx.beginPath();
        
        batch.elements.forEach(element => {
            this.addElementPathToContext(ctx, element);
        });
        
        ctx.stroke();
    }
    
    // 渲染图片批次
    renderImageBatch(ctx, batch) {
        batch.elements.forEach(element => {
            if (element._image && element._imageLoaded) {
                const bounds = element.getBoundingBox();
                ctx.drawImage(element._image, bounds.x, bounds.y, bounds.width, bounds.height);
            }
        });
    }
    
    // 渲染文本批次
    renderTextBatch(ctx, batch) {
        batch.elements.forEach(element => {
            const position = element.position;
            ctx.fillText(element.text, position.x, position.y);
        });
    }
    
    // 添加元素路径到上下文
    addElementPathToContext(ctx, element) {
        switch (element.type) {
            case 'rectangle':
                const bounds = element.getBoundingBox();
                ctx.rect(bounds.x, bounds.y, bounds.width, bounds.height);
                break;
                
            case 'ellipse':
                ctx.ellipse(
                    element.position.x,
                    element.position.y,
                    element.radiusX,
                    element.radiusY,
                    0, 0, Math.PI * 2
                );
                break;
                
            case 'line':
                if (element.points.length > 0) {
                    ctx.moveTo(element.points[0].x, element.points[0].y);
                    for (let i = 1; i < element.points.length; i++) {
                        ctx.lineTo(element.points[i].x, element.points[i].y);
                    }
                }
                break;
        }
    }
    
    // 清空缓冲区
    clearBuffers() {
        this.batches.clear();
        Object.keys(this.buffers).forEach(key => {
            this.buffers[key] = [];
        });
    }
    
    // 更新统计
    updateStats() {
        // 计算节省的绘制调用
        let totalElements = 0;
        this.batches.forEach(batch => {
            totalElements += batch.elements.length;
        });
        
        this.stats.savedDrawCalls = totalElements - this.stats.drawCalls;
    }
    
    // 获取统计信息
    getStats() {
        return {
            ...this.stats,
            efficiency: this.stats.savedDrawCalls / (this.stats.drawCalls + this.stats.savedDrawCalls)
        };
    }
}
```

## 6.4 动画系统

### 6.4.1 动画引擎

实现灵活的动画系统，支持各种动画效果。

```javascript
// 动画管理器
class AnimationManager {
    constructor(renderEngine) {
        this.renderEngine = renderEngine;
        this.animations = new Map();
        this.animationQueue = [];
        this.isRunning = false;
        this.lastFrameTime = 0;
        
        // 缓动函数库
        this.easingFunctions = new EasingFunctions();
        
        // 动画配置
        this.config = {
            defaultDuration: 300,
            defaultEasing: 'easeInOutCubic'
        };
    }
    
    // 创建动画
    createAnimation(target, properties, options = {}) {
        const animation = new Animation({
            target,
            properties,
            duration: options.duration || this.config.defaultDuration,
            easing: options.easing || this.config.defaultEasing,
            delay: options.delay || 0,
            onUpdate: options.onUpdate,
            onComplete: options.onComplete,
            onStart: options.onStart
        });
        
        this.animations.set(animation.id, animation);
        
        // 如果有延迟，加入队列
        if (animation.delay > 0) {
            this.animationQueue.push(animation);
        } else {
            animation.start();
        }
        
        // 启动动画循环
        if (!this.isRunning) {
            this.start();
        }
        
        return animation;
    }
    
    // 更新动画
    update(deltaTime) {
        const currentTime = performance.now();
        
        // 处理延迟的动画
        this.animationQueue = this.animationQueue.filter(animation => {
            if (currentTime >= animation.startTime + animation.delay) {
                animation.start();
                return false;
            }
            return true;
        });
        
        // 更新活动动画
        const completedAnimations = [];
        
        this.animations.forEach(animation => {
            if (animation.isActive) {
                animation.update(currentTime);
                
                if (animation.isComplete) {
                    completedAnimations.push(animation.id);
                }
            }
        });
        
        // 移除完成的动画
        completedAnimations.forEach(id => {
            this.animations.delete(id);
        });
        
        // 标记需要重绘
        if (this.animations.size > 0 || this.animationQueue.length > 0) {
            this.renderEngine.markDirty();
        }
    }
    
    // 启动动画循环
    start() {
        this.isRunning = true;
        this.lastFrameTime = performance.now();
    }
    
    // 停止动画循环
    stop() {
        this.isRunning = false;
    }
    
    // 暂停所有动画
    pauseAll() {
        this.animations.forEach(animation => animation.pause());
    }
    
    // 恢复所有动画
    resumeAll() {
        this.animations.forEach(animation => animation.resume());
    }
    
    // 停止特定动画
    stopAnimation(animationId) {
        const animation = this.animations.get(animationId);
        if (animation) {
            animation.stop();
            this.animations.delete(animationId);
        }
    }
    
    // 停止目标的所有动画
    stopTargetAnimations(target) {
        const toStop = [];
        
        this.animations.forEach(animation => {
            if (animation.target === target) {
                toStop.push(animation.id);
            }
        });
        
        toStop.forEach(id => this.stopAnimation(id));
    }
    
    // 检查是否有活动动画
    hasActiveAnimations() {
        return this.animations.size > 0 || this.animationQueue.length > 0;
    }
    
    // 链式动画
    chain(animations) {
        let previousAnimation = null;
        
        animations.forEach(config => {
            const animation = this.createAnimation(
                config.target,
                config.properties,
                {
                    ...config.options,
                    delay: previousAnimation ? 0 : (config.options?.delay || 0)
                }
            );
            
            if (previousAnimation) {
                previousAnimation.onComplete = () => animation.start();
            }
            
            previousAnimation = animation;
        });
        
        return animations[0];
    }
    
    // 并行动画
    parallel(animations) {
        const group = [];
        
        animations.forEach(config => {
            const animation = this.createAnimation(
                config.target,
                config.properties,
                config.options
            );
            group.push(animation);
        });
        
        return group;
    }
}

// 单个动画类
class Animation {
    constructor(config) {
        this.id = this.generateId();
        this.target = config.target;
        this.properties = config.properties;
        this.duration = config.duration;
        this.easing = config.easing;
        this.delay = config.delay;
        
        // 回调
        this.onUpdate = config.onUpdate;
        this.onComplete = config.onComplete;
        this.onStart = config.onStart;
        
        // 状态
        this.isActive = false;
        this.isComplete = false;
        this.isPaused = false;
        
        // 时间
        this.startTime = 0;
        this.pauseTime = 0;
        this.elapsedTime = 0;
        
        // 属性初始值和目标值
        this.fromValues = {};
        this.toValues = {};
        
        this.initialize();
    }
    
    generateId() {
        return `animation_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    initialize() {
        // 保存初始值和目标值
        Object.keys(this.properties).forEach(prop => {
            this.fromValues[prop] = this.getPropertyValue(prop);
            this.toValues[prop] = this.properties[prop];
        });
    }
    
    getPropertyValue(prop) {
        // 支持嵌套属性
        const parts = prop.split('.');
        let value = this.target;
        
        for (const part of parts) {
            value = value[part];
        }
        
        return value;
    }
    
    setPropertyValue(prop, value) {
        // 支持嵌套属性
        const parts = prop.split('.');
        let obj = this.target;
        
        for (let i = 0; i < parts.length - 1; i++) {
            obj = obj[parts[i]];
        }
        
        obj[parts[parts.length - 1]] = value;
    }
    
    start() {
        this.isActive = true;
        this.startTime = performance.now();
        
        if (this.onStart) {
            this.onStart(this);
        }
    }
    
    pause() {
        if (this.isActive && !this.isPaused) {
            this.isPaused = true;
            this.pauseTime = performance.now();
        }
    }
    
    resume() {
        if (this.isPaused) {
            const pauseDuration = performance.now() - this.pauseTime;
            this.startTime += pauseDuration;
            this.isPaused = false;
        }
    }
    
    stop() {
        this.isActive = false;
        this.isComplete = true;
    }
    
    update(currentTime) {
        if (!this.isActive || this.isPaused) return;
        
        this.elapsedTime = currentTime - this.startTime;
        const progress = Math.min(this.elapsedTime / this.duration, 1);
        
        // 应用缓动
        const easedProgress = this.applyEasing(progress);
        
        // 更新属性
        Object.keys(this.properties).forEach(prop => {
            const from = this.fromValues[prop];
            const to = this.toValues[prop];
            
            let value;
            if (typeof from === 'number' && typeof to === 'number') {
                value = from + (to - from) * easedProgress;
            } else if (typeof from === 'object' && typeof to === 'object') {
                value = this.interpolateObject(from, to, easedProgress);
            } else {
                value = easedProgress >= 1 ? to : from;
            }
            
            this.setPropertyValue(prop, value);
        });
        
        // 触发更新回调
        if (this.onUpdate) {
            this.onUpdate(this, easedProgress);
        }
        
        // 检查完成
        if (progress >= 1) {
            this.isComplete = true;
            this.isActive = false;
            
            if (this.onComplete) {
                this.onComplete(this);
            }
        }
    }
    
    applyEasing(t) {
        // 使用缓动函数
        return EasingFunctions[this.easing]?.(t) || t;
    }
    
    interpolateObject(from, to, progress) {
        const result = {};
        
        Object.keys(from).forEach(key => {
            if (typeof from[key] === 'number' && typeof to[key] === 'number') {
                result[key] = from[key] + (to[key] - from[key]) * progress;
            } else {
                result[key] = progress >= 1 ? to[key] : from[key];
            }
        });
        
        return result;
    }
}

// 缓动函数库
const EasingFunctions = {
    linear: t => t,
    
    easeInQuad: t => t * t,
    easeOutQuad: t => t * (2 - t),
    easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
    
    easeInCubic: t => t * t * t,
    easeOutCubic: t => (--t) * t * t + 1,
    easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
    
    easeInQuart: t => t * t * t * t,
    easeOutQuart: t => 1 - (--t) * t * t * t,
    easeInOutQuart: t => t < 0.5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t,
    
    easeInQuint: t => t * t * t * t * t,
    easeOutQuint: t => 1 + (--t) * t * t * t * t,
    easeInOutQuint: t => t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t,
    
    easeInSine: t => 1 - Math.cos(t * Math.PI / 2),
    easeOutSine: t => Math.sin(t * Math.PI / 2),
    easeInOutSine: t => -(Math.cos(Math.PI * t) - 1) / 2,
    
    easeInExpo: t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
    easeOutExpo: t => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
    easeInOutExpo: t => {
        if (t === 0 || t === 1) return t;
        if (t < 0.5) return Math.pow(2, 20 * t - 10) / 2;
        return (2 - Math.pow(2, -20 * t + 10)) / 2;
    },
    
    easeInCirc: t => 1 - Math.sqrt(1 - t * t),
    easeOutCirc: t => Math.sqrt(1 - (--t) * t),
    easeInOutCirc: t => t < 0.5
        ? (1 - Math.sqrt(1 - 4 * t * t)) / 2
        : (Math.sqrt(1 - 4 * (--t) * t) + 1) / 2,
    
    easeInBack: t => t * t * (2.70158 * t - 1.70158),
    easeOutBack: t => 1 + (--t) * t * (2.70158 * t + 1.70158),
    easeInOutBack: t => {
        const c = 1.70158 * 1.525;
        return t < 0.5
            ? 2 * t * t * ((c + 1) * 2 * t - c) / 2
            : ((2 * t - 2) * (2 * t - 2) * ((c + 1) * (2 * t - 2) + c) + 2) / 2;
    },
    
    easeInElastic: t => {
        if (t === 0 || t === 1) return t;
        return -Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1.1) * 5 * Math.PI);
    },
    easeOutElastic: t => {
        if (t === 0 || t === 1) return t;
        return Math.pow(2, -10 * t) * Math.sin((t - 0.1) * 5 * Math.PI) + 1;
    },
    easeInOutElastic: t => {
        if (t === 0 || t === 1) return t;
        if (t < 0.5) {
            return -Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * (2 * Math.PI) / 4.5) / 2;
        }
        return Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * (2 * Math.PI) / 4.5) / 2 + 1;
    },
    
    easeInBounce: t => 1 - EasingFunctions.easeOutBounce(1 - t),
    easeOutBounce: t => {
        if (t < 1 / 2.75) {
            return 7.5625 * t * t;
        } else if (t < 2 / 2.75) {
            return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
        } else if (t < 2.5 / 2.75) {
            return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
        } else {
            return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
        }
    },
    easeInOutBounce: t => t < 0.5
        ? EasingFunctions.easeInBounce(t * 2) / 2
        : EasingFunctions.easeOutBounce(t * 2 - 1) / 2 + 0.5
};
```

## 总结

本章详细介绍了渲染引擎与可视化系统的构建，包括：

1. **渲染引擎架构** - 设计了完整的渲染管线和视口管理系统
2. **分层渲染系统** - 实现了多层渲染架构和脏矩形更新算法
3. **渲染优化技术** - 构建了缓存管理和批处理渲染系统
4. **动画系统** - 实现了灵活的动画引擎和丰富的缓动函数

这套渲染引擎为构建高性能的绘图应用提供了强大的基础设施，具有优秀的性能表现和扩展能力。在下一章中，我们将学习如何构建工具系统来支持各种绘图工具。