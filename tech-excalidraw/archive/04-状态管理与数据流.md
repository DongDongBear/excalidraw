# 第4章：状态管理与数据流

## 学习目标
通过本章学习，你将掌握：
- 现代状态管理模式和架构
- Jotai状态管理库的深度应用
- 原子化状态设计模式
- 状态派生和计算属性
- 异步状态处理
- 时间旅行调试和撤销重做
- 状态持久化和同步
- 性能优化策略

## 4.1 状态管理基础理论

### 4.1.1 状态管理模式演进

在复杂的前端应用中，状态管理经历了从简单到复杂的演进过程。

```javascript
// 1. 原始状态管理 - 直接修改对象
class PrimitiveStateManager {
    constructor() {
        this.state = {
            elements: [],
            selectedIds: [],
            viewport: {
                offset: { x: 0, y: 0 },
                scale: 1
            },
            tool: 'select'
        };
        
        this.listeners = [];
    }
    
    // 直接修改状态（不推荐）
    setState(updates) {
        Object.assign(this.state, updates);
        this.notifyListeners();
    }
    
    // 监听器模式
    subscribe(listener) {
        this.listeners.push(listener);
        return () => {
            const index = this.listeners.indexOf(listener);
            if (index > -1) {
                this.listeners.splice(index, 1);
            }
        };
    }
    
    notifyListeners() {
        this.listeners.forEach(listener => listener(this.state));
    }
}

// 2. 不可变状态管理 - Redux模式
class ImmutableStateManager {
    constructor() {
        this.state = {
            elements: [],
            selectedIds: [],
            viewport: { offset: { x: 0, y: 0 }, scale: 1 },
            tool: 'select',
            history: {
                past: [],
                present: null,
                future: []
            }
        };
        
        this.listeners = new Set();
        this.reducers = new Map();
    }
    
    // 注册reducer
    registerReducer(actionType, reducer) {
        this.reducers.set(actionType, reducer);
    }
    
    // 派发action
    dispatch(action) {
        const reducer = this.reducers.get(action.type);
        if (reducer) {
            const newState = reducer(this.state, action);
            if (newState !== this.state) {
                this.state = newState;
                this.notifyListeners();
            }
        }
    }
    
    // 订阅状态变化
    subscribe(listener) {
        this.listeners.add(listener);
        return () => this.listeners.delete(listener);
    }
    
    notifyListeners() {
        this.listeners.forEach(listener => listener(this.state));
    }
    
    // 创建不可变更新辅助函数
    produce(updater) {
        return this.immerProduce(this.state, updater);
    }
    
    // 简化版的immer produce实现
    immerProduce(baseState, updater) {
        const draft = this.deepClone(baseState);
        updater(draft);
        return draft;
    }
    
    deepClone(obj) {
        if (obj === null || typeof obj !== 'object') return obj;
        if (obj instanceof Date) return new Date(obj.getTime());
        if (obj instanceof Array) return obj.map(item => this.deepClone(item));
        
        const clonedObj = {};
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                clonedObj[key] = this.deepClone(obj[key]);
            }
        }
        return clonedObj;
    }
}

// 设置reducer
const stateManager = new ImmutableStateManager();

stateManager.registerReducer('ADD_ELEMENT', (state, action) => {
    return stateManager.produce(draft => {
        draft.elements.push(action.payload);
        draft.history.past.push({
            elements: [...state.elements],
            selectedIds: [...state.selectedIds]
        });
        draft.history.future = [];
    });
});

stateManager.registerReducer('UPDATE_VIEWPORT', (state, action) => {
    return stateManager.produce(draft => {
        draft.viewport = { ...draft.viewport, ...action.payload };
    });
});

stateManager.registerReducer('SELECT_ELEMENTS', (state, action) => {
    return stateManager.produce(draft => {
        draft.selectedIds = action.payload.elementIds;
    });
});
```

### 4.1.2 原子化状态管理

原子化状态管理将状态拆分为独立的原子单元，每个原子负责一个特定的状态片段。

```javascript
// 基础原子实现
class Atom {
    constructor(initialValue, key = null) {
        this.value = initialValue;
        this.key = key || this.generateKey();
        this.listeners = new Set();
        this.dependencies = new Set();
        this.dependents = new Set();
    }
    
    generateKey() {
        return `atom_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    // 获取当前值
    get() {
        // 如果在计算上下文中，添加依赖关系
        if (Atom.currentComputation) {
            this.dependents.add(Atom.currentComputation);
            Atom.currentComputation.dependencies.add(this);
        }
        return this.value;
    }
    
    // 设置新值
    set(newValue) {
        if (this.value !== newValue) {
            this.value = newValue;
            this.notifyListeners();
            this.notifyDependents();
        }
    }
    
    // 订阅变化
    subscribe(listener) {
        this.listeners.add(listener);
        return () => this.listeners.delete(listener);
    }
    
    notifyListeners() {
        this.listeners.forEach(listener => {
            try {
                listener(this.value);
            } catch (error) {
                console.error('Atom listener error:', error);
            }
        });
    }
    
    notifyDependents() {
        this.dependents.forEach(dependent => {
            dependent.invalidate();
        });
    }
}

// 派生原子（计算属性）
class DerivedAtom extends Atom {
    constructor(derivation, dependencies = []) {
        super(null);
        this.derivation = derivation;
        this.dependencies = new Set(dependencies);
        this.isValid = false;
        this.isComputing = false;
        
        // 订阅依赖变化
        dependencies.forEach(dep => {
            dep.dependents.add(this);
        });
        
        // 初始计算
        this.compute();
    }
    
    get() {
        if (!this.isValid && !this.isComputing) {
            this.compute();
        }
        return super.get();
    }
    
    compute() {
        if (this.isComputing) {
            throw new Error('Circular dependency detected');
        }
        
        this.isComputing = true;
        const previousComputation = Atom.currentComputation;
        Atom.currentComputation = this;
        
        try {
            const newValue = this.derivation();
            this.value = newValue;
            this.isValid = true;
        } catch (error) {
            console.error('Derived atom computation error:', error);
            this.isValid = false;
        } finally {
            Atom.currentComputation = previousComputation;
            this.isComputing = false;
        }
    }
    
    invalidate() {
        if (this.isValid) {
            this.isValid = false;
            this.notifyDependents();
        }
    }
}

// 原子存储
class AtomStore {
    constructor() {
        this.atoms = new Map();
    }
    
    // 创建原子
    atom(initialValue, key = null) {
        const atom = new Atom(initialValue, key);
        if (key) {
            this.atoms.set(key, atom);
        }
        return atom;
    }
    
    // 创建派生原子
    derived(derivation, dependencies = []) {
        return new DerivedAtom(derivation, dependencies);
    }
    
    // 获取原子
    get(key) {
        return this.atoms.get(key);
    }
    
    // 批量更新
    batch(updater) {
        const notificationQueue = [];
        const originalNotify = Atom.prototype.notifyListeners;
        
        // 暂停通知
        Atom.prototype.notifyListeners = function() {
            notificationQueue.push(() => originalNotify.call(this));
        };
        
        try {
            updater();
        } finally {
            // 恢复通知并执行
            Atom.prototype.notifyListeners = originalNotify;
            notificationQueue.forEach(notify => notify());
        }
    }
    
    // 调试工具
    debug() {
        console.log('=== Atom Store Debug Info ===');
        this.atoms.forEach((atom, key) => {
            console.log(`${key}:`, atom.value, `(${atom.listeners.size} listeners)`);
        });
    }
}
```

## 4.2 Jotai深度应用

### 4.2.1 Jotai基础概念和API

Jotai是一个原子化状态管理库，让我们深入了解其核心概念。

```javascript
// Jotai在Excalidraw中的使用示例
import { atom, useAtom, useAtomValue, useSetAtom } from 'jotai';

// 基础原子
const elementsAtom = atom([]);
const selectedElementIdsAtom = atom([]);
const viewportAtom = atom({
    offset: { x: 0, y: 0 },
    scale: 1
});
const currentToolAtom = atom('select');

// 派生原子 - 选中的元素
const selectedElementsAtom = atom((get) => {
    const elements = get(elementsAtom);
    const selectedIds = get(selectedElementIdsAtom);
    return elements.filter(el => selectedIds.includes(el.id));
});

// 派生原子 - 场景边界
const sceneBoundsAtom = atom((get) => {
    const elements = get(elementsAtom);
    if (elements.length === 0) {
        return { left: 0, top: 0, right: 0, bottom: 0 };
    }
    
    let left = Infinity, top = Infinity, right = -Infinity, bottom = -Infinity;
    
    elements.forEach(element => {
        const bounds = getElementBounds(element);
        left = Math.min(left, bounds.x);
        top = Math.min(top, bounds.y);
        right = Math.max(right, bounds.x + bounds.width);
        bottom = Math.max(bottom, bounds.y + bounds.height);
    });
    
    return { left, top, right, bottom };
});

// 写入原子 - 添加元素
const addElementAtom = atom(null, (get, set, element) => {
    const currentElements = get(elementsAtom);
    set(elementsAtom, [...currentElements, element]);
});

// 写入原子 - 更新元素
const updateElementAtom = atom(null, (get, set, { id, updates }) => {
    const currentElements = get(elementsAtom);
    set(elementsAtom, currentElements.map(el => 
        el.id === id ? { ...el, ...updates } : el
    ));
});

// 写入原子 - 删除元素
const deleteElementsAtom = atom(null, (get, set, elementIds) => {
    const currentElements = get(elementsAtom);
    set(elementsAtom, currentElements.filter(el => !elementIds.includes(el.id)));
    
    // 同时清除选择
    const currentSelection = get(selectedElementIdsAtom);
    const newSelection = currentSelection.filter(id => !elementIds.includes(id));
    set(selectedElementIdsAtom, newSelection);
});

// 工具辅助函数
function getElementBounds(element) {
    switch (element.type) {
        case 'rectangle':
        case 'ellipse':
            return {
                x: element.position.x,
                y: element.position.y,
                width: element.size.width,
                height: element.size.height
            };
        
        case 'line':
            const [start, end] = element.points;
            return {
                x: Math.min(start.x, end.x),
                y: Math.min(start.y, end.y),
                width: Math.abs(end.x - start.x),
                height: Math.abs(end.y - start.y)
            };
            
        default:
            return { x: 0, y: 0, width: 0, height: 0 };
    }
}
```

### 4.2.2 复杂状态管理模式

构建更复杂的状态管理模式来处理Excalidraw的各种需求。

```javascript
// 历史记录管理
const historyAtom = atom({
    past: [],
    present: null,
    future: []
});

// 创建历史记录原子
const createHistoryAtom = (targetAtom) => {
    const historyAtom = atom({
        past: [],
        present: null,
        future: []
    });
    
    // 撤销原子
    const undoAtom = atom(null, (get, set) => {
        const history = get(historyAtom);
        if (history.past.length === 0) return;
        
        const previous = history.past[history.past.length - 1];
        const current = get(targetAtom);
        
        set(historyAtom, {
            past: history.past.slice(0, -1),
            present: previous,
            future: [current, ...history.future]
        });
        
        set(targetAtom, previous);
    });
    
    // 重做原子
    const redoAtom = atom(null, (get, set) => {
        const history = get(historyAtom);
        if (history.future.length === 0) return;
        
        const next = history.future[0];
        const current = get(targetAtom);
        
        set(historyAtom, {
            past: [...history.past, current],
            present: next,
            future: history.future.slice(1)
        });
        
        set(targetAtom, next);
    });
    
    // 添加历史记录原子
    const pushHistoryAtom = atom(null, (get, set, newValue) => {
        const current = get(targetAtom);
        const history = get(historyAtom);
        
        // 限制历史记录数量
        const maxHistorySize = 50;
        const newPast = [...history.past, current].slice(-maxHistorySize);
        
        set(historyAtom, {
            past: newPast,
            present: newValue,
            future: [] // 新操作清空future
        });
        
        set(targetAtom, newValue);
    });
    
    return {
        historyAtom,
        undoAtom,
        redoAtom,
        pushHistoryAtom
    };
};

// 为元素创建历史记录
const {
    historyAtom: elementsHistoryAtom,
    undoAtom: undoElementsAtom,
    redoAtom: redoElementsAtom,
    pushHistoryAtom: pushElementsHistoryAtom
} = createHistoryAtom(elementsAtom);

// 异步状态管理
const createAsyncAtom = (asyncFunction) => {
    const baseAtom = atom({
        data: null,
        loading: false,
        error: null
    });
    
    const loadingAtom = atom(get => get(baseAtom).loading);
    const dataAtom = atom(get => get(baseAtom).data);
    const errorAtom = atom(get => get(baseAtom).error);
    
    const executeAtom = atom(null, async (get, set, ...args) => {
        set(baseAtom, prev => ({ ...prev, loading: true, error: null }));
        
        try {
            const result = await asyncFunction(...args);
            set(baseAtom, { data: result, loading: false, error: null });
            return result;
        } catch (error) {
            set(baseAtom, prev => ({ ...prev, loading: false, error }));
            throw error;
        }
    });
    
    return {
        baseAtom,
        loadingAtom,
        dataAtom,
        errorAtom,
        executeAtom
    };
};

// 文件保存异步原子
const {
    loadingAtom: saveLoadingAtom,
    errorAtom: saveErrorAtom,
    executeAtom: saveFileAtom
} = createAsyncAtom(async (elements, filename) => {
    const data = {
        type: 'excalidraw',
        version: 2,
        source: 'https://excalidraw.com',
        elements: elements
    };
    
    const blob = new Blob([JSON.stringify(data, null, 2)], { 
        type: 'application/json' 
    });
    
    // 模拟异步保存
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // 下载文件
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename || 'drawing.excalidraw';
    link.click();
    URL.revokeObjectURL(url);
    
    return { success: true, filename };
});

// 协作状态管理
const collaborationAtom = atom({
    isConnected: false,
    peers: [],
    cursors: new Map(),
    isHost: false,
    roomId: null
});

const myPointerAtom = atom({ x: 0, y: 0 });

// 广播指针位置原子
const broadcastPointerAtom = atom(null, (get, set, position) => {
    set(myPointerAtom, position);
    
    const collaboration = get(collaborationAtom);
    if (collaboration.isConnected) {
        // 这里应该通过WebSocket发送
        console.log('Broadcasting pointer position:', position);
    }
});

// 处理远程指针更新原子
const updateRemotePointerAtom = atom(null, (get, set, { peerId, position }) => {
    const collaboration = get(collaborationAtom);
    const newCursors = new Map(collaboration.cursors);
    newCursors.set(peerId, position);
    
    set(collaborationAtom, {
        ...collaboration,
        cursors: newCursors
    });
});

// 性能监控原子
const performanceAtom = atom({
    renderTime: 0,
    elementCount: 0,
    frameRate: 0,
    memoryUsage: 0
});

const updatePerformanceAtom = atom(null, (get, set, metrics) => {
    set(performanceAtom, prev => ({
        ...prev,
        ...metrics,
        timestamp: Date.now()
    }));
});
```

### 4.2.3 状态持久化和同步

实现状态的本地存储和云端同步功能。

```javascript
// 持久化原子工厂
const createPersistentAtom = (key, initialValue, storage = localStorage) => {
    // 从存储加载初始值
    const loadFromStorage = () => {
        try {
            const stored = storage.getItem(key);
            return stored ? JSON.parse(stored) : initialValue;
        } catch {
            return initialValue;
        }
    };
    
    const baseAtom = atom(loadFromStorage());
    
    // 持久化原子，自动保存到存储
    const persistentAtom = atom(
        get => get(baseAtom),
        (get, set, newValue) => {
            set(baseAtom, newValue);
            
            // 异步保存到存储
            try {
                storage.setItem(key, JSON.stringify(newValue));
            } catch (error) {
                console.error(`Failed to persist atom ${key}:`, error);
            }
        }
    );
    
    return persistentAtom;
};

// 创建持久化原子
const persistentViewportAtom = createPersistentAtom('excalidraw-viewport', {
    offset: { x: 0, y: 0 },
    scale: 1
});

const persistentToolAtom = createPersistentAtom('excalidraw-tool', 'select');

const persistentThemeAtom = createPersistentAtom('excalidraw-theme', 'light');

// 自动保存原子
const autoSaveAtom = atom({
    enabled: true,
    interval: 30000, // 30秒
    lastSaved: null
});

const autoSaveIntervalIdAtom = atom(null);

// 启动自动保存
const startAutoSaveAtom = atom(null, (get, set) => {
    const autoSave = get(autoSaveAtom);
    if (!autoSave.enabled) return;
    
    // 清除现有定时器
    const currentId = get(autoSaveIntervalIdAtom);
    if (currentId) {
        clearInterval(currentId);
    }
    
    // 设置新定时器
    const intervalId = setInterval(async () => {
        const elements = get(elementsAtom);
        const viewport = get(viewportAtom);
        
        try {
            await saveToIndexedDB('autoSave', {
                elements,
                viewport,
                timestamp: Date.now()
            });
            
            set(autoSaveAtom, prev => ({
                ...prev,
                lastSaved: Date.now()
            }));
        } catch (error) {
            console.error('Auto save failed:', error);
        }
    }, autoSave.interval);
    
    set(autoSaveIntervalIdAtom, intervalId);
});

// IndexedDB存储工具
const saveToIndexedDB = (key, data) => {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('ExcalidrawDB', 1);
        
        request.onerror = () => reject(request.error);
        
        request.onsuccess = (event) => {
            const db = event.target.result;
            const transaction = db.transaction(['drawings'], 'readwrite');
            const store = transaction.objectStore('drawings');
            
            store.put({ key, data, timestamp: Date.now() });
            
            transaction.oncomplete = () => resolve();
            transaction.onerror = () => reject(transaction.error);
        };
        
        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('drawings')) {
                db.createObjectStore('drawings', { keyPath: 'key' });
            }
        };
    });
};

// 云端同步原子
const cloudSyncAtom = atom({
    status: 'idle', // 'idle', 'syncing', 'error'
    lastSync: null,
    conflicts: [],
    apiKey: null
});

const syncToCloudAtom = atom(null, async (get, set) => {
    const elements = get(elementsAtom);
    const cloudSync = get(cloudSyncAtom);
    
    if (!cloudSync.apiKey) {
        throw new Error('API key required for cloud sync');
    }
    
    set(cloudSyncAtom, prev => ({ ...prev, status: 'syncing' }));
    
    try {
        const response = await fetch('/api/sync', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${cloudSync.apiKey}`
            },
            body: JSON.stringify({
                elements,
                timestamp: Date.now()
            })
        });
        
        if (!response.ok) {
            throw new Error(`Sync failed: ${response.statusText}`);
        }
        
        const result = await response.json();
        
        // 处理冲突
        if (result.conflicts) {
            set(cloudSyncAtom, prev => ({
                ...prev,
                status: 'idle',
                conflicts: result.conflicts,
                lastSync: Date.now()
            }));
        } else {
            set(cloudSyncAtom, prev => ({
                ...prev,
                status: 'idle',
                lastSync: Date.now(),
                conflicts: []
            }));
        }
        
        return result;
    } catch (error) {
        set(cloudSyncAtom, prev => ({
            ...prev,
            status: 'error'
        }));
        throw error;
    }
});
```

## 4.3 状态派生和计算

### 4.3.1 复杂派生状态

实现复杂的状态派生逻辑，提供高性能的计算属性。

```javascript
// 空间索引原子 - 用于快速查找元素
const spatialIndexAtom = atom((get) => {
    const elements = get(elementsAtom);
    const index = new QuadTree({
        x: -10000,
        y: -10000,
        width: 20000,
        height: 20000
    });
    
    elements.forEach(element => {
        const bounds = getElementBounds(element);
        index.insert({
            x: bounds.x,
            y: bounds.y,
            width: bounds.width,
            height: bounds.height,
            data: element
        });
    });
    
    return index;
});

// 四叉树实现（简化版）
class QuadTree {
    constructor(bounds, maxObjects = 10, maxLevels = 5, level = 0) {
        this.bounds = bounds;
        this.maxObjects = maxObjects;
        this.maxLevels = maxLevels;
        this.level = level;
        this.objects = [];
        this.nodes = [];
    }
    
    insert(rect) {
        if (this.nodes.length > 0) {
            const index = this.getIndex(rect);
            if (index !== -1) {
                this.nodes[index].insert(rect);
                return;
            }
        }
        
        this.objects.push(rect);
        
        if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {
            if (this.nodes.length === 0) {
                this.split();
            }
            
            let i = 0;
            while (i < this.objects.length) {
                const index = this.getIndex(this.objects[i]);
                if (index !== -1) {
                    this.nodes[index].insert(this.objects.splice(i, 1)[0]);
                } else {
                    i++;
                }
            }
        }
    }
    
    retrieve(rect) {
        const returnObjects = [...this.objects];
        
        if (this.nodes.length > 0) {
            const index = this.getIndex(rect);
            if (index !== -1) {
                returnObjects.push(...this.nodes[index].retrieve(rect));
            } else {
                this.nodes.forEach(node => {
                    returnObjects.push(...node.retrieve(rect));
                });
            }
        }
        
        return returnObjects;
    }
    
    split() {
        const subWidth = this.bounds.width / 2;
        const subHeight = this.bounds.height / 2;
        
        this.nodes[0] = new QuadTree({
            x: this.bounds.x + subWidth,
            y: this.bounds.y,
            width: subWidth,
            height: subHeight
        }, this.maxObjects, this.maxLevels, this.level + 1);
        
        this.nodes[1] = new QuadTree({
            x: this.bounds.x,
            y: this.bounds.y,
            width: subWidth,
            height: subHeight
        }, this.maxObjects, this.maxLevels, this.level + 1);
        
        this.nodes[2] = new QuadTree({
            x: this.bounds.x,
            y: this.bounds.y + subHeight,
            width: subWidth,
            height: subHeight
        }, this.maxObjects, this.maxLevels, this.level + 1);
        
        this.nodes[3] = new QuadTree({
            x: this.bounds.x + subWidth,
            y: this.bounds.y + subHeight,
            width: subWidth,
            height: subHeight
        }, this.maxObjects, this.maxLevels, this.level + 1);
    }
    
    getIndex(rect) {
        const verticalMidpoint = this.bounds.x + (this.bounds.width / 2);
        const horizontalMidpoint = this.bounds.y + (this.bounds.height / 2);
        
        const topQuadrant = rect.y < horizontalMidpoint && rect.y + rect.height < horizontalMidpoint;
        const bottomQuadrant = rect.y > horizontalMidpoint;
        
        if (rect.x < verticalMidpoint && rect.x + rect.width < verticalMidpoint) {
            if (topQuadrant) {
                return 1;
            } else if (bottomQuadrant) {
                return 2;
            }
        } else if (rect.x > verticalMidpoint) {
            if (topQuadrant) {
                return 0;
            } else if (bottomQuadrant) {
                return 3;
            }
        }
        
        return -1;
    }
}

// 碰撞检测原子
const collisionDetectionAtom = atom((get) => {
    const spatialIndex = get(spatialIndexAtom);
    
    return {
        // 点击检测
        getElementAtPoint: (point) => {
            const candidates = spatialIndex.retrieve({
                x: point.x - 1,
                y: point.y - 1,
                width: 2,
                height: 2
            });
            
            return candidates
                .map(item => item.data)
                .filter(element => isPointInElement(point, element))
                .sort((a, b) => b.zIndex - a.zIndex)[0]; // 返回最顶层的元素
        },
        
        // 区域检测
        getElementsInBounds: (bounds) => {
            const candidates = spatialIndex.retrieve(bounds);
            return candidates
                .map(item => item.data)
                .filter(element => isElementIntersectingBounds(element, bounds));
        },
        
        // 重叠检测
        getOverlappingElements: (targetElement) => {
            const bounds = getElementBounds(targetElement);
            const candidates = spatialIndex.retrieve(bounds);
            
            return candidates
                .map(item => item.data)
                .filter(element => 
                    element.id !== targetElement.id &&
                    isElementOverlapping(targetElement, element)
                );
        }
    };
});

// 几何检测辅助函数
function isPointInElement(point, element) {
    const bounds = getElementBounds(element);
    
    switch (element.type) {
        case 'rectangle':
            return point.x >= bounds.x && 
                   point.x <= bounds.x + bounds.width &&
                   point.y >= bounds.y && 
                   point.y <= bounds.y + bounds.height;
                   
        case 'ellipse':
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            const dx = (point.x - centerX) / (bounds.width / 2);
            const dy = (point.y - centerY) / (bounds.height / 2);
            return dx * dx + dy * dy <= 1;
            
        case 'line':
            const [start, end] = element.points;
            const lineThreshold = element.style.strokeWidth || 2;
            return distancePointToLine(point, start, end) <= lineThreshold;
            
        default:
            return false;
    }
}

function distancePointToLine(point, lineStart, lineEnd) {
    const A = point.x - lineStart.x;
    const B = point.y - lineStart.y;
    const C = lineEnd.x - lineStart.x;
    const D = lineEnd.y - lineStart.y;
    
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;
    
    if (lenSq !== 0) {
        param = dot / lenSq;
    }
    
    let xx, yy;
    
    if (param < 0) {
        xx = lineStart.x;
        yy = lineStart.y;
    } else if (param > 1) {
        xx = lineEnd.x;
        yy = lineEnd.y;
    } else {
        xx = lineStart.x + param * C;
        yy = lineStart.y + param * D;
    }
    
    const dx = point.x - xx;
    const dy = point.y - yy;
    return Math.sqrt(dx * dx + dy * dy);
}

function isElementIntersectingBounds(element, bounds) {
    const elementBounds = getElementBounds(element);
    
    return !(elementBounds.x > bounds.x + bounds.width ||
             elementBounds.x + elementBounds.width < bounds.x ||
             elementBounds.y > bounds.y + bounds.height ||
             elementBounds.y + elementBounds.height < bounds.y);
}

function isElementOverlapping(element1, element2) {
    const bounds1 = getElementBounds(element1);
    const bounds2 = getElementBounds(element2);
    
    return isElementIntersectingBounds(element1, bounds2);
}

// 统计信息原子
const statisticsAtom = atom((get) => {
    const elements = get(elementsAtom);
    const selectedElements = get(selectedElementsAtom);
    const viewport = get(viewportAtom);
    
    const stats = {
        totalElements: elements.length,
        selectedCount: selectedElements.length,
        elementTypes: {},
        totalArea: 0,
        boundingBox: null,
        zoomLevel: Math.round(viewport.scale * 100)
    };
    
    // 统计元素类型
    elements.forEach(element => {
        stats.elementTypes[element.type] = (stats.elementTypes[element.type] || 0) + 1;
        
        // 累计面积
        const bounds = getElementBounds(element);
        stats.totalArea += bounds.width * bounds.height;
    });
    
    // 计算包围盒
    if (elements.length > 0) {
        const bounds = get(sceneBoundsAtom);
        stats.boundingBox = {
            width: bounds.right - bounds.left,
            height: bounds.bottom - bounds.top,
            center: {
                x: (bounds.left + bounds.right) / 2,
                y: (bounds.top + bounds.bottom) / 2
            }
        };
    }
    
    return stats;
});

// 渲染优化原子
const renderOptimizationAtom = atom((get) => {
    const elements = get(elementsAtom);
    const viewport = get(viewportAtom);
    const canvas = get(canvasAtom); // 假设有canvas原子
    
    if (!canvas) return { visibleElements: elements, culledCount: 0 };
    
    // 计算视口范围
    const rect = canvas.getBoundingClientRect();
    const viewBounds = {
        x: -viewport.offset.x / viewport.scale,
        y: -viewport.offset.y / viewport.scale,
        width: rect.width / viewport.scale,
        height: rect.height / viewport.scale
    };
    
    // 视锥裁剪
    const visibleElements = elements.filter(element => {
        const bounds = getElementBounds(element);
        return isElementIntersectingBounds(element, viewBounds);
    });
    
    // LOD (细节层次) 优化
    const lodElements = visibleElements.map(element => {
        const bounds = getElementBounds(element);
        const screenSize = Math.max(bounds.width, bounds.height) * viewport.scale;
        
        // 根据屏幕尺寸决定渲染质量
        let lodLevel = 'high';
        if (screenSize < 5) {
            lodLevel = 'low';
        } else if (screenSize < 20) {
            lodLevel = 'medium';
        }
        
        return {
            ...element,
            _lodLevel: lodLevel,
            _screenBounds: {
                x: bounds.x * viewport.scale + viewport.offset.x,
                y: bounds.y * viewport.scale + viewport.offset.y,
                width: bounds.width * viewport.scale,
                height: bounds.height * viewport.scale
            }
        };
    });
    
    return {
        visibleElements: lodElements,
        culledCount: elements.length - visibleElements.length,
        viewBounds
    };
});
```

### 4.3.2 缓存和记忆化

实现高效的缓存机制来优化状态计算性能。

```javascript
// 记忆化计算工具
class MemoizeCache {
    constructor(maxSize = 100) {
        this.cache = new Map();
        this.maxSize = maxSize;
        this.accessOrder = new Map(); // 用于LRU
    }
    
    get(key) {
        if (this.cache.has(key)) {
            // 更新访问时间
            this.accessOrder.set(key, Date.now());
            return this.cache.get(key);
        }
        return undefined;
    }
    
    set(key, value) {
        // 如果缓存满了，删除最久未使用的项
        if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
            const lruKey = this.findLRUKey();
            this.cache.delete(lruKey);
            this.accessOrder.delete(lruKey);
        }
        
        this.cache.set(key, value);
        this.accessOrder.set(key, Date.now());
    }
    
    findLRUKey() {
        let lruKey = null;
        let lruTime = Infinity;
        
        for (const [key, time] of this.accessOrder) {
            if (time < lruTime) {
                lruTime = time;
                lruKey = key;
            }
        }
        
        return lruKey;
    }
    
    clear() {
        this.cache.clear();
        this.accessOrder.clear();
    }
}

// 创建记忆化原子
const createMemoizedAtom = (derivation, keyGenerator, maxCacheSize = 50) => {
    const cache = new MemoizeCache(maxCacheSize);
    
    return atom((get) => {
        const key = keyGenerator(get);
        const cached = cache.get(key);
        
        if (cached !== undefined) {
            return cached;
        }
        
        const result = derivation(get);
        cache.set(key, result);
        return result;
    });
};

// 缓存的碰撞检测原子
const cachedCollisionDetectionAtom = createMemoizedAtom(
    (get) => {
        const elements = get(elementsAtom);
        return new CollisionDetector(elements);
    },
    (get) => {
        const elements = get(elementsAtom);
        // 使用元素数量和最后修改时间作为缓存键
        return `collision_${elements.length}_${elements.map(el => el.lastModified || 0).join('_')}`;
    }
);

// 缓存的渲染数据原子
const cachedRenderDataAtom = createMemoizedAtom(
    (get) => {
        const elements = get(elementsAtom);
        const viewport = get(viewportAtom);
        
        return {
            renderCommands: generateRenderCommands(elements),
            transformMatrix: createTransformMatrix(viewport),
            clipBounds: calculateClipBounds(viewport)
        };
    },
    (get) => {
        const elements = get(elementsAtom);
        const viewport = get(viewportAtom);
        
        const elementsHash = hashArray(elements);
        const viewportHash = hashObject(viewport);
        
        return `render_${elementsHash}_${viewportHash}`;
    }
);

// 哈希函数
function hashArray(arr) {
    return arr.reduce((hash, item) => {
        return hash ^ hashObject(item);
    }, 0);
}

function hashObject(obj) {
    const str = JSON.stringify(obj, Object.keys(obj).sort());
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // 转换为32位整数
    }
    return hash;
}

// 渐进式计算原子
const createProgressiveAtom = (computation, chunkSize = 100) => {
    const resultAtom = atom(null);
    const progressAtom = atom(0);
    const isComputingAtom = atom(false);
    
    const computeAtom = atom(null, async (get, set, data) => {
        set(isComputingAtom, true);
        set(progressAtom, 0);
        
        const chunks = [];
        for (let i = 0; i < data.length; i += chunkSize) {
            chunks.push(data.slice(i, i + chunkSize));
        }
        
        let result = null;
        
        for (let i = 0; i < chunks.length; i++) {
            // 使用微任务让出执行权
            await new Promise(resolve => setTimeout(resolve, 0));
            
            const chunkResult = computation(chunks[i], result);
            result = chunkResult;
            
            set(progressAtom, (i + 1) / chunks.length);
        }
        
        set(resultAtom, result);
        set(isComputingAtom, false);
    });
    
    return {
        resultAtom,
        progressAtom,
        isComputingAtom,
        computeAtom
    };
};

// 大数据集处理示例
const {
    resultAtom: layoutResultAtom,
    progressAtom: layoutProgressAtom,
    isComputingAtom: isLayoutComputingAtom,
    computeAtom: computeLayoutAtom
} = createProgressiveAtom((chunk, previousResult) => {
    // 布局算法实现
    return performLayoutCalculation(chunk, previousResult);
});

function performLayoutCalculation(elements, previousLayout) {
    // 模拟复杂的布局计算
    return elements.map(element => ({
        ...element,
        computedPosition: calculateOptimalPosition(element, previousLayout)
    }));
}

function calculateOptimalPosition(element, layout) {
    // 模拟位置计算
    return {
        x: element.position.x,
        y: element.position.y
    };
}

// 增量更新原子
const createIncrementalAtom = (baseAtom, computeFunction) => {
    const lastVersionAtom = atom(0);
    const incrementalResultAtom = atom(null);
    
    const updateAtom = atom(null, (get, set) => {
        const currentData = get(baseAtom);
        const lastVersion = get(lastVersionAtom);
        const currentVersion = currentData.version || 0;
        
        if (currentVersion > lastVersion) {
            const previousResult = get(incrementalResultAtom);
            const changes = currentData.changes || [];
            
            const newResult = computeFunction(changes, previousResult, currentData);
            
            set(incrementalResultAtom, newResult);
            set(lastVersionAtom, currentVersion);
        }
    });
    
    return {
        resultAtom: incrementalResultAtom,
        updateAtom
    };
};

// 版本化数据原子
const versionedElementsAtom = atom({
    elements: [],
    version: 0,
    changes: []
});

// 增量索引更新
const {
    resultAtom: incrementalIndexAtom,
    updateAtom: updateIncrementalIndexAtom
} = createIncrementalAtom(versionedElementsAtom, (changes, previousIndex, data) => {
    const index = previousIndex || new Map();
    
    changes.forEach(change => {
        switch (change.type) {
            case 'add':
                index.set(change.element.id, change.element);
                break;
            case 'update':
                if (index.has(change.elementId)) {
                    const existing = index.get(change.elementId);
                    index.set(change.elementId, { ...existing, ...change.updates });
                }
                break;
            case 'delete':
                index.delete(change.elementId);
                break;
        }
    });
    
    return index;
});
```

## 4.4 完整状态管理系统集成

### 4.4.1 状态管理器组合

将所有状态管理组件整合成一个完整的系统。

```javascript
// 主状态管理器
class ExcalidrawStateManager {
    constructor() {
        this.atoms = this.createAtoms();
        this.actions = this.createActions();
        this.selectors = this.createSelectors();
        this.middleware = this.createMiddleware();
        
        this.setupAutoSave();
        this.setupPerformanceMonitoring();
    }
    
    createAtoms() {
        return {
            // 核心数据原子
            elements: atom([]),
            selectedElementIds: atom([]),
            viewport: persistentViewportAtom,
            currentTool: persistentToolAtom,
            
            // 历史记录原子
            history: atom({
                past: [],
                present: null,
                future: []
            }),
            
            // UI状态原子
            ui: atom({
                showGrid: true,
                showRulers: false,
                snapToGrid: true,
                gridSize: 20
            }),
            
            // 协作原子
            collaboration: collaborationAtom,
            
            // 性能原子
            performance: performanceAtom,
            
            // 异步状态原子
            fileOperations: atom({
                saving: false,
                loading: false,
                lastSaved: null
            })
        };
    }
    
    createActions() {
        const atoms = this.atoms;
        
        return {
            // 元素操作
            addElement: atom(null, (get, set, element) => {
                const elements = get(atoms.elements);
                const newElements = [...elements, { ...element, id: generateId() }];
                
                this.commitToHistory(set, atoms.elements, newElements);
            }),
            
            updateElement: atom(null, (get, set, { id, updates }) => {
                const elements = get(atoms.elements);
                const newElements = elements.map(el => 
                    el.id === id ? { ...el, ...updates, lastModified: Date.now() } : el
                );
                
                this.commitToHistory(set, atoms.elements, newElements);
            }),
            
            deleteElements: atom(null, (get, set, elementIds) => {
                const elements = get(atoms.elements);
                const selectedIds = get(atoms.selectedElementIds);
                
                const newElements = elements.filter(el => !elementIds.includes(el.id));
                const newSelection = selectedIds.filter(id => !elementIds.includes(id));
                
                this.batchUpdate(set, [
                    [atoms.elements, newElements],
                    [atoms.selectedElementIds, newSelection]
                ]);
            }),
            
            // 选择操作
            selectElements: atom(null, (get, set, elementIds, addToSelection = false) => {
                const currentSelection = get(atoms.selectedElementIds);
                
                let newSelection;
                if (addToSelection) {
                    newSelection = [...new Set([...currentSelection, ...elementIds])];
                } else {
                    newSelection = elementIds;
                }
                
                set(atoms.selectedElementIds, newSelection);
            }),
            
            clearSelection: atom(null, (get, set) => {
                set(atoms.selectedElementIds, []);
            }),
            
            // 视图操作
            updateViewport: atom(null, (get, set, updates) => {
                const viewport = get(atoms.viewport);
                set(atoms.viewport, { ...viewport, ...updates });
            }),
            
            zoomToFit: atom(null, (get, set) => {
                const elements = get(atoms.elements);
                if (elements.length === 0) return;
                
                const bounds = calculateSceneBounds(elements);
                const canvasSize = { width: 800, height: 600 }; // 应该从实际canvas获取
                
                const padding = 50;
                const scaleX = (canvasSize.width - padding * 2) / bounds.width;
                const scaleY = (canvasSize.height - padding * 2) / bounds.height;
                const scale = Math.min(scaleX, scaleY, 1);
                
                const offsetX = (canvasSize.width - bounds.width * scale) / 2 - bounds.left * scale;
                const offsetY = (canvasSize.height - bounds.height * scale) / 2 - bounds.top * scale;
                
                set(atoms.viewport, {
                    offset: { x: offsetX, y: offsetY },
                    scale: scale
                });
            }),
            
            // 历史记录操作
            undo: atom(null, (get, set) => {
                const history = get(atoms.history);
                if (history.past.length === 0) return;
                
                const previous = history.past[history.past.length - 1];
                const current = get(atoms.elements);
                
                set(atoms.history, {
                    past: history.past.slice(0, -1),
                    present: previous,
                    future: [current, ...history.future]
                });
                
                set(atoms.elements, previous);
            }),
            
            redo: atom(null, (get, set) => {
                const history = get(atoms.history);
                if (history.future.length === 0) return;
                
                const next = history.future[0];
                const current = get(atoms.elements);
                
                set(atoms.history, {
                    past: [...history.past, current],
                    present: next,
                    future: history.future.slice(1)
                });
                
                set(atoms.elements, next);
            }),
            
            // 文件操作
            saveFile: atom(null, async (get, set, filename) => {
                set(atoms.fileOperations, prev => ({ ...prev, saving: true }));
                
                try {
                    const elements = get(atoms.elements);
                    const viewport = get(atoms.viewport);
                    
                    const data = {
                        type: 'excalidraw',
                        version: 2,
                        elements,
                        appState: { viewport }
                    };
                    
                    await this.saveToFile(data, filename);
                    
                    set(atoms.fileOperations, prev => ({
                        ...prev,
                        saving: false,
                        lastSaved: Date.now()
                    }));
                } catch (error) {
                    set(atoms.fileOperations, prev => ({ ...prev, saving: false }));
                    throw error;
                }
            }),
            
            loadFile: atom(null, async (get, set, file) => {
                set(atoms.fileOperations, prev => ({ ...prev, loading: true }));
                
                try {
                    const data = await this.loadFromFile(file);
                    
                    this.batchUpdate(set, [
                        [atoms.elements, data.elements || []],
                        [atoms.viewport, data.appState?.viewport || { offset: { x: 0, y: 0 }, scale: 1 }],
                        [atoms.selectedElementIds, []]
                    ]);
                    
                    // 清空历史记录
                    set(atoms.history, {
                        past: [],
                        present: null,
                        future: []
                    });
                    
                    set(atoms.fileOperations, prev => ({ ...prev, loading: false }));
                } catch (error) {
                    set(atoms.fileOperations, prev => ({ ...prev, loading: false }));
                    throw error;
                }
            })
        };
    }
    
    createSelectors() {
        const atoms = this.atoms;
        
        return {
            selectedElements: atom((get) => {
                const elements = get(atoms.elements);
                const selectedIds = get(atoms.selectedElementIds);
                return elements.filter(el => selectedIds.includes(el.id));
            }),
            
            sceneBounds: atom((get) => {
                const elements = get(atoms.elements);
                return calculateSceneBounds(elements);
            }),
            
            canUndo: atom((get) => {
                const history = get(atoms.history);
                return history.past.length > 0;
            }),
            
            canRedo: atom((get) => {
                const history = get(atoms.history);
                return history.future.length > 0;
            }),
            
            statistics: statisticsAtom,
            
            renderData: cachedRenderDataAtom,
            
            spatialIndex: spatialIndexAtom
        };
    }
    
    createMiddleware() {
        return {
            // 变更日志中间件
            changeLogger: (get, set, atom, newValue, oldValue) => {
                if (process.env.NODE_ENV === 'development') {
                    console.log('State change:', {
                        atom: atom.toString(),
                        oldValue,
                        newValue,
                        timestamp: new Date().toISOString()
                    });
                }
            },
            
            // 性能监控中间件
            performanceMonitor: (get, set, atom, newValue, oldValue) => {
                const start = performance.now();
                const result = set(atom, newValue);
                const end = performance.now();
                
                if (end - start > 16) { // 超过一帧的时间
                    console.warn('Slow state update:', {
                        atom: atom.toString(),
                        duration: end - start
                    });
                }
                
                return result;
            },
            
            // 验证中间件
            validator: (get, set, atom, newValue, oldValue) => {
                // 验证元素数据完整性
                if (atom === this.atoms.elements && Array.isArray(newValue)) {
                    const isValid = newValue.every(el => 
                        el.id && el.type && el.position && typeof el.position.x === 'number'
                    );
                    
                    if (!isValid) {
                        console.error('Invalid elements data:', newValue);
                        return oldValue; // 阻止无效更新
                    }
                }
                
                return set(atom, newValue);
            }
        };
    }
    
    // 工具方法
    commitToHistory(set, elementsAtom, newElements) {
        const currentElements = get(elementsAtom);
        const history = get(this.atoms.history);
        
        // 添加到历史记录
        set(this.atoms.history, {
            past: [...history.past, currentElements].slice(-50), // 限制历史记录数量
            present: newElements,
            future: []
        });
        
        set(elementsAtom, newElements);
    }
    
    batchUpdate(set, updates) {
        // 批量更新多个原子
        updates.forEach(([atom, value]) => {
            set(atom, value);
        });
    }
    
    async saveToFile(data, filename) {
        const blob = new Blob([JSON.stringify(data, null, 2)], {
            type: 'application/json'
        });
        
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename || 'drawing.excalidraw';
        link.click();
        URL.revokeObjectURL(url);
    }
    
    async loadFromFile(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    resolve(data);
                } catch (error) {
                    reject(new Error('Invalid file format'));
                }
            };
            reader.onerror = () => reject(new Error('Failed to read file'));
            reader.readAsText(file);
        });
    }
    
    setupAutoSave() {
        // 设置自动保存
        setInterval(() => {
            const elements = get(this.atoms.elements);
            if (elements.length > 0) {
                saveToIndexedDB('autoSave', {
                    elements,
                    timestamp: Date.now()
                }).catch(console.error);
            }
        }, 30000);
    }
    
    setupPerformanceMonitoring() {
        // 设置性能监控
        const updatePerformance = () => {
            const now = performance.now();
            this.lastFrameTime = this.lastFrameTime || now;
            const deltaTime = now - this.lastFrameTime;
            const fps = 1000 / deltaTime;
            
            if (this.frameCount++ % 60 === 0) { // 每60帧更新一次
                set(this.atoms.performance, prev => ({
                    ...prev,
                    frameRate: Math.round(fps),
                    memoryUsage: performance.memory?.usedJSHeapSize || 0
                }));
            }
            
            this.lastFrameTime = now;
            requestAnimationFrame(updatePerformance);
        };
        
        this.frameCount = 0;
        updatePerformance();
    }
}

// 工具函数
function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

function calculateSceneBounds(elements) {
    if (elements.length === 0) {
        return { left: 0, top: 0, right: 0, bottom: 0, width: 0, height: 0 };
    }
    
    let left = Infinity, top = Infinity, right = -Infinity, bottom = -Infinity;
    
    elements.forEach(element => {
        const bounds = getElementBounds(element);
        left = Math.min(left, bounds.x);
        top = Math.min(top, bounds.y);
        right = Math.max(right, bounds.x + bounds.width);
        bottom = Math.max(bottom, bounds.y + bounds.height);
    });
    
    return {
        left,
        top,
        right,
        bottom,
        width: right - left,
        height: bottom - top
    };
}

// 创建全局状态管理器实例
const stateManager = new ExcalidrawStateManager();

// 导出用于React组件的hooks
export const useElements = () => useAtomValue(stateManager.atoms.elements);
export const useSelectedElements = () => useAtomValue(stateManager.selectors.selectedElements);
export const useViewport = () => useAtomValue(stateManager.atoms.viewport);
export const useAddElement = () => useSetAtom(stateManager.actions.addElement);
export const useUpdateElement = () => useSetAtom(stateManager.actions.updateElement);
export const useSelectElements = () => useSetAtom(stateManager.actions.selectElements);
export const useCanUndo = () => useAtomValue(stateManager.selectors.canUndo);
export const useCanRedo = () => useAtomValue(stateManager.selectors.canRedo);
export const useUndo = () => useSetAtom(stateManager.actions.undo);
export const useRedo = () => useSetAtom(stateManager.actions.redo);

export default stateManager;
```

## 总结

本章深入探讨了状态管理与数据流的构建，包括：

1. **状态管理基础理论** - 从原始状态管理到不可变状态管理的演进
2. **原子化状态管理** - 基于原子的状态拆分和组合
3. **Jotai深度应用** - 原子化状态库的高级使用模式
4. **状态派生和计算** - 高性能的计算属性和空间索引
5. **缓存和记忆化** - 优化状态计算性能的策略
6. **完整系统集成** - 将所有组件整合成完整的状态管理系统

这套状态管理系统为复杂的绘图应用提供了强大的数据管理能力，具有良好的性能特性和扩展性。在下一章中，我们将学习如何构建元素系统来管理各种图形元素。