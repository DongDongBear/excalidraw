# 第九章：协作系统与实时通信

## 9.1 协作系统概述

### 9.1.1 什么是协作编辑

协作编辑是多个用户同时编辑同一份文档的技术。在 Excalidraw 中，这意味着多个用户可以同时在同一个画布上绘制、编辑和移动元素，所有用户都能实时看到其他人的操作。

**核心挑战：**
- **网络延迟：** 操作需要时间传播到其他用户
- **并发冲突：** 多用户同时修改同一元素
- **数据一致性：** 确保所有用户看到相同的最终状态
- **用户体验：** 提供流畅的实时交互感受

### 9.1.2 协作系统的基本架构

```typescript
// 协作系统的基本组件
interface CollaborationSystem {
  // 通信层：负责数据传输
  transport: TransportLayer;
  
  // 同步引擎：处理冲突和一致性
  syncEngine: SyncEngine;
  
  // 用户管理：处理用户状态
  userManager: UserManager;
  
  // 冲突解决器：处理编辑冲突
  conflictResolver: ConflictResolver;
}

// 传输层接口
interface TransportLayer {
  connect(roomId: string): Promise<void>;
  disconnect(): void;
  
  // 发送操作
  sendOperation(operation: Operation): void;
  
  // 接收操作的回调
  onOperation(callback: (operation: Operation) => void): void;
  
  // 用户状态变化
  onUserJoin(callback: (user: User) => void): void;
  onUserLeave(callback: (userId: string) => void): void;
}
```

## 9.2 实时通信基础

### 9.2.1 WebSocket 通信实现

```typescript
// WebSocket 传输层实现
class WebSocketTransport implements TransportLayer {
  private ws: WebSocket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectDelay = 1000;
  
  private eventEmitter = new EventTarget();
  
  async connect(roomId: string): Promise<void> {
    const wsUrl = `${this.getWebSocketUrl()}/room/${roomId}`;
    
    return new Promise((resolve, reject) => {
      this.ws = new WebSocket(wsUrl);
      
      this.ws.onopen = () => {
        console.log('WebSocket connected');
        this.reconnectAttempts = 0;
        resolve();
      };
      
      this.ws.onclose = (event) => {
        console.log('WebSocket closed:', event.code);
        this.handleReconnect(roomId);
      };
      
      this.ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        reject(error);
      };
      
      this.ws.onmessage = (event) => {
        this.handleMessage(event.data);
      };
    });
  }
  
  disconnect(): void {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
  
  sendOperation(operation: Operation): void {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      const message: Message = {
        type: 'operation',
        data: operation,
        timestamp: Date.now()
      };
      
      this.ws.send(JSON.stringify(message));
    } else {
      // 缓存操作，等待重连后发送
      this.cacheOperation(operation);
    }
  }
  
  onOperation(callback: (operation: Operation) => void): void {
    this.eventEmitter.addEventListener('operation', (event: any) => {
      callback(event.detail);
    });
  }
  
  onUserJoin(callback: (user: User) => void): void {
    this.eventEmitter.addEventListener('userJoin', (event: any) => {
      callback(event.detail);
    });
  }
  
  onUserLeave(callback: (userId: string) => void): void {
    this.eventEmitter.addEventListener('userLeave', (event: any) => {
      callback(event.detail);
    });
  }
  
  private handleMessage(data: string): void {
    try {
      const message: Message = JSON.parse(data);
      
      switch (message.type) {
        case 'operation':
          this.eventEmitter.dispatchEvent(
            new CustomEvent('operation', { detail: message.data })
          );
          break;
          
        case 'userJoin':
          this.eventEmitter.dispatchEvent(
            new CustomEvent('userJoin', { detail: message.data })
          );
          break;
          
        case 'userLeave':
          this.eventEmitter.dispatchEvent(
            new CustomEvent('userLeave', { detail: message.data })
          );
          break;
          
        case 'cursorUpdate':
          this.eventEmitter.dispatchEvent(
            new CustomEvent('cursorUpdate', { detail: message.data })
          );
          break;
      }
    } catch (error) {
      console.error('Failed to parse message:', error);
    }
  }
  
  private async handleReconnect(roomId: string): Promise<void> {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
      
      console.log(`Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts})`);
      
      setTimeout(() => {
        this.connect(roomId).catch((error) => {
          console.error('Reconnection failed:', error);
        });
      }, delay);
    } else {
      console.error('Max reconnection attempts reached');
    }
  }
  
  private getWebSocketUrl(): string {
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    return `${protocol}//${window.location.host}/ws`;
  }
  
  private cacheOperation(operation: Operation): void {
    // 实现操作缓存逻辑
    // 在重连后重新发送缓存的操作
  }
}

// 消息类型定义
interface Message {
  type: 'operation' | 'userJoin' | 'userLeave' | 'cursorUpdate' | 'heartbeat';
  data: any;
  timestamp: number;
}
```

### 9.2.2 操作序列化与传输

```typescript
// 操作类型定义
type OperationType = 
  | 'createElement'
  | 'updateElement' 
  | 'deleteElement'
  | 'moveElement'
  | 'resizeElement'
  | 'styleElement';

interface Operation {
  id: string;
  type: OperationType;
  userId: string;
  timestamp: number;
  elementId?: string;
  data: any;
  
  // 操作转换用的向量时钟
  vectorClock: VectorClock;
}

// 向量时钟实现
class VectorClock {
  private clocks: Map<string, number> = new Map();
  
  constructor(userId: string) {
    this.clocks.set(userId, 0);
  }
  
  tick(userId: string): void {
    const current = this.clocks.get(userId) || 0;
    this.clocks.set(userId, current + 1);
  }
  
  update(other: VectorClock): void {
    for (const [userId, clock] of other.clocks) {
      const current = this.clocks.get(userId) || 0;
      this.clocks.set(userId, Math.max(current, clock));
    }
  }
  
  happensBefore(other: VectorClock): boolean {
    let hasSmaller = false;
    
    for (const [userId, clock] of this.clocks) {
      const otherClock = other.clocks.get(userId) || 0;
      
      if (clock > otherClock) {
        return false;
      }
      
      if (clock < otherClock) {
        hasSmaller = true;
      }
    }
    
    return hasSmaller;
  }
  
  isConcurrent(other: VectorClock): boolean {
    return !this.happensBefore(other) && !other.happensBefore(this);
  }
  
  clone(): VectorClock {
    const newClock = new VectorClock('');
    newClock.clocks = new Map(this.clocks);
    return newClock;
  }
}

// 操作序列化器
class OperationSerializer {
  static serialize(operation: Operation): string {
    return JSON.stringify({
      ...operation,
      vectorClock: this.serializeVectorClock(operation.vectorClock)
    });
  }
  
  static deserialize(data: string): Operation {
    const parsed = JSON.parse(data);
    return {
      ...parsed,
      vectorClock: this.deserializeVectorClock(parsed.vectorClock)
    };
  }
  
  private static serializeVectorClock(clock: VectorClock): any {
    return {
      clocks: Array.from((clock as any).clocks.entries())
    };
  }
  
  private static deserializeVectorClock(data: any): VectorClock {
    const clock = new VectorClock('');
    (clock as any).clocks = new Map(data.clocks);
    return clock;
  }
}
```

## 9.3 操作转换算法

### 9.3.1 基础操作转换理论

操作转换（Operational Transformation, OT）是协作编辑中解决冲突的核心算法。它确保在存在并发操作的情况下，所有用户最终看到相同的文档状态。

**转换函数的基本原理：**
```typescript
// 转换函数：transform(op1, op2) => [op1', op2']
// 其中 op1' 是 op1 在应用 op2 后的转换版本
// op2' 是 op2 在应用 op1 后的转换版本

interface TransformResult {
  transformedOp1: Operation;
  transformedOp2: Operation;
}

interface OperationTransformer {
  transform(op1: Operation, op2: Operation): TransformResult;
}
```

### 9.3.2 元素操作转换实现

```typescript
class ExcalidrawOperationTransformer implements OperationTransformer {
  transform(op1: Operation, op2: Operation): TransformResult {
    // 如果操作的向量时钟不冲突，无需转换
    if (!op1.vectorClock.isConcurrent(op2.vectorClock)) {
      return {
        transformedOp1: op1,
        transformedOp2: op2
      };
    }
    
    // 根据操作类型进行转换
    return this.transformByType(op1, op2);
  }
  
  private transformByType(op1: Operation, op2: Operation): TransformResult {
    const key = `${op1.type}-${op2.type}`;
    
    switch (key) {
      case 'updateElement-updateElement':
        return this.transformUpdateUpdate(op1, op2);
        
      case 'updateElement-deleteElement':
        return this.transformUpdateDelete(op1, op2);
        
      case 'deleteElement-updateElement':
        return this.transformDeleteUpdate(op1, op2);
        
      case 'deleteElement-deleteElement':
        return this.transformDeleteDelete(op1, op2);
        
      case 'moveElement-moveElement':
        return this.transformMoveMove(op1, op2);
        
      case 'moveElement-resizeElement':
        return this.transformMoveResize(op1, op2);
        
      case 'resizeElement-moveElement':
        return this.transformResizeMove(op1, op2);
        
      case 'resizeElement-resizeElement':
        return this.transformResizeResize(op1, op2);
        
      default:
        // 默认情况：如果操作不冲突，保持原样
        return {
          transformedOp1: op1,
          transformedOp2: op2
        };
    }
  }
  
  // 两个更新操作的转换
  private transformUpdateUpdate(op1: Operation, op2: Operation): TransformResult {
    // 如果操作不同的元素，无需转换
    if (op1.elementId !== op2.elementId) {
      return { transformedOp1: op1, transformedOp2: op2 };
    }
    
    // 对同一元素的属性更新进行合并
    const merged1 = { ...op1 };
    const merged2 = { ...op2 };
    
    // 使用时间戳决定优先级
    if (op1.timestamp > op2.timestamp) {
      // op1 优先，op2 的部分属性可能被覆盖
      merged2.data = this.mergeElementUpdates(op2.data, op1.data);
    } else {
      // op2 优先，op1 的部分属性可能被覆盖
      merged1.data = this.mergeElementUpdates(op1.data, op2.data);
    }
    
    return {
      transformedOp1: merged1,
      transformedOp2: merged2
    };
  }
  
  // 更新和删除操作的转换
  private transformUpdateDelete(op1: Operation, op2: Operation): TransformResult {
    if (op1.elementId === op2.elementId) {
      // 更新一个被删除的元素 -> 更新操作变为无效
      return {
        transformedOp1: { ...op1, type: 'noOp' as any },
        transformedOp2: op2
      };
    }
    
    return { transformedOp1: op1, transformedOp2: op2 };
  }
  
  // 删除和更新操作的转换
  private transformDeleteUpdate(op1: Operation, op2: Operation): TransformResult {
    if (op1.elementId === op2.elementId) {
      // 删除一个被更新的元素 -> 更新操作变为无效
      return {
        transformedOp1: op1,
        transformedOp2: { ...op2, type: 'noOp' as any }
      };
    }
    
    return { transformedOp1: op1, transformedOp2: op2 };
  }
  
  // 两个删除操作的转换
  private transformDeleteDelete(op1: Operation, op2: Operation): TransformResult {
    if (op1.elementId === op2.elementId) {
      // 删除同一个元素 -> 第二个删除操作变为无效
      const laterOp = op1.timestamp > op2.timestamp ? op1 : op2;
      const earlierOp = op1.timestamp > op2.timestamp ? op2 : op1;
      
      return op1.timestamp > op2.timestamp
        ? {
            transformedOp1: op1,
            transformedOp2: { ...op2, type: 'noOp' as any }
          }
        : {
            transformedOp1: { ...op1, type: 'noOp' as any },
            transformedOp2: op2
          };
    }
    
    return { transformedOp1: op1, transformedOp2: op2 };
  }
  
  // 两个移动操作的转换
  private transformMoveMove(op1: Operation, op2: Operation): TransformResult {
    if (op1.elementId !== op2.elementId) {
      return { transformedOp1: op1, transformedOp2: op2 };
    }
    
    // 对同一元素的移动操作进行合成
    const finalPosition = this.calculateFinalPosition(
      op1.data.position,
      op2.data.position,
      op1.timestamp,
      op2.timestamp
    );
    
    // 较新的操作保留，较旧的操作变为相对移动
    if (op1.timestamp > op2.timestamp) {
      return {
        transformedOp1: op1,
        transformedOp2: {
          ...op2,
          data: { ...op2.data, position: finalPosition }
        }
      };
    } else {
      return {
        transformedOp1: {
          ...op1,
          data: { ...op1.data, position: finalPosition }
        },
        transformedOp2: op2
      };
    }
  }
  
  // 移动和缩放操作的转换
  private transformMoveResize(op1: Operation, op2: Operation): TransformResult {
    if (op1.elementId !== op2.elementId) {
      return { transformedOp1: op1, transformedOp2: op2 };
    }
    
    // 移动和缩放可以同时进行，但需要调整坐标
    const resizeData = op2.data;
    const moveData = op1.data;
    
    // 根据缩放调整移动位置
    const adjustedMove = {
      ...moveData,
      position: this.adjustPositionForResize(
        moveData.position,
        resizeData.oldBounds,
        resizeData.newBounds
      )
    };
    
    return {
      transformedOp1: { ...op1, data: adjustedMove },
      transformedOp2: op2
    };
  }
  
  // 缩放和移动操作的转换
  private transformResizeMove(op1: Operation, op2: Operation): TransformResult {
    if (op1.elementId !== op2.elementId) {
      return { transformedOp1: op1, transformedOp2: op2 };
    }
    
    // 缩放后再移动，位置需要基于新的bounds
    const resizeData = op1.data;
    const moveData = op2.data;
    
    return {
      transformedOp1: op1,
      transformedOp2: {
        ...op2,
        data: {
          ...moveData,
          position: this.adjustPositionForPreviousResize(
            moveData.position,
            resizeData.newBounds
          )
        }
      }
    };
  }
  
  // 两个缩放操作的转换
  private transformResizeResize(op1: Operation, op2: Operation): TransformResult {
    if (op1.elementId !== op2.elementId) {
      return { transformedOp1: op1, transformedOp2: op2 };
    }
    
    // 连续的缩放操作需要合成
    const resize1 = op1.data;
    const resize2 = op2.data;
    
    const composedResize = this.composeResizeOperations(resize1, resize2);
    
    // 较新的操作包含合成结果
    if (op1.timestamp > op2.timestamp) {
      return {
        transformedOp1: { ...op1, data: composedResize },
        transformedOp2: { ...op2, type: 'noOp' as any }
      };
    } else {
      return {
        transformedOp1: { ...op1, type: 'noOp' as any },
        transformedOp2: { ...op2, data: composedResize }
      };
    }
  }
  
  // 工具方法
  private mergeElementUpdates(update1: any, update2: any): any {
    // 深度合并元素更新，处理属性冲突
    const merged = { ...update1 };
    
    for (const [key, value] of Object.entries(update2)) {
      if (key in merged) {
        // 属性冲突，使用特定规则解决
        merged[key] = this.resolvePropertyConflict(key, merged[key], value);
      } else {
        merged[key] = value;
      }
    }
    
    return merged;
  }
  
  private resolvePropertyConflict(property: string, value1: any, value2: any): any {
    // 根据属性类型决定冲突解决策略
    switch (property) {
      case 'strokeColor':
      case 'backgroundColor':
      case 'fillStyle':
        // 样式属性：使用最新值
        return value2;
        
      case 'opacity':
        // 透明度：取平均值
        return (value1 + value2) / 2;
        
      case 'text':
        // 文本：简单合并
        return value1 + value2;
        
      default:
        return value2;
    }
  }
  
  private calculateFinalPosition(pos1: any, pos2: any, ts1: number, ts2: number): any {
    // 基于时间戳和位置计算最终位置
    if (ts1 > ts2) {
      return pos1;
    } else {
      return pos2;
    }
  }
  
  private adjustPositionForResize(position: any, oldBounds: any, newBounds: any): any {
    // 根据缩放调整位置
    const scaleX = newBounds.width / oldBounds.width;
    const scaleY = newBounds.height / oldBounds.height;
    
    return {
      x: position.x * scaleX,
      y: position.y * scaleY
    };
  }
  
  private adjustPositionForPreviousResize(position: any, newBounds: any): any {
    // 基于新bounds调整位置
    return {
      x: position.x + newBounds.x,
      y: position.y + newBounds.y
    };
  }
  
  private composeResizeOperations(resize1: any, resize2: any): any {
    // 合成两个缩放操作
    return {
      oldBounds: resize1.oldBounds,
      newBounds: resize2.newBounds,
      scaleX: resize1.scaleX * resize2.scaleX,
      scaleY: resize1.scaleY * resize2.scaleY
    };
  }
}
```

## 9.4 同步引擎实现

### 9.4.1 同步引擎核心逻辑

```typescript
class SyncEngine {
  private localOperations: Operation[] = [];
  private remoteOperations: Operation[] = [];
  private pendingOperations: Operation[] = [];
  
  private transformer: OperationTransformer;
  private transport: TransportLayer;
  private vectorClock: VectorClock;
  
  constructor(
    private userId: string,
    transformer: OperationTransformer,
    transport: TransportLayer
  ) {
    this.transformer = transformer;
    this.transport = transport;
    this.vectorClock = new VectorClock(userId);
    
    this.setupTransportListeners();
  }
  
  // 应用本地操作
  applyLocalOperation(operation: Omit<Operation, 'id' | 'vectorClock'>): Operation {
    // 生成操作ID和向量时钟
    const fullOperation: Operation = {
      ...operation,
      id: this.generateOperationId(),
      vectorClock: this.vectorClock.clone()
    };
    
    // 更新向量时钟
    this.vectorClock.tick(this.userId);
    
    // 添加到本地操作队列
    this.localOperations.push(fullOperation);
    this.pendingOperations.push(fullOperation);
    
    // 发送到服务器
    this.transport.sendOperation(fullOperation);
    
    return fullOperation;
  }
  
  // 接收远程操作
  receiveRemoteOperation(operation: Operation): void {
    // 更新向量时钟
    this.vectorClock.update(operation.vectorClock);
    
    // 转换操作以解决冲突
    const transformedOperation = this.transformRemoteOperation(operation);
    
    if (transformedOperation) {
      // 应用转换后的操作
      this.applyTransformedOperation(transformedOperation);
      
      // 添加到远程操作历史
      this.remoteOperations.push(transformedOperation);
      
      // 重新转换待确认的本地操作
      this.retransformPendingOperations();
    }
  }
  
  // 确认操作（服务器回显）
  acknowledgeOperation(operationId: string): void {
    const index = this.pendingOperations.findIndex(op => op.id === operationId);
    if (index !== -1) {
      this.pendingOperations.splice(index, 1);
    }
  }
  
  private transformRemoteOperation(operation: Operation): Operation | null {
    let transformedOp = operation;
    
    // 与所有待确认的本地操作进行转换
    for (const localOp of this.pendingOperations) {
      const result = this.transformer.transform(localOp, transformedOp);
      transformedOp = result.transformedOp2;
      
      // 如果操作被转换为无效操作，返回null
      if ((transformedOp as any).type === 'noOp') {
        return null;
      }
    }
    
    return transformedOp;
  }
  
  private retransformPendingOperations(): void {
    // 重新转换所有待确认的本地操作
    // 这是为了确保操作的正确顺序
    
    const newPendingOps: Operation[] = [];
    
    for (const pendingOp of this.pendingOperations) {
      let transformedOp = pendingOp;
      
      // 与最近的远程操作进行转换
      const latestRemoteOp = this.remoteOperations[this.remoteOperations.length - 1];
      if (latestRemoteOp) {
        const result = this.transformer.transform(transformedOp, latestRemoteOp);
        transformedOp = result.transformedOp1;
      }
      
      if ((transformedOp as any).type !== 'noOp') {
        newPendingOps.push(transformedOp);
      }
    }
    
    this.pendingOperations = newPendingOps;
  }
  
  private applyTransformedOperation(operation: Operation): void {
    // 将转换后的操作应用到本地状态
    // 这里需要与应用的状态管理系统集成
    this.dispatchOperationToApp(operation);
  }
  
  private dispatchOperationToApp(operation: Operation): void {
    // 发送操作给应用程序处理
    const event = new CustomEvent('collaborativeOperation', {
      detail: operation
    });
    
    window.dispatchEvent(event);
  }
  
  private setupTransportListeners(): void {
    this.transport.onOperation((operation) => {
      if (operation.userId !== this.userId) {
        this.receiveRemoteOperation(operation);
      } else {
        // 服务器确认我们的操作
        this.acknowledgeOperation(operation.id);
      }
    });
  }
  
  private generateOperationId(): string {
    return `${this.userId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  
  // 获取同步状态
  getSyncStatus(): {
    pendingCount: number;
    isConnected: boolean;
    lastSyncTime: number;
  } {
    return {
      pendingCount: this.pendingOperations.length,
      isConnected: this.transport.isConnected?.() ?? false,
      lastSyncTime: this.vectorClock.getMaxClock()
    };
  }
}
```

### 9.4.2 冲突解决策略

```typescript
// 高级冲突解决器
class AdvancedConflictResolver {
  resolveElementConflict(
    localElement: ExcalidrawElement,
    remoteElement: ExcalidrawElement,
    localOperation: Operation,
    remoteOperation: Operation
  ): ExcalidrawElement {
    
    // 策略1：基于时间戳的LWW (Last Write Wins)
    if (localOperation.timestamp !== remoteOperation.timestamp) {
      return localOperation.timestamp > remoteOperation.timestamp 
        ? localElement 
        : remoteElement;
    }
    
    // 策略2：基于用户ID的确定性解决
    if (localOperation.userId !== remoteOperation.userId) {
      return localOperation.userId > remoteOperation.userId 
        ? localElement 
        : remoteElement;
    }
    
    // 策略3：基于操作类型的优先级
    const priority = this.getOperationPriority(localOperation.type);
    const remotePriority = this.getOperationPriority(remoteOperation.type);
    
    if (priority !== remotePriority) {
      return priority > remotePriority ? localElement : remoteElement;
    }
    
    // 策略4：智能合并（适用于某些属性）
    return this.smartMergeElements(localElement, remoteElement);
  }
  
  private getOperationPriority(type: OperationType): number {
    const priorities = {
      'deleteElement': 10,    // 删除优先级最高
      'createElement': 9,     // 创建次之
      'updateElement': 5,     // 更新中等
      'moveElement': 3,       // 移动较低
      'styleElement': 1       // 样式最低
    };
    
    return priorities[type] || 0;
  }
  
  private smartMergeElements(
    element1: ExcalidrawElement, 
    element2: ExcalidrawElement
  ): ExcalidrawElement {
    // 对可合并的属性进行智能合并
    return {
      ...element1,
      // 位置：取中点
      x: (element1.x + element2.x) / 2,
      y: (element1.y + element2.y) / 2,
      
      // 尺寸：取平均值
      width: (element1.width + element2.width) / 2,
      height: (element1.height + element2.height) / 2,
      
      // 样式：保持较新的
      strokeColor: element2.strokeColor || element1.strokeColor,
      backgroundColor: element2.backgroundColor || element1.backgroundColor,
      
      // 文本：合并
      text: element1.type === 'text' && element2.type === 'text' 
        ? (element1 as any).text + ' ' + (element2 as any).text
        : (element1 as any).text || (element2 as any).text
    };
  }
}
```

## 9.5 用户状态管理

### 9.5.1 用户管理器实现

```typescript
interface CollaborativeUser {
  id: string;
  name: string;
  color: string;
  avatar?: string;
  cursor?: {
    x: number;
    y: number;
  };
  selection?: string[]; // 选中的元素ID
  isActive: boolean;
  lastSeen: number;
}

class UserManager {
  private users = new Map<string, CollaborativeUser>();
  private currentUser: CollaborativeUser;
  private eventEmitter = new EventTarget();
  
  constructor(
    private userId: string,
    private transport: TransportLayer
  ) {
    this.currentUser = this.createUser(userId, 'Me');
    this.setupTransportListeners();
    this.startHeartbeat();
  }
  
  // 获取当前用户
  getCurrentUser(): CollaborativeUser {
    return this.currentUser;
  }
  
  // 获取所有用户
  getAllUsers(): CollaborativeUser[] {
    return Array.from(this.users.values()).filter(user => user.isActive);
  }
  
  // 更新当前用户的光标位置
  updateCursor(x: number, y: number): void {
    this.currentUser.cursor = { x, y };
    this.broadcastCursorUpdate();
  }
  
  // 更新当前用户的选择
  updateSelection(elementIds: string[]): void {
    this.currentUser.selection = elementIds;
    this.broadcastSelectionUpdate();
  }
  
  // 用户加入
  private handleUserJoin(user: CollaborativeUser): void {
    this.users.set(user.id, user);
    this.emitUserEvent('userJoin', user);
  }
  
  // 用户离开
  private handleUserLeave(userId: string): void {
    const user = this.users.get(userId);
    if (user) {
      user.isActive = false;
      this.emitUserEvent('userLeave', user);
      
      // 延迟删除用户数据，以防网络问题导致的误判
      setTimeout(() => {
        this.users.delete(userId);
      }, 30000);
    }
  }
  
  // 处理光标更新
  private handleCursorUpdate(data: { userId: string; cursor: { x: number; y: number } }): void {
    const user = this.users.get(data.userId);
    if (user && user.id !== this.userId) {
      user.cursor = data.cursor;
      user.lastSeen = Date.now();
      this.emitUserEvent('cursorUpdate', user);
    }
  }
  
  // 处理选择更新
  private handleSelectionUpdate(data: { userId: string; selection: string[] }): void {
    const user = this.users.get(data.userId);
    if (user && user.id !== this.userId) {
      user.selection = data.selection;
      user.lastSeen = Date.now();
      this.emitUserEvent('selectionUpdate', user);
    }
  }
  
  // 广播光标更新
  private broadcastCursorUpdate(): void {
    this.transport.sendMessage({
      type: 'cursorUpdate',
      data: {
        userId: this.userId,
        cursor: this.currentUser.cursor
      }
    });
  }
  
  // 广播选择更新
  private broadcastSelectionUpdate(): void {
    this.transport.sendMessage({
      type: 'selectionUpdate',
      data: {
        userId: this.userId,
        selection: this.currentUser.selection
      }
    });
  }
  
  // 创建用户
  private createUser(id: string, name: string): CollaborativeUser {
    return {
      id,
      name,
      color: this.generateUserColor(id),
      isActive: true,
      lastSeen: Date.now()
    };
  }
  
  // 生成用户颜色
  private generateUserColor(userId: string): string {
    const colors = [
      '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', 
      '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F'
    ];
    
    let hash = 0;
    for (let i = 0; i < userId.length; i++) {
      hash = userId.charCodeAt(i) + ((hash << 5) - hash);
    }
    
    return colors[Math.abs(hash) % colors.length];
  }
  
  // 设置传输层监听器
  private setupTransportListeners(): void {
    this.transport.onUserJoin((user) => this.handleUserJoin(user));
    this.transport.onUserLeave((userId) => this.handleUserLeave(userId));
    this.transport.onMessage('cursorUpdate', (data) => this.handleCursorUpdate(data));
    this.transport.onMessage('selectionUpdate', (data) => this.handleSelectionUpdate(data));
  }
  
  // 开始心跳
  private startHeartbeat(): void {
    setInterval(() => {
      this.transport.sendMessage({
        type: 'heartbeat',
        data: {
          userId: this.userId,
          timestamp: Date.now()
        }
      });
      
      // 清理不活跃的用户
      this.cleanupInactiveUsers();
    }, 10000); // 每10秒发送心跳
  }
  
  // 清理不活跃用户
  private cleanupInactiveUsers(): void {
    const now = Date.now();
    const timeout = 60000; // 60秒超时
    
    for (const [userId, user] of this.users) {
      if (now - user.lastSeen > timeout) {
        this.handleUserLeave(userId);
      }
    }
  }
  
  // 发送用户事件
  private emitUserEvent(eventType: string, user: CollaborativeUser): void {
    this.eventEmitter.dispatchEvent(
      new CustomEvent(eventType, { detail: user })
    );
  }
  
  // 监听用户事件
  on(eventType: string, callback: (user: CollaborativeUser) => void): void {
    this.eventEmitter.addEventListener(eventType, (event: any) => {
      callback(event.detail);
    });
  }
}
```

### 9.5.2 用户感知界面组件

```typescript
// React 组件：用户光标显示
const UserCursors: React.FC<{
  users: CollaborativeUser[];
  viewportTransform: Transform2D;
}> = ({ users, viewportTransform }) => {
  return (
    <div className="user-cursors">
      {users.map(user => (
        user.cursor && (
          <UserCursor
            key={user.id}
            user={user}
            position={viewportTransform.transformPoint(user.cursor)}
          />
        )
      ))}
    </div>
  );
};

const UserCursor: React.FC<{
  user: CollaborativeUser;
  position: { x: number; y: number };
}> = ({ user, position }) => {
  return (
    <div
      className="user-cursor"
      style={{
        position: 'absolute',
        left: position.x,
        top: position.y,
        pointerEvents: 'none',
        zIndex: 1000
      }}
    >
      {/* 光标指针 */}
      <svg width="24" height="24" viewBox="0 0 24 24">
        <path
          d="M0 0 L18 6 L8 10 L6 18 Z"
          fill={user.color}
          stroke="white"
          strokeWidth="1"
        />
      </svg>
      
      {/* 用户名标签 */}
      <div
        className="user-label"
        style={{
          backgroundColor: user.color,
          color: 'white',
          padding: '2px 6px',
          borderRadius: '4px',
          fontSize: '12px',
          marginTop: '2px',
          whiteSpace: 'nowrap'
        }}
      >
        {user.name}
      </div>
    </div>
  );
};

// 用户选择指示器
const UserSelectionIndicators: React.FC<{
  users: CollaborativeUser[];
  elements: ExcalidrawElement[];
}> = ({ users, elements }) => {
  return (
    <svg className="user-selection-indicators">
      {users.map(user => (
        user.selection?.map(elementId => {
          const element = elements.find(el => el.id === elementId);
          if (!element) return null;
          
          return (
            <SelectionIndicator
              key={`${user.id}-${elementId}`}
              element={element}
              color={user.color}
              userName={user.name}
            />
          );
        })
      ))}
    </svg>
  );
};

const SelectionIndicator: React.FC<{
  element: ExcalidrawElement;
  color: string;
  userName: string;
}> = ({ element, color, userName }) => {
  const bounds = getElementBounds(element);
  
  return (
    <g>
      {/* 选择边框 */}
      <rect
        x={bounds.x - 2}
        y={bounds.y - 2}
        width={bounds.width + 4}
        height={bounds.height + 4}
        fill="none"
        stroke={color}
        strokeWidth="2"
        strokeDasharray="5,5"
        opacity="0.8"
      />
      
      {/* 用户标签 */}
      <text
        x={bounds.x}
        y={bounds.y - 8}
        fill={color}
        fontSize="12"
        fontWeight="bold"
      >
        {userName}
      </text>
    </g>
  );
};

// 协作状态栏
const CollaborationStatusBar: React.FC<{
  users: CollaborativeUser[];
  syncStatus: {
    pendingCount: number;
    isConnected: boolean;
    lastSyncTime: number;
  };
}> = ({ users, syncStatus }) => {
  return (
    <div className="collaboration-status-bar">
      {/* 连接状态 */}
      <div className={`connection-status ${syncStatus.isConnected ? 'connected' : 'disconnected'}`}>
        <div className="status-dot" />
        {syncStatus.isConnected ? 'Connected' : 'Disconnected'}
      </div>
      
      {/* 待同步操作数 */}
      {syncStatus.pendingCount > 0 && (
        <div className="pending-operations">
          {syncStatus.pendingCount} pending
        </div>
      )}
      
      {/* 在线用户 */}
      <div className="online-users">
        {users.slice(0, 5).map(user => (
          <div
            key={user.id}
            className="user-avatar"
            style={{ backgroundColor: user.color }}
            title={user.name}
          >
            {user.name.charAt(0)}
          </div>
        ))}
        
        {users.length > 5 && (
          <div className="user-count">
            +{users.length - 5}
          </div>
        )}
      </div>
    </div>
  );
};
```

## 9.6 协作系统集成

### 9.6.1 完整的协作系统类

```typescript
class CollaborationSystem {
  private transport: TransportLayer;
  private syncEngine: SyncEngine;
  private userManager: UserManager;
  private conflictResolver: AdvancedConflictResolver;
  
  private isInitialized = false;
  private roomId: string | null = null;
  
  constructor(private userId: string) {
    this.transport = new WebSocketTransport();
    this.syncEngine = new SyncEngine(
      userId,
      new ExcalidrawOperationTransformer(),
      this.transport
    );
    this.userManager = new UserManager(userId, this.transport);
    this.conflictResolver = new AdvancedConflictResolver();
    
    this.setupEventListeners();
  }
  
  // 加入协作房间
  async joinRoom(roomId: string): Promise<void> {
    if (this.isInitialized && this.roomId === roomId) {
      return;
    }
    
    try {
      await this.transport.connect(roomId);
      this.roomId = roomId;
      this.isInitialized = true;
      
      console.log(`Joined collaboration room: ${roomId}`);
    } catch (error) {
      console.error('Failed to join room:', error);
      throw error;
    }
  }
  
  // 离开协作房间
  leaveRoom(): void {
    if (this.isInitialized) {
      this.transport.disconnect();
      this.isInitialized = false;
      this.roomId = null;
      
      console.log('Left collaboration room');
    }
  }
  
  // 发送本地操作
  sendOperation(operation: Omit<Operation, 'id' | 'vectorClock'>): void {
    if (!this.isInitialized) {
      console.warn('Collaboration system not initialized');
      return;
    }
    
    this.syncEngine.applyLocalOperation(operation);
  }
  
  // 更新用户光标
  updateCursor(x: number, y: number): void {
    if (this.isInitialized) {
      this.userManager.updateCursor(x, y);
    }
  }
  
  // 更新用户选择
  updateSelection(elementIds: string[]): void {
    if (this.isInitialized) {
      this.userManager.updateSelection(elementIds);
    }
  }
  
  // 获取协作状态
  getStatus(): {
    isConnected: boolean;
    roomId: string | null;
    userCount: number;
    syncStatus: any;
  } {
    return {
      isConnected: this.isInitialized,
      roomId: this.roomId,
      userCount: this.userManager.getAllUsers().length,
      syncStatus: this.syncEngine.getSyncStatus()
    };
  }
  
  // 获取所有用户
  getUsers(): CollaborativeUser[] {
    return this.userManager.getAllUsers();
  }
  
  // 事件监听
  on(eventType: string, callback: Function): void {
    this.userManager.on(eventType, callback);
  }
  
  private setupEventListeners(): void {
    // 监听协作操作
    window.addEventListener('collaborativeOperation', (event: any) => {
      const operation = event.detail as Operation;
      this.handleRemoteOperation(operation);
    });
  }
  
  private handleRemoteOperation(operation: Operation): void {
    // 将远程操作转发给应用程序
    const event = new CustomEvent('applyRemoteOperation', {
      detail: operation
    });
    
    window.dispatchEvent(event);
  }
}

// 单例实例
let collaborationInstance: CollaborationSystem | null = null;

export const getCollaborationSystem = (userId?: string): CollaborationSystem => {
  if (!collaborationInstance && userId) {
    collaborationInstance = new CollaborationSystem(userId);
  }
  
  if (!collaborationInstance) {
    throw new Error('Collaboration system not initialized');
  }
  
  return collaborationInstance;
};
```

### 9.6.2 与 Excalidraw 应用的集成

```typescript
// 扩展 Excalidraw 应用以支持协作
const CollaborativeExcalidrawApp: React.FC = () => {
  const [elements, setElements] = useState<ExcalidrawElement[]>([]);
  const [appState, setAppState] = useState<AppState>(getDefaultAppState());
  const [users, setUsers] = useState<CollaborativeUser[]>([]);
  const [isCollabActive, setIsCollabActive] = useState(false);
  
  const collaboration = useRef<CollaborationSystem | null>(null);
  const userId = useRef(generateUserId());
  
  // 初始化协作
  const initCollaboration = useCallback(async (roomId: string) => {
    try {
      collaboration.current = getCollaborationSystem(userId.current);
      
      // 设置事件监听
      collaboration.current.on('userJoin', (user) => {
        setUsers(prev => [...prev.filter(u => u.id !== user.id), user]);
      });
      
      collaboration.current.on('userLeave', (user) => {
        setUsers(prev => prev.filter(u => u.id !== user.id));
      });
      
      collaboration.current.on('cursorUpdate', (user) => {
        setUsers(prev => prev.map(u => u.id === user.id ? user : u));
      });
      
      // 监听远程操作
      window.addEventListener('applyRemoteOperation', handleRemoteOperation);
      
      // 加入房间
      await collaboration.current.joinRoom(roomId);
      setIsCollabActive(true);
      
    } catch (error) {
      console.error('Failed to initialize collaboration:', error);
    }
  }, []);
  
  // 处理远程操作
  const handleRemoteOperation = useCallback((event: any) => {
    const operation = event.detail as Operation;
    
    switch (operation.type) {
      case 'createElement':
        setElements(prev => [...prev, operation.data]);
        break;
        
      case 'updateElement':
        setElements(prev => prev.map(el => 
          el.id === operation.elementId 
            ? { ...el, ...operation.data }
            : el
        ));
        break;
        
      case 'deleteElement':
        setElements(prev => prev.filter(el => el.id !== operation.elementId));
        break;
        
      case 'moveElement':
        setElements(prev => prev.map(el => 
          el.id === operation.elementId
            ? { ...el, x: operation.data.x, y: operation.data.y }
            : el
        ));
        break;
    }
  }, []);
  
  // 处理本地元素变化
  const handleElementsChange = useCallback((newElements: ExcalidrawElement[]) => {
    if (!isCollabActive) {
      setElements(newElements);
      return;
    }
    
    // 检测变化并发送操作
    const operations = detectElementChanges(elements, newElements);
    
    operations.forEach(operation => {
      collaboration.current?.sendOperation(operation);
    });
    
    setElements(newElements);
  }, [elements, isCollabActive]);
  
  // 处理指针移动
  const handlePointerMove = useCallback((event: React.PointerEvent) => {
    if (isCollabActive) {
      const rect = event.currentTarget.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      
      collaboration.current?.updateCursor(x, y);
    }
  }, [isCollabActive]);
  
  // 处理选择变化
  const handleSelectionChange = useCallback((selectedIds: string[]) => {
    if (isCollabActive) {
      collaboration.current?.updateSelection(selectedIds);
    }
  }, [isCollabActive]);
  
  return (
    <div className="collaborative-excalidraw">
      {/* 协作控制栏 */}
      <CollaborationControls
        onStartCollab={initCollaboration}
        isActive={isCollabActive}
        onStopCollab={() => {
          collaboration.current?.leaveRoom();
          setIsCollabActive(false);
          setUsers([]);
        }}
      />
      
      {/* 协作状态栏 */}
      {isCollabActive && (
        <CollaborationStatusBar
          users={users}
          syncStatus={collaboration.current?.getStatus().syncStatus || {
            pendingCount: 0,
            isConnected: false,
            lastSyncTime: 0
          }}
        />
      )}
      
      {/* 主画布区域 */}
      <div 
        className="canvas-container"
        onPointerMove={handlePointerMove}
      >
        <Excalidraw
          elements={elements}
          appState={appState}
          onChange={handleElementsChange}
          onAppStateChange={setAppState}
          onSelectionChange={handleSelectionChange}
        />
        
        {/* 用户光标和选择指示器 */}
        {isCollabActive && (
          <>
            <UserCursors 
              users={users} 
              viewportTransform={getViewportTransform(appState)}
            />
            <UserSelectionIndicators 
              users={users} 
              elements={elements}
            />
          </>
        )}
      </div>
    </div>
  );
};

// 检测元素变化的工具函数
function detectElementChanges(
  oldElements: ExcalidrawElement[],
  newElements: ExcalidrawElement[]
): Omit<Operation, 'id' | 'vectorClock'>[] {
  const operations: Omit<Operation, 'id' | 'vectorClock'>[] = [];
  
  const oldMap = new Map(oldElements.map(el => [el.id, el]));
  const newMap = new Map(newElements.map(el => [el.id, el]));
  
  // 检测新增元素
  for (const [id, element] of newMap) {
    if (!oldMap.has(id)) {
      operations.push({
        type: 'createElement',
        userId: '',
        timestamp: Date.now(),
        elementId: id,
        data: element
      });
    }
  }
  
  // 检测删除元素
  for (const [id] of oldMap) {
    if (!newMap.has(id)) {
      operations.push({
        type: 'deleteElement',
        userId: '',
        timestamp: Date.now(),
        elementId: id,
        data: null
      });
    }
  }
  
  // 检测修改元素
  for (const [id, newElement] of newMap) {
    const oldElement = oldMap.get(id);
    if (oldElement && !deepEqual(oldElement, newElement)) {
      const changes = getDifferences(oldElement, newElement);
      
      operations.push({
        type: 'updateElement',
        userId: '',
        timestamp: Date.now(),
        elementId: id,
        data: changes
      });
    }
  }
  
  return operations;
}

// 工具函数
function generateUserId(): string {
  return `user-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

function deepEqual(obj1: any, obj2: any): boolean {
  return JSON.stringify(obj1) === JSON.stringify(obj2);
}

function getDifferences(oldObj: any, newObj: any): any {
  const changes: any = {};
  
  for (const key in newObj) {
    if (oldObj[key] !== newObj[key]) {
      changes[key] = newObj[key];
    }
  }
  
  return changes;
}

function getViewportTransform(appState: AppState): Transform2D {
  return new Transform2D(
    appState.zoom.value,
    0,
    0,
    appState.zoom.value,
    appState.scrollX,
    appState.scrollY
  );
}
```

## 9.7 实践项目：协作绘图板

### 9.7.1 项目结构

```
collaborative-drawing/
├── src/
│   ├── collaboration/
│   │   ├── CollaborationSystem.ts     # 协作系统主类
│   │   ├── SyncEngine.ts              # 同步引擎
│   │   ├── UserManager.ts             # 用户管理
│   │   ├── WebSocketTransport.ts      # WebSocket传输
│   │   └── OperationTransformer.ts    # 操作转换
│   ├── components/
│   │   ├── CollaborativeCanvas.tsx    # 协作画布
│   │   ├── UserCursors.tsx           # 用户光标
│   │   ├── CollaborationStatus.tsx    # 协作状态
│   │   └── RoomControls.tsx          # 房间控制
│   ├── server/
│   │   ├── CollaborationServer.ts     # 协作服务器
│   │   ├── RoomManager.ts            # 房间管理
│   │   └── OperationHandler.ts       # 操作处理
│   └── utils/
│       ├── VectorClock.ts            # 向量时钟
│       └── OperationSerializer.ts    # 操作序列化
```

### 9.7.2 服务器端实现

```typescript
// 协作服务器实现
import { WebSocketServer, WebSocket } from 'ws';
import { IncomingMessage } from 'http';

interface RoomConnection {
  userId: string;
  userName: string;
  ws: WebSocket;
  lastSeen: number;
}

interface Room {
  id: string;
  connections: Map<string, RoomConnection>;
  operations: Operation[];
  createdAt: number;
}

class CollaborationServer {
  private wss: WebSocketServer;
  private rooms = new Map<string, Room>();
  
  constructor(port: number) {
    this.wss = new WebSocketServer({ port });
    this.setupServer();
    
    console.log(`Collaboration server started on port ${port}`);
  }
  
  private setupServer(): void {
    this.wss.on('connection', (ws: WebSocket, req: IncomingMessage) => {
      console.log('New WebSocket connection');
      
      ws.on('message', (data: Buffer) => {
        try {
          const message = JSON.parse(data.toString());
          this.handleMessage(ws, message);
        } catch (error) {
          console.error('Failed to parse message:', error);
        }
      });
      
      ws.on('close', () => {
        this.handleDisconnection(ws);
      });
      
      ws.on('error', (error) => {
        console.error('WebSocket error:', error);
      });
    });
    
    // 定期清理空房间
    setInterval(() => {
      this.cleanupEmptyRooms();
    }, 60000);
  }
  
  private handleMessage(ws: WebSocket, message: any): void {
    switch (message.type) {
      case 'joinRoom':
        this.handleJoinRoom(ws, message.data);
        break;
        
      case 'operation':
        this.handleOperation(ws, message.data);
        break;
        
      case 'cursorUpdate':
        this.handleCursorUpdate(ws, message.data);
        break;
        
      case 'heartbeat':
        this.handleHeartbeat(ws, message.data);
        break;
    }
  }
  
  private handleJoinRoom(ws: WebSocket, data: {
    roomId: string;
    userId: string;
    userName: string;
  }): void {
    const { roomId, userId, userName } = data;
    
    // 获取或创建房间
    let room = this.rooms.get(roomId);
    if (!room) {
      room = {
        id: roomId,
        connections: new Map(),
        operations: [],
        createdAt: Date.now()
      };
      this.rooms.set(roomId, room);
    }
    
    // 添加连接到房间
    const connection: RoomConnection = {
      userId,
      userName,
      ws,
      lastSeen: Date.now()
    };
    
    room.connections.set(userId, connection);
    
    // 为WebSocket添加房间信息
    (ws as any).roomId = roomId;
    (ws as any).userId = userId;
    
    // 发送历史操作
    room.operations.forEach(operation => {
      this.sendToClient(ws, {
        type: 'operation',
        data: operation
      });
    });
    
    // 通知其他用户有新用户加入
    this.broadcastToRoom(roomId, {
      type: 'userJoin',
      data: {
        id: userId,
        name: userName,
        color: this.generateUserColor(userId),
        isActive: true,
        lastSeen: Date.now()
      }
    }, userId);
    
    // 发送当前房间用户列表
    const users = Array.from(room.connections.values()).map(conn => ({
      id: conn.userId,
      name: conn.userName,
      color: this.generateUserColor(conn.userId),
      isActive: true,
      lastSeen: conn.lastSeen
    }));
    
    this.sendToClient(ws, {
      type: 'roomUsers',
      data: users
    });
    
    console.log(`User ${userName} joined room ${roomId}`);
  }
  
  private handleOperation(ws: WebSocket, operation: Operation): void {
    const roomId = (ws as any).roomId;
    const userId = (ws as any).userId;
    
    if (!roomId || !userId) {
      return;
    }
    
    const room = this.rooms.get(roomId);
    if (!room) {
      return;
    }
    
    // 添加操作到房间历史
    room.operations.push(operation);
    
    // 限制历史操作数量
    if (room.operations.length > 1000) {
      room.operations = room.operations.slice(-800);
    }
    
    // 广播操作到房间内其他用户
    this.broadcastToRoom(roomId, {
      type: 'operation',
      data: operation
    }, userId);
    
    // 回显给发送者确认
    this.sendToClient(ws, {
      type: 'operationAck',
      data: { operationId: operation.id }
    });
  }
  
  private handleCursorUpdate(ws: WebSocket, data: any): void {
    const roomId = (ws as any).roomId;
    const userId = (ws as any).userId;
    
    if (!roomId || !userId) {
      return;
    }
    
    // 广播光标更新
    this.broadcastToRoom(roomId, {
      type: 'cursorUpdate',
      data: data
    }, userId);
  }
  
  private handleHeartbeat(ws: WebSocket, data: any): void {
    const roomId = (ws as any).roomId;
    const userId = (ws as any).userId;
    
    if (!roomId || !userId) {
      return;
    }
    
    const room = this.rooms.get(roomId);
    if (room) {
      const connection = room.connections.get(userId);
      if (connection) {
        connection.lastSeen = Date.now();
      }
    }
  }
  
  private handleDisconnection(ws: WebSocket): void {
    const roomId = (ws as any).roomId;
    const userId = (ws as any).userId;
    
    if (!roomId || !userId) {
      return;
    }
    
    const room = this.rooms.get(roomId);
    if (room) {
      room.connections.delete(userId);
      
      // 通知其他用户该用户离开
      this.broadcastToRoom(roomId, {
        type: 'userLeave',
        data: userId
      }, userId);
      
      console.log(`User ${userId} left room ${roomId}`);
    }
  }
  
  private broadcastToRoom(roomId: string, message: any, excludeUserId?: string): void {
    const room = this.rooms.get(roomId);
    if (!room) {
      return;
    }
    
    for (const [userId, connection] of room.connections) {
      if (userId !== excludeUserId && connection.ws.readyState === WebSocket.OPEN) {
        this.sendToClient(connection.ws, message);
      }
    }
  }
  
  private sendToClient(ws: WebSocket, message: any): void {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(message));
    }
  }
  
  private generateUserColor(userId: string): string {
    const colors = [
      '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', 
      '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F'
    ];
    
    let hash = 0;
    for (let i = 0; i < userId.length; i++) {
      hash = userId.charCodeAt(i) + ((hash << 5) - hash);
    }
    
    return colors[Math.abs(hash) % colors.length];
  }
  
  private cleanupEmptyRooms(): void {
    const now = Date.now();
    const maxAge = 24 * 60 * 60 * 1000; // 24小时
    
    for (const [roomId, room] of this.rooms) {
      // 删除空房间或超时房间
      if (room.connections.size === 0 || (now - room.createdAt > maxAge)) {
        this.rooms.delete(roomId);
        console.log(`Cleaned up room ${roomId}`);
      }
    }
  }
}

// 启动服务器
const server = new CollaborationServer(8080);
```

### 9.7.3 完整的协作画板应用

```typescript
// 主应用组件
import React, { useState, useCallback, useEffect, useRef } from 'react';
import { CollaborationSystem } from './collaboration/CollaborationSystem';
import { CollaborativeCanvas } from './components/CollaborativeCanvas';
import { RoomControls } from './components/RoomControls';

const CollaborativeDrawingApp: React.FC = () => {
  const [isCollaborating, setIsCollaborating] = useState(false);
  const [roomId, setRoomId] = useState<string>('');
  const [users, setUsers] = useState<CollaborativeUser[]>([]);
  const [elements, setElements] = useState<ExcalidrawElement[]>([]);
  
  const collaboration = useRef<CollaborationSystem | null>(null);
  const userId = useRef(`user-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`);
  
  // 初始化协作
  const startCollaboration = useCallback(async (newRoomId: string, userName: string) => {
    try {
      collaboration.current = new CollaborationSystem(userId.current);
      
      // 设置事件监听
      collaboration.current.on('userJoin', (user: CollaborativeUser) => {
        setUsers(prev => [...prev.filter(u => u.id !== user.id), user]);
      });
      
      collaboration.current.on('userLeave', (user: CollaborativeUser) => {
        setUsers(prev => prev.filter(u => u.id !== user.id));
      });
      
      collaboration.current.on('cursorUpdate', (user: CollaborativeUser) => {
        setUsers(prev => prev.map(u => u.id === user.id ? user : u));
      });
      
      // 监听远程操作
      window.addEventListener('applyRemoteOperation', handleRemoteOperation);
      
      // 加入房间
      await collaboration.current.joinRoom(newRoomId);
      
      setIsCollaborating(true);
      setRoomId(newRoomId);
      
    } catch (error) {
      console.error('Failed to start collaboration:', error);
      alert('Failed to join collaboration room');
    }
  }, []);
  
  // 停止协作
  const stopCollaboration = useCallback(() => {
    if (collaboration.current) {
      collaboration.current.leaveRoom();
      collaboration.current = null;
    }
    
    setIsCollaborating(false);
    setRoomId('');
    setUsers([]);
    
    window.removeEventListener('applyRemoteOperation', handleRemoteOperation);
  }, []);
  
  // 处理远程操作
  const handleRemoteOperation = useCallback((event: any) => {
    const operation = event.detail as Operation;
    
    switch (operation.type) {
      case 'createElement':
        setElements(prev => [...prev, operation.data]);
        break;
        
      case 'updateElement':
        setElements(prev => prev.map(el => 
          el.id === operation.elementId 
            ? { ...el, ...operation.data }
            : el
        ));
        break;
        
      case 'deleteElement':
        setElements(prev => prev.filter(el => el.id !== operation.elementId));
        break;
    }
  }, []);
  
  // 处理本地操作
  const handleLocalOperation = useCallback((operation: Omit<Operation, 'id' | 'vectorClock'>) => {
    if (collaboration.current) {
      collaboration.current.sendOperation(operation);
    }
  }, []);
  
  // 清空画布
  const clearCanvas = useCallback(() => {
    if (elements.length > 0) {
      elements.forEach(element => {
        handleLocalOperation({
          type: 'deleteElement',
          userId: userId.current,
          timestamp: Date.now(),
          elementId: element.id,
          data: null
        });
      });
    }
    
    setElements([]);
  }, [elements, handleLocalOperation]);
  
  return (
    <div className="collaborative-drawing-app">
      <header className="app-header">
        <h1>Collaborative Drawing Board</h1>
        
        <RoomControls
          isCollaborating={isCollaborating}
          roomId={roomId}
          onStartCollaboration={startCollaboration}
          onStopCollaboration={stopCollaboration}
          userCount={users.length}
        />
      </header>
      
      <main className="app-content">
        <CollaborativeCanvas
          elements={elements}
          onElementsChange={setElements}
          onLocalOperation={handleLocalOperation}
          users={users}
          isCollaborating={isCollaborating}
          onCursorMove={(x, y) => collaboration.current?.updateCursor(x, y)}
          onSelectionChange={(ids) => collaboration.current?.updateSelection(ids)}
        />
        
        {isCollaborating && (
          <div className="collaboration-info">
            <div className="room-info">
              Room: {roomId} | Users: {users.length + 1}
            </div>
            
            <div className="users-list">
              {users.map(user => (
                <div 
                  key={user.id} 
                  className="user-indicator"
                  style={{ backgroundColor: user.color }}
                >
                  {user.name}
                </div>
              ))}
            </div>
            
            <button onClick={clearCanvas} className="clear-button">
              Clear Canvas
            </button>
          </div>
        )}
      </main>
    </div>
  );
};

export default CollaborativeDrawingApp;
```

## 9.8 章节总结

在本章中，我们深入学习了协作系统的实现，包括：

### 核心概念
- **实时协作原理**：多用户同时编辑的基本概念
- **操作转换算法**：解决并发冲突的核心技术
- **向量时钟**：分布式系统中的时间同步机制
- **冲突解决策略**：处理不同类型操作冲突的方法

### 技术实现
- **WebSocket通信**：实时双向通信的实现
- **同步引擎**：管理本地和远程操作的同步
- **用户状态管理**：跟踪多用户的在线状态和交互
- **操作序列化**：网络传输中的数据格式处理

### 用户体验
- **实时光标显示**：直观展示其他用户的操作位置
- **选择状态指示**：显示用户正在编辑的元素
- **连接状态反馈**：网络状态和同步进度的可视化
- **冲突处理**：平滑处理操作冲突，保持用户体验

### 系统架构
- **模块化设计**：清晰的职责分离和接口定义
- **可扩展性**：支持不同类型的协作操作
- **容错能力**：网络断开重连和数据恢复
- **性能优化**：减少网络传输和计算开销

协作系统是现代应用的重要特性，通过本章的学习，我们掌握了从基础通信到高级冲突解决的完整技术栈，能够为各种应用添加实时协作功能。