# 第5章：元素系统与图形抽象

## 学习目标
通过本章学习，你将掌握：
- 图形元素的抽象设计模式
- 元素类型系统和继承体系
- 图形属性和样式系统
- 元素的几何计算和变换
- 边界检测和碰撞系统
- 元素序列化和反序列化
- 组合元素和复杂图形
- 元素生命周期管理
- 性能优化策略

## 5.1 元素抽象基础

### 5.1.1 基础元素接口设计

设计一个灵活且可扩展的元素系统，支持各种图形类型。

```javascript
// 基础元素接口
class BaseElement {
    constructor(props = {}) {
        // 基础属性
        this.id = props.id || this.generateId();
        this.type = props.type || 'unknown';
        this.version = props.version || 1;
        this.createdAt = props.createdAt || Date.now();
        this.updatedAt = props.updatedAt || Date.now();
        
        // 几何属性
        this.position = props.position || { x: 0, y: 0 };
        this.rotation = props.rotation || 0;
        this.scale = props.scale || { x: 1, y: 1 };
        
        // 视觉属性
        this.style = {
            fill: props.style?.fill || 'transparent',
            stroke: props.style?.stroke || '#000000',
            strokeWidth: props.style?.strokeWidth || 2,
            opacity: props.style?.opacity || 1,
            visible: props.style?.visible ?? true,
            ...props.style
        };
        
        // 交互属性
        this.selectable = props.selectable ?? true;
        this.draggable = props.draggable ?? true;
        this.resizable = props.resizable ?? true;
        this.rotatable = props.rotatable ?? true;
        
        // 层级属性
        this.zIndex = props.zIndex || 0;
        this.locked = props.locked || false;
        this.groupId = props.groupId || null;
        
        // 元数据
        this.metadata = props.metadata || {};
        
        // 缓存属性
        this._boundingBox = null;
        this._boundingBoxVersion = 0;
        this._renderCache = null;
        this._renderCacheVersion = 0;
    }
    
    generateId() {
        return `${this.type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    // 抽象方法 - 子类必须实现
    getBoundingBox() {
        throw new Error('getBoundingBox() must be implemented by subclass');
    }
    
    render(ctx, viewport) {
        throw new Error('render() must be implemented by subclass');
    }
    
    containsPoint(point) {
        throw new Error('containsPoint() must be implemented by subclass');
    }
    
    // 通用方法
    clone() {
        const cloned = new this.constructor(this.serialize());
        cloned.id = this.generateId(); // 生成新ID
        return cloned;
    }
    
    serialize() {
        return {
            id: this.id,
            type: this.type,
            version: this.version,
            createdAt: this.createdAt,
            updatedAt: this.updatedAt,
            position: { ...this.position },
            rotation: this.rotation,
            scale: { ...this.scale },
            style: { ...this.style },
            selectable: this.selectable,
            draggable: this.draggable,
            resizable: this.resizable,
            rotatable: this.rotatable,
            zIndex: this.zIndex,
            locked: this.locked,
            groupId: this.groupId,
            metadata: { ...this.metadata }
        };
    }
    
    update(props) {
        const oldVersion = this.version;
        
        Object.assign(this, props);
        this.updatedAt = Date.now();
        this.version++;
        
        // 清除缓存
        if (this.geometryChanged(props)) {
            this._boundingBoxVersion = this.version;
        }
        
        this._renderCacheVersion = this.version;
        
        return oldVersion !== this.version;
    }
    
    geometryChanged(props) {
        return props.position || props.rotation || props.scale || 
               this.specificGeometryChanged?.(props);
    }
    
    // 变换方法
    translate(dx, dy) {
        this.position.x += dx;
        this.position.y += dy;
        this.invalidateCache();
    }
    
    rotate(angle, center = null) {
        if (center) {
            // 绕指定点旋转
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            
            const dx = this.position.x - center.x;
            const dy = this.position.y - center.y;
            
            this.position.x = center.x + dx * cos - dy * sin;
            this.position.y = center.y + dx * sin + dy * cos;
        }
        
        this.rotation += angle;
        this.invalidateCache();
    }
    
    scaleBy(sx, sy = sx, center = null) {
        if (center) {
            // 绕指定点缩放
            const dx = this.position.x - center.x;
            const dy = this.position.y - center.y;
            
            this.position.x = center.x + dx * sx;
            this.position.y = center.y + dy * sy;
        }
        
        this.scale.x *= sx;
        this.scale.y *= sy;
        this.invalidateCache();
    }
    
    // 缓存管理
    invalidateCache() {
        this._boundingBoxVersion = this.version;
        this._renderCacheVersion = this.version;
    }
    
    getCachedBoundingBox() {
        if (!this._boundingBox || this._boundingBoxVersion < this.version) {
            this._boundingBox = this.getBoundingBox();
            this._boundingBoxVersion = this.version;
        }
        return this._boundingBox;
    }
    
    // 变换矩阵
    getTransformMatrix() {
        const m = new DOMMatrix();
        
        // 应用变换：平移 -> 旋转 -> 缩放
        m.translateSelf(this.position.x, this.position.y);
        if (this.rotation !== 0) {
            m.rotateSelf(this.rotation * 180 / Math.PI);
        }
        if (this.scale.x !== 1 || this.scale.y !== 1) {
            m.scaleSelf(this.scale.x, this.scale.y);
        }
        
        return m;
    }
    
    // 应用变换到点
    transformPoint(point) {
        const matrix = this.getTransformMatrix();
        const domPoint = new DOMPoint(point.x, point.y);
        const transformed = matrix.transformPoint(domPoint);
        return { x: transformed.x, y: transformed.y };
    }
    
    // 逆变换点
    inverseTransformPoint(point) {
        const matrix = this.getTransformMatrix().inverse();
        const domPoint = new DOMPoint(point.x, point.y);
        const transformed = matrix.transformPoint(domPoint);
        return { x: transformed.x, y: transformed.y };
    }
}

// 元素工厂
class ElementFactory {
    constructor() {
        this.elementTypes = new Map();
        this.registerBuiltinTypes();
    }
    
    registerElementType(type, ElementClass) {
        this.elementTypes.set(type, ElementClass);
    }
    
    createElement(type, props = {}) {
        const ElementClass = this.elementTypes.get(type);
        if (!ElementClass) {
            throw new Error(`Unknown element type: ${type}`);
        }
        
        return new ElementClass({ ...props, type });
    }
    
    deserializeElement(data) {
        return this.createElement(data.type, data);
    }
    
    registerBuiltinTypes() {
        // 稍后实现各种具体元素类型
    }
    
    getAvailableTypes() {
        return Array.from(this.elementTypes.keys());
    }
    
    getElementSchema(type) {
        const ElementClass = this.elementTypes.get(type);
        return ElementClass?.schema || null;
    }
}

// 全局工厂实例
const elementFactory = new ElementFactory();
```

### 5.1.2 样式系统设计

创建一个强大的样式系统，支持继承、主题和动态样式。

```javascript
// 样式管理器
class StyleManager {
    constructor() {
        this.themes = new Map();
        this.defaultTheme = 'default';
        this.currentTheme = 'default';
        
        this.setupDefaultTheme();
    }
    
    setupDefaultTheme() {
        this.registerTheme('default', {
            colors: {
                primary: '#1971c2',
                secondary: '#495057',
                success: '#2f9e44',
                warning: '#f08c00',
                error: '#e03131',
                background: '#ffffff',
                surface: '#f8f9fa',
                text: '#212529',
                border: '#dee2e6'
            },
            
            elements: {
                rectangle: {
                    fill: 'transparent',
                    stroke: '#1971c2',
                    strokeWidth: 2,
                    opacity: 1
                },
                ellipse: {
                    fill: 'transparent',
                    stroke: '#1971c2',
                    strokeWidth: 2,
                    opacity: 1
                },
                line: {
                    stroke: '#1971c2',
                    strokeWidth: 2,
                    opacity: 1
                },
                text: {
                    fill: '#212529',
                    fontSize: 16,
                    fontFamily: 'Arial, sans-serif',
                    fontWeight: 'normal',
                    textAlign: 'left'
                }
            },
            
            effects: {
                shadow: {
                    enabled: false,
                    color: 'rgba(0, 0, 0, 0.1)',
                    blur: 4,
                    offsetX: 2,
                    offsetY: 2
                },
                glow: {
                    enabled: false,
                    color: '#1971c2',
                    blur: 8
                }
            }
        });
        
        this.registerTheme('dark', {
            colors: {
                primary: '#339af0',
                secondary: '#adb5bd',
                success: '#51cf66',
                warning: '#ffd43b',
                error: '#ff6b6b',
                background: '#212529',
                surface: '#343a40',
                text: '#f8f9fa',
                border: '#495057'
            },
            
            elements: {
                rectangle: {
                    fill: 'transparent',
                    stroke: '#339af0',
                    strokeWidth: 2,
                    opacity: 1
                },
                ellipse: {
                    fill: 'transparent',
                    stroke: '#339af0',
                    strokeWidth: 2,
                    opacity: 1
                },
                line: {
                    stroke: '#339af0',
                    strokeWidth: 2,
                    opacity: 1
                },
                text: {
                    fill: '#f8f9fa',
                    fontSize: 16,
                    fontFamily: 'Arial, sans-serif',
                    fontWeight: 'normal',
                    textAlign: 'left'
                }
            }
        });
    }
    
    registerTheme(name, theme) {
        this.themes.set(name, theme);
    }
    
    setTheme(name) {
        if (this.themes.has(name)) {
            this.currentTheme = name;
            this.notifyThemeChange(name);
        }
    }
    
    getTheme(name = null) {
        return this.themes.get(name || this.currentTheme);
    }
    
    getElementStyle(elementType, customStyle = {}) {
        const theme = this.getTheme();
        const baseStyle = theme.elements[elementType] || {};
        
        return {
            ...baseStyle,
            ...customStyle
        };
    }
    
    getColor(colorName) {
        const theme = this.getTheme();
        return theme.colors[colorName] || colorName;
    }
    
    // 样式计算和继承
    computeStyle(element, parentStyle = null) {
        const baseStyle = this.getElementStyle(element.type);
        let computedStyle = { ...baseStyle };
        
        // 应用父级样式（用于组合元素）
        if (parentStyle) {
            computedStyle = this.inheritStyle(computedStyle, parentStyle);
        }
        
        // 应用元素自身样式
        computedStyle = { ...computedStyle, ...element.style };
        
        // 解析颜色变量
        computedStyle = this.resolveColors(computedStyle);
        
        // 应用动画和状态样式
        if (element._animationStyle) {
            computedStyle = { ...computedStyle, ...element._animationStyle };
        }
        
        return computedStyle;
    }
    
    inheritStyle(childStyle, parentStyle) {
        const inherited = { ...childStyle };
        
        // 继承规则
        const inheritableProperties = [
            'opacity', 'fontFamily', 'fontSize', 'fontWeight',
            'textAlign', 'lineHeight'
        ];
        
        inheritableProperties.forEach(prop => {
            if (childStyle[prop] === 'inherit' && parentStyle[prop] !== undefined) {
                inherited[prop] = parentStyle[prop];
            }
        });
        
        // 相对透明度
        if (parentStyle.opacity !== undefined && childStyle.opacity !== undefined) {
            inherited.opacity = parentStyle.opacity * childStyle.opacity;
        }
        
        return inherited;
    }
    
    resolveColors(style) {
        const resolved = { ...style };
        
        Object.keys(resolved).forEach(key => {
            if (typeof resolved[key] === 'string' && resolved[key].startsWith('$')) {
                const colorName = resolved[key].substring(1);
                resolved[key] = this.getColor(colorName);
            }
        });
        
        return resolved;
    }
    
    // 样式预设
    createStylePreset(name, style) {
        if (!this.stylePresets) {
            this.stylePresets = new Map();
        }
        this.stylePresets.set(name, style);
    }
    
    getStylePreset(name) {
        return this.stylePresets?.get(name) || {};
    }
    
    // 事件监听
    onThemeChange(callback) {
        if (!this.themeChangeListeners) {
            this.themeChangeListeners = [];
        }
        this.themeChangeListeners.push(callback);
    }
    
    notifyThemeChange(themeName) {
        if (this.themeChangeListeners) {
            this.themeChangeListeners.forEach(callback => {
                callback(themeName, this.getTheme(themeName));
            });
        }
    }
}

// 全局样式管理器
const styleManager = new StyleManager();

// 样式工具函数
class StyleUtils {
    static parseColor(color) {
        // 简化的颜色解析
        if (color.startsWith('#')) {
            return this.parseHexColor(color);
        } else if (color.startsWith('rgb')) {
            return this.parseRgbColor(color);
        } else if (color.startsWith('hsl')) {
            return this.parseHslColor(color);
        }
        
        return { r: 0, g: 0, b: 0, a: 1 };
    }
    
    static parseHexColor(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16),
            a: result[4] ? parseInt(result[4], 16) / 255 : 1
        } : null;
    }
    
    static parseRgbColor(rgb) {
        const match = rgb.match(/rgba?\(([^)]+)\)/);
        if (!match) return null;
        
        const values = match[1].split(',').map(v => parseFloat(v.trim()));
        return {
            r: values[0],
            g: values[1],
            b: values[2],
            a: values[3] !== undefined ? values[3] : 1
        };
    }
    
    static parseHslColor(hsl) {
        // HSL解析实现
        const match = hsl.match(/hsla?\(([^)]+)\)/);
        if (!match) return null;
        
        const values = match[1].split(',').map(v => parseFloat(v.trim()));
        const [h, s, l, a = 1] = values;
        
        return this.hslToRgb(h, s / 100, l / 100, a);
    }
    
    static hslToRgb(h, s, l, a = 1) {
        h /= 360;
        
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        };
        
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        
        return {
            r: Math.round(hue2rgb(p, q, h + 1/3) * 255),
            g: Math.round(hue2rgb(p, q, h) * 255),
            b: Math.round(hue2rgb(p, q, h - 1/3) * 255),
            a
        };
    }
    
    static colorToString(color) {
        if (color.a === undefined || color.a === 1) {
            return `rgb(${color.r}, ${color.g}, ${color.b})`;
        }
        return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;
    }
    
    static blendColors(color1, color2, ratio) {
        const c1 = this.parseColor(color1);
        const c2 = this.parseColor(color2);
        
        if (!c1 || !c2) return color1;
        
        return this.colorToString({
            r: Math.round(c1.r * (1 - ratio) + c2.r * ratio),
            g: Math.round(c1.g * (1 - ratio) + c2.g * ratio),
            b: Math.round(c1.b * (1 - ratio) + c2.b * ratio),
            a: c1.a * (1 - ratio) + c2.a * ratio
        });
    }
    
    static adjustOpacity(color, opacity) {
        const parsed = this.parseColor(color);
        if (!parsed) return color;
        
        parsed.a = opacity;
        return this.colorToString(parsed);
    }
}
```

## 5.2 具体元素类型实现

### 5.2.1 基础几何图形

实现矩形、椭圆、直线等基础几何图形。

```javascript
// 矩形元素
class RectangleElement extends BaseElement {
    constructor(props = {}) {
        super({ ...props, type: 'rectangle' });
        
        this.size = props.size || { width: 100, height: 80 };
        this.cornerRadius = props.cornerRadius || 0;
    }
    
    static schema = {
        type: 'rectangle',
        properties: {
            size: { type: 'object', properties: { width: 'number', height: 'number' } },
            cornerRadius: { type: 'number', min: 0 }
        }
    };
    
    getBoundingBox() {
        const { x, y } = this.position;
        const { width, height } = this.size;
        
        return {
            x: x - width / 2,
            y: y - height / 2,
            width,
            height,
            left: x - width / 2,
            top: y - height / 2,
            right: x + width / 2,
            bottom: y + height / 2
        };
    }
    
    containsPoint(point) {
        const bbox = this.getCachedBoundingBox();
        
        // 简单边界检查
        if (point.x < bbox.left || point.x > bbox.right ||
            point.y < bbox.top || point.y > bbox.bottom) {
            return false;
        }
        
        // 如果有旋转，需要进行逆变换
        if (this.rotation !== 0) {
            const localPoint = this.inverseTransformPoint(point);
            const localBbox = {
                left: -this.size.width / 2,
                top: -this.size.height / 2,
                right: this.size.width / 2,
                bottom: this.size.height / 2
            };
            
            return localPoint.x >= localBbox.left && localPoint.x <= localBbox.right &&
                   localPoint.y >= localBbox.top && localPoint.y <= localBbox.bottom;
        }
        
        return true;
    }
    
    render(ctx, viewport) {
        const style = styleManager.computeStyle(this);
        
        ctx.save();
        
        // 应用变换
        const matrix = this.getTransformMatrix();
        ctx.setTransform(matrix);
        
        // 设置样式
        this.applyStyle(ctx, style);
        
        // 绘制矩形
        const { width, height } = this.size;
        const x = -width / 2;
        const y = -height / 2;
        
        if (this.cornerRadius > 0) {
            this.drawRoundedRect(ctx, x, y, width, height, this.cornerRadius);
        } else {
            ctx.rect(x, y, width, height);
        }
        
        // 填充和描边
        if (style.fill !== 'transparent') {
            ctx.fill();
        }
        if (style.stroke !== 'transparent' && style.strokeWidth > 0) {
            ctx.stroke();
        }
        
        ctx.restore();
    }
    
    drawRoundedRect(ctx, x, y, width, height, radius) {
        const r = Math.min(radius, width / 2, height / 2);
        
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + width - r, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + r);
        ctx.lineTo(x + width, y + height - r);
        ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
        ctx.lineTo(x + r, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
    }
    
    applyStyle(ctx, style) {
        ctx.fillStyle = style.fill;
        ctx.strokeStyle = style.stroke;
        ctx.lineWidth = style.strokeWidth;
        ctx.globalAlpha = style.opacity;
        
        // 线条样式
        if (style.lineDash) {
            ctx.setLineDash(style.lineDash);
        }
        if (style.lineCap) {
            ctx.lineCap = style.lineCap;
        }
        if (style.lineJoin) {
            ctx.lineJoin = style.lineJoin;
        }
    }
    
    specificGeometryChanged(props) {
        return props.size || props.cornerRadius;
    }
    
    serialize() {
        return {
            ...super.serialize(),
            size: { ...this.size },
            cornerRadius: this.cornerRadius
        };
    }
    
    // 调整大小
    resize(newSize, anchor = 'center') {
        const oldSize = { ...this.size };
        this.size = { ...newSize };
        
        // 根据锚点调整位置
        if (anchor !== 'center') {
            const deltaWidth = newSize.width - oldSize.width;
            const deltaHeight = newSize.height - oldSize.height;
            
            switch (anchor) {
                case 'top-left':
                    this.position.x += deltaWidth / 2;
                    this.position.y += deltaHeight / 2;
                    break;
                case 'top-right':
                    this.position.x -= deltaWidth / 2;
                    this.position.y += deltaHeight / 2;
                    break;
                case 'bottom-left':
                    this.position.x += deltaWidth / 2;
                    this.position.y -= deltaHeight / 2;
                    break;
                case 'bottom-right':
                    this.position.x -= deltaWidth / 2;
                    this.position.y -= deltaHeight / 2;
                    break;
            }
        }
        
        this.invalidateCache();
    }
}

// 椭圆元素
class EllipseElement extends BaseElement {
    constructor(props = {}) {
        super({ ...props, type: 'ellipse' });
        
        this.radiusX = props.radiusX || 50;
        this.radiusY = props.radiusY || 40;
    }
    
    static schema = {
        type: 'ellipse',
        properties: {
            radiusX: { type: 'number', min: 0 },
            radiusY: { type: 'number', min: 0 }
        }
    };
    
    getBoundingBox() {
        const { x, y } = this.position;
        
        return {
            x: x - this.radiusX,
            y: y - this.radiusY,
            width: this.radiusX * 2,
            height: this.radiusY * 2,
            left: x - this.radiusX,
            top: y - this.radiusY,
            right: x + this.radiusX,
            bottom: y + this.radiusY
        };
    }
    
    containsPoint(point) {
        // 椭圆点检测：(x-cx)²/a² + (y-cy)²/b² <= 1
        let localPoint = point;
        
        if (this.rotation !== 0) {
            localPoint = this.inverseTransformPoint(point);
            localPoint.x -= this.position.x;
            localPoint.y -= this.position.y;
        } else {
            localPoint = {
                x: point.x - this.position.x,
                y: point.y - this.position.y
            };
        }
        
        const dx = localPoint.x / this.radiusX;
        const dy = localPoint.y / this.radiusY;
        
        return dx * dx + dy * dy <= 1;
    }
    
    render(ctx, viewport) {
        const style = styleManager.computeStyle(this);
        
        ctx.save();
        
        // 应用变换
        const matrix = this.getTransformMatrix();
        ctx.setTransform(matrix);
        
        // 设置样式
        this.applyStyle(ctx, style);
        
        // 绘制椭圆
        ctx.beginPath();
        ctx.ellipse(0, 0, this.radiusX, this.radiusY, 0, 0, 2 * Math.PI);
        
        // 填充和描边
        if (style.fill !== 'transparent') {
            ctx.fill();
        }
        if (style.stroke !== 'transparent' && style.strokeWidth > 0) {
            ctx.stroke();
        }
        
        ctx.restore();
    }
    
    applyStyle(ctx, style) {
        ctx.fillStyle = style.fill;
        ctx.strokeStyle = style.stroke;
        ctx.lineWidth = style.strokeWidth;
        ctx.globalAlpha = style.opacity;
        
        if (style.lineDash) {
            ctx.setLineDash(style.lineDash);
        }
    }
    
    specificGeometryChanged(props) {
        return props.radiusX || props.radiusY;
    }
    
    serialize() {
        return {
            ...super.serialize(),
            radiusX: this.radiusX,
            radiusY: this.radiusY
        };
    }
}

// 直线元素
class LineElement extends BaseElement {
    constructor(props = {}) {
        super({ ...props, type: 'line' });
        
        this.points = props.points || [
            { x: 0, y: 0 },
            { x: 100, y: 0 }
        ];
        
        this.arrowStart = props.arrowStart || false;
        this.arrowEnd = props.arrowEnd || false;
    }
    
    static schema = {
        type: 'line',
        properties: {
            points: { type: 'array', items: { type: 'object' } },
            arrowStart: { type: 'boolean' },
            arrowEnd: { type: 'boolean' }
        }
    };
    
    getBoundingBox() {
        const xs = this.points.map(p => p.x);
        const ys = this.points.map(p => p.y);
        
        const left = Math.min(...xs);
        const right = Math.max(...xs);
        const top = Math.min(...ys);
        const bottom = Math.max(...ys);
        
        return {
            x: left,
            y: top,
            width: right - left,
            height: bottom - top,
            left,
            top,
            right,
            bottom
        };
    }
    
    containsPoint(point) {
        const threshold = this.style.strokeWidth || 2;
        
        for (let i = 0; i < this.points.length - 1; i++) {
            const start = this.points[i];
            const end = this.points[i + 1];
            
            const distance = this.distancePointToLineSegment(point, start, end);
            if (distance <= threshold) {
                return true;
            }
        }
        
        return false;
    }
    
    distancePointToLineSegment(point, lineStart, lineEnd) {
        const A = point.x - lineStart.x;
        const B = point.y - lineStart.y;
        const C = lineEnd.x - lineStart.x;
        const D = lineEnd.y - lineStart.y;
        
        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        
        if (lenSq === 0) {
            // 线段长度为0，返回到起点的距离
            return Math.sqrt(A * A + B * B);
        }
        
        let param = dot / lenSq;
        
        // 限制在线段范围内
        param = Math.max(0, Math.min(1, param));
        
        const xx = lineStart.x + param * C;
        const yy = lineStart.y + param * D;
        
        const dx = point.x - xx;
        const dy = point.y - yy;
        
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    render(ctx, viewport) {
        const style = styleManager.computeStyle(this);
        
        ctx.save();
        
        // 设置样式
        this.applyStyle(ctx, style);
        
        // 绘制线条
        ctx.beginPath();
        
        if (this.points.length > 0) {
            ctx.moveTo(this.points[0].x, this.points[0].y);
            
            for (let i = 1; i < this.points.length; i++) {
                ctx.lineTo(this.points[i].x, this.points[i].y);
            }
        }
        
        ctx.stroke();
        
        // 绘制箭头
        if (this.arrowStart && this.points.length >= 2) {
            this.drawArrow(ctx, this.points[1], this.points[0], style);
        }
        
        if (this.arrowEnd && this.points.length >= 2) {
            const len = this.points.length;
            this.drawArrow(ctx, this.points[len - 2], this.points[len - 1], style);
        }
        
        ctx.restore();
    }
    
    drawArrow(ctx, from, to, style) {
        const arrowLength = style.strokeWidth * 3;
        const arrowAngle = Math.PI / 6; // 30度
        
        const angle = Math.atan2(to.y - from.y, to.x - from.x);
        
        ctx.beginPath();
        ctx.moveTo(to.x, to.y);
        ctx.lineTo(
            to.x - arrowLength * Math.cos(angle - arrowAngle),
            to.y - arrowLength * Math.sin(angle - arrowAngle)
        );
        ctx.moveTo(to.x, to.y);
        ctx.lineTo(
            to.x - arrowLength * Math.cos(angle + arrowAngle),
            to.y - arrowLength * Math.sin(angle + arrowAngle)
        );
        ctx.stroke();
    }
    
    applyStyle(ctx, style) {
        ctx.strokeStyle = style.stroke;
        ctx.lineWidth = style.strokeWidth;
        ctx.globalAlpha = style.opacity;
        ctx.lineCap = style.lineCap || 'round';
        ctx.lineJoin = style.lineJoin || 'round';
        
        if (style.lineDash) {
            ctx.setLineDash(style.lineDash);
        }
    }
    
    specificGeometryChanged(props) {
        return props.points || props.arrowStart || props.arrowEnd;
    }
    
    serialize() {
        return {
            ...super.serialize(),
            points: this.points.map(p => ({ ...p })),
            arrowStart: this.arrowStart,
            arrowEnd: this.arrowEnd
        };
    }
    
    // 添加点
    addPoint(point, index = null) {
        if (index === null) {
            this.points.push({ ...point });
        } else {
            this.points.splice(index, 0, { ...point });
        }
        this.invalidateCache();
    }
    
    // 移除点
    removePoint(index) {
        if (this.points.length > 2 && index >= 0 && index < this.points.length) {
            this.points.splice(index, 1);
            this.invalidateCache();
        }
    }
    
    // 更新点
    updatePoint(index, point) {
        if (index >= 0 && index < this.points.length) {
            this.points[index] = { ...point };
            this.invalidateCache();
        }
    }
}

// 自由绘制元素
class FreeDrawElement extends BaseElement {
    constructor(props = {}) {
        super({ ...props, type: 'freedraw' });
        
        this.points = props.points || [];
        this.pressures = props.pressures || []; // 压感数据
        this.smoothed = props.smoothed || false;
    }
    
    static schema = {
        type: 'freedraw',
        properties: {
            points: { type: 'array', items: { type: 'object' } },
            pressures: { type: 'array', items: { type: 'number' } },
            smoothed: { type: 'boolean' }
        }
    };
    
    getBoundingBox() {
        if (this.points.length === 0) {
            return { x: 0, y: 0, width: 0, height: 0, left: 0, top: 0, right: 0, bottom: 0 };
        }
        
        const xs = this.points.map(p => p.x);
        const ys = this.points.map(p => p.y);
        
        const left = Math.min(...xs);
        const right = Math.max(...xs);
        const top = Math.min(...ys);
        const bottom = Math.max(...ys);
        
        const padding = this.style.strokeWidth || 2;
        
        return {
            x: left - padding,
            y: top - padding,
            width: right - left + padding * 2,
            height: bottom - top + padding * 2,
            left: left - padding,
            top: top - padding,
            right: right + padding,
            bottom: bottom + padding
        };
    }
    
    containsPoint(point) {
        const threshold = (this.style.strokeWidth || 2) + 2;
        
        for (let i = 0; i < this.points.length - 1; i++) {
            const distance = this.distancePointToLineSegment(
                point, 
                this.points[i], 
                this.points[i + 1]
            );
            
            if (distance <= threshold) {
                return true;
            }
        }
        
        return false;
    }
    
    distancePointToLineSegment(point, lineStart, lineEnd) {
        // 复用LineElement的方法
        return LineElement.prototype.distancePointToLineSegment.call(
            this, point, lineStart, lineEnd
        );
    }
    
    render(ctx, viewport) {
        if (this.points.length < 2) return;
        
        const style = styleManager.computeStyle(this);
        
        ctx.save();
        
        // 设置样式
        ctx.strokeStyle = style.stroke;
        ctx.lineWidth = style.strokeWidth;
        ctx.globalAlpha = style.opacity;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        if (this.smoothed) {
            this.renderSmoothed(ctx);
        } else {
            this.renderRaw(ctx);
        }
        
        ctx.restore();
    }
    
    renderRaw(ctx) {
        ctx.beginPath();
        ctx.moveTo(this.points[0].x, this.points[0].y);
        
        for (let i = 1; i < this.points.length; i++) {
            ctx.lineTo(this.points[i].x, this.points[i].y);
        }
        
        ctx.stroke();
    }
    
    renderSmoothed(ctx) {
        if (this.points.length < 3) {
            this.renderRaw(ctx);
            return;
        }
        
        ctx.beginPath();
        ctx.moveTo(this.points[0].x, this.points[0].y);
        
        // 使用二次贝塞尔曲线平滑
        for (let i = 1; i < this.points.length - 1; i++) {
            const cp = this.points[i];
            const next = this.points[i + 1];
            const cpx = (cp.x + next.x) / 2;
            const cpy = (cp.y + next.y) / 2;
            
            ctx.quadraticCurveTo(cp.x, cp.y, cpx, cpy);
        }
        
        // 最后一个点
        const lastPoint = this.points[this.points.length - 1];
        ctx.lineTo(lastPoint.x, lastPoint.y);
        
        ctx.stroke();
    }
    
    // 添加点
    addPoint(point, pressure = 1) {
        this.points.push({ ...point });
        this.pressures.push(pressure);
        this.invalidateCache();
    }
    
    // 平滑处理
    smooth() {
        if (this.points.length < 3) return;
        
        this.smoothed = true;
        this.invalidateCache();
    }
    
    // 简化路径（减少点数）
    simplify(tolerance = 2) {
        if (this.points.length < 3) return;
        
        this.points = this.douglasPeucker(this.points, tolerance);
        // 同时调整压感数组
        if (this.pressures.length > this.points.length) {
            this.pressures = this.pressures.slice(0, this.points.length);
        }
        
        this.invalidateCache();
    }
    
    douglasPeucker(points, tolerance) {
        if (points.length <= 2) return points;
        
        // 找到距离起点和终点连线最远的点
        let maxDistance = 0;
        let maxIndex = 0;
        
        const start = points[0];
        const end = points[points.length - 1];
        
        for (let i = 1; i < points.length - 1; i++) {
            const distance = this.pointToLineDistance(points[i], start, end);
            if (distance > maxDistance) {
                maxDistance = distance;
                maxIndex = i;
            }
        }
        
        // 如果最大距离小于容差，返回起点和终点
        if (maxDistance < tolerance) {
            return [start, end];
        }
        
        // 递归处理两段
        const left = this.douglasPeucker(points.slice(0, maxIndex + 1), tolerance);
        const right = this.douglasPeucker(points.slice(maxIndex), tolerance);
        
        // 合并结果，去除重复的中间点
        return left.slice(0, -1).concat(right);
    }
    
    pointToLineDistance(point, lineStart, lineEnd) {
        const A = lineEnd.x - lineStart.x;
        const B = lineEnd.y - lineStart.y;
        const C = point.x - lineStart.x;
        const D = point.y - lineStart.y;
        
        const dot = A * C + B * D;
        const lenSq = A * A + B * B;
        
        if (lenSq === 0) return Math.sqrt(C * C + D * D);
        
        const param = dot / lenSq;
        
        let xx, yy;
        
        if (param < 0) {
            xx = lineStart.x;
            yy = lineStart.y;
        } else if (param > 1) {
            xx = lineEnd.x;
            yy = lineEnd.y;
        } else {
            xx = lineStart.x + param * A;
            yy = lineStart.y + param * B;
        }
        
        const dx = point.x - xx;
        const dy = point.y - yy;
        
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    serialize() {
        return {
            ...super.serialize(),
            points: this.points.map(p => ({ ...p })),
            pressures: [...this.pressures],
            smoothed: this.smoothed
        };
    }
}

// 注册元素类型
elementFactory.registerElementType('rectangle', RectangleElement);
elementFactory.registerElementType('ellipse', EllipseElement);
elementFactory.registerElementType('line', LineElement);
elementFactory.registerElementType('freedraw', FreeDrawElement);
```

### 5.2.2 文本元素

实现支持富文本的文本元素系统。

```javascript
// 文本元素
class TextElement extends BaseElement {
    constructor(props = {}) {
        super({ ...props, type: 'text' });
        
        this.text = props.text || '';
        this.fontSize = props.fontSize || 16;
        this.fontFamily = props.fontFamily || 'Arial, sans-serif';
        this.fontWeight = props.fontWeight || 'normal';
        this.fontStyle = props.fontStyle || 'normal';
        this.textAlign = props.textAlign || 'left';
        this.textBaseline = props.textBaseline || 'top';
        this.lineHeight = props.lineHeight || 1.2;
        this.maxWidth = props.maxWidth || null;
        this.autoSize = props.autoSize ?? true;
        
        // 富文本支持
        this.richText = props.richText || false;
        this.textRuns = props.textRuns || null; // 富文本片段
        
        // 缓存
        this._textMetrics = null;
        this._textMetricsVersion = 0;
    }
    
    static schema = {
        type: 'text',
        properties: {
            text: { type: 'string' },
            fontSize: { type: 'number', min: 1 },
            fontFamily: { type: 'string' },
            fontWeight: { type: 'string' },
            fontStyle: { type: 'string' },
            textAlign: { type: 'string', enum: ['left', 'center', 'right'] },
            lineHeight: { type: 'number', min: 0.5 },
            maxWidth: { type: 'number', nullable: true },
            richText: { type: 'boolean' }
        }
    };
    
    getBoundingBox() {
        const metrics = this.getTextMetrics();
        const { x, y } = this.position;
        
        let left, top;
        
        switch (this.textAlign) {
            case 'center':
                left = x - metrics.width / 2;
                break;
            case 'right':
                left = x - metrics.width;
                break;
            default:
                left = x;
        }
        
        switch (this.textBaseline) {
            case 'middle':
                top = y - metrics.height / 2;
                break;
            case 'bottom':
                top = y - metrics.height;
                break;
            default:
                top = y;
        }
        
        return {
            x: left,
            y: top,
            width: metrics.width,
            height: metrics.height,
            left,
            top,
            right: left + metrics.width,
            bottom: top + metrics.height
        };
    }
    
    containsPoint(point) {
        const bbox = this.getCachedBoundingBox();
        
        return point.x >= bbox.left && point.x <= bbox.right &&
               point.y >= bbox.top && point.y <= bbox.bottom;
    }
    
    getTextMetrics() {
        if (!this._textMetrics || this._textMetricsVersion < this.version) {
            this._textMetrics = this.calculateTextMetrics();
            this._textMetricsVersion = this.version;
        }
        return this._textMetrics;
    }
    
    calculateTextMetrics() {
        // 创建临时canvas进行测量
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        ctx.font = this.getFontString();
        
        const lines = this.getTextLines(ctx);
        const lineHeight = this.fontSize * this.lineHeight;
        
        let maxWidth = 0;
        lines.forEach(line => {
            const lineMetrics = ctx.measureText(line);
            maxWidth = Math.max(maxWidth, lineMetrics.width);
        });
        
        return {
            width: maxWidth,
            height: lines.length * lineHeight,
            lines: lines,
            lineHeight: lineHeight
        };
    }
    
    getTextLines(ctx) {
        if (!this.maxWidth || this.text.length === 0) {
            return this.text.split('\n');
        }
        
        const words = this.text.split(' ');
        const lines = [];
        let currentLine = '';
        
        for (const word of words) {
            const testLine = currentLine ? currentLine + ' ' + word : word;
            const metrics = ctx.measureText(testLine);
            
            if (metrics.width > this.maxWidth && currentLine) {
                lines.push(currentLine);
                currentLine = word;
            } else {
                currentLine = testLine;
            }
        }
        
        if (currentLine) {
            lines.push(currentLine);
        }
        
        return lines;
    }
    
    getFontString() {
        return `${this.fontStyle} ${this.fontWeight} ${this.fontSize}px ${this.fontFamily}`;
    }
    
    render(ctx, viewport) {
        if (!this.text) return;
        
        const style = styleManager.computeStyle(this);
        
        ctx.save();
        
        // 设置字体和样式
        ctx.font = this.getFontString();
        ctx.fillStyle = style.fill || style.stroke || '#000000';
        ctx.globalAlpha = style.opacity;
        ctx.textAlign = this.textAlign;
        ctx.textBaseline = this.textBaseline;
        
        // 获取文本行
        const metrics = this.getTextMetrics();
        const { x, y } = this.position;
        
        // 渲染文本
        if (this.richText && this.textRuns) {
            this.renderRichText(ctx, x, y, metrics);
        } else {
            this.renderPlainText(ctx, x, y, metrics);
        }
        
        ctx.restore();
    }
    
    renderPlainText(ctx, x, y, metrics) {
        metrics.lines.forEach((line, index) => {
            const lineY = y + index * metrics.lineHeight;
            ctx.fillText(line, x, lineY);
        });
    }
    
    renderRichText(ctx, x, y, metrics) {
        let currentY = y;
        
        this.textRuns.forEach(run => {
            ctx.save();
            
            // 应用运行样式
            if (run.fontWeight) ctx.font = ctx.font.replace(/^\w+/, run.fontWeight);
            if (run.fontStyle) ctx.font = run.fontStyle + ' ' + ctx.font;
            if (run.color) ctx.fillStyle = run.color;
            if (run.fontSize) {
                const newFont = ctx.font.replace(/\d+px/, run.fontSize + 'px');
                ctx.font = newFont;
            }
            
            // 渲染文本片段
            const lines = run.text.split('\n');
            lines.forEach((line, index) => {
                if (index > 0) currentY += metrics.lineHeight;
                ctx.fillText(line, x, currentY);
            });
            
            ctx.restore();
        });
    }
    
    // 文本编辑方法
    insertText(text, position = null) {
        if (position === null) {
            this.text += text;
        } else {
            this.text = this.text.slice(0, position) + text + this.text.slice(position);
        }
        this.invalidateCache();
    }
    
    deleteText(start, length = 1) {
        this.text = this.text.slice(0, start) + this.text.slice(start + length);
        this.invalidateCache();
    }
    
    replaceText(start, length, newText) {
        this.text = this.text.slice(0, start) + newText + this.text.slice(start + length);
        this.invalidateCache();
    }
    
    // 富文本方法
    applyFormat(start, length, format) {
        if (!this.richText) {
            this.richText = true;
            this.textRuns = [{ text: this.text }];
        }
        
        // 分割文本运行以应用格式
        this.splitTextRuns(start, length, format);
        this.invalidateCache();
    }
    
    splitTextRuns(start, length, format) {
        const newRuns = [];
        let currentPos = 0;
        
        for (const run of this.textRuns) {
            const runEnd = currentPos + run.text.length;
            
            if (currentPos >= start + length || runEnd <= start) {
                // 运行不在格式范围内
                newRuns.push(run);
            } else {
                // 运行与格式范围重叠
                if (currentPos < start) {
                    // 添加格式前的部分
                    newRuns.push({
                        ...run,
                        text: run.text.slice(0, start - currentPos)
                    });
                }
                
                // 添加格式化的部分
                const formatStart = Math.max(0, start - currentPos);
                const formatEnd = Math.min(run.text.length, start + length - currentPos);
                
                newRuns.push({
                    ...run,
                    ...format,
                    text: run.text.slice(formatStart, formatEnd)
                });
                
                if (formatEnd < run.text.length) {
                    // 添加格式后的部分
                    newRuns.push({
                        ...run,
                        text: run.text.slice(formatEnd)
                    });
                }
            }
            
            currentPos = runEnd;
        }
        
        this.textRuns = newRuns;
    }
    
    // 获取指定位置的字符索引
    getCharacterIndex(point) {
        const bbox = this.getCachedBoundingBox();
        const metrics = this.getTextMetrics();
        
        // 计算行索引
        const relativeY = point.y - bbox.top;
        const lineIndex = Math.floor(relativeY / metrics.lineHeight);
        
        if (lineIndex < 0 || lineIndex >= metrics.lines.length) {
            return lineIndex < 0 ? 0 : this.text.length;
        }
        
        // 在行内查找字符位置
        const line = metrics.lines[lineIndex];
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.font = this.getFontString();
        
        let charIndex = 0;
        let currentWidth = 0;
        
        for (let i = 0; i <= line.length; i++) {
            const partialText = line.slice(0, i);
            const textWidth = ctx.measureText(partialText).width;
            
            if (point.x - bbox.left <= textWidth + (ctx.measureText(line[i] || '').width / 2)) {
                charIndex = i;
                break;
            }
        }
        
        // 计算在整个文本中的索引
        let globalIndex = 0;
        for (let i = 0; i < lineIndex; i++) {
            globalIndex += metrics.lines[i].length + 1; // +1 for newline
        }
        globalIndex += charIndex;
        
        return Math.min(globalIndex, this.text.length);
    }
    
    specificGeometryChanged(props) {
        return props.text || props.fontSize || props.fontFamily || 
               props.fontWeight || props.fontStyle || props.lineHeight ||
               props.maxWidth || props.textRuns;
    }
    
    serialize() {
        const data = {
            ...super.serialize(),
            text: this.text,
            fontSize: this.fontSize,
            fontFamily: this.fontFamily,
            fontWeight: this.fontWeight,
            fontStyle: this.fontStyle,
            textAlign: this.textAlign,
            textBaseline: this.textBaseline,
            lineHeight: this.lineHeight,
            maxWidth: this.maxWidth,
            autoSize: this.autoSize,
            richText: this.richText
        };
        
        if (this.textRuns) {
            data.textRuns = this.textRuns.map(run => ({ ...run }));
        }
        
        return data;
    }
}

// 注册文本元素
elementFactory.registerElementType('text', TextElement);
```

### 5.2.3 图片元素

实现支持各种图片格式的图片元素。

```javascript
// 图片元素
class ImageElement extends BaseElement {
    constructor(props = {}) {
        super({ ...props, type: 'image' });
        
        this.src = props.src || '';
        this.size = props.size || { width: 100, height: 100 };
        this.cropBox = props.cropBox || null; // { x, y, width, height }
        this.filters = props.filters || {}; // 滤镜效果
        
        // 图片加载状态
        this._image = null;
        this._imageLoaded = false;
        this._imageLoading = false;
        this._imageError = false;
        
        this.loadImage();
    }
    
    static schema = {
        type: 'image',
        properties: {
            src: { type: 'string' },
            size: { type: 'object', properties: { width: 'number', height: 'number' } },
            cropBox: { type: 'object', nullable: true },
            filters: { type: 'object' }
        }
    };
    
    async loadImage() {
        if (!this.src || this._imageLoading) return;
        
        this._imageLoading = true;
        this._imageError = false;
        
        try {
            const img = new Image();
            img.crossOrigin = 'anonymous'; // 支持跨域
            
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
                img.src = this.src;
            });
            
            this._image = img;
            this._imageLoaded = true;
            this._imageLoading = false;
            
            // 如果是自动大小，更新元素大小
            if (this.autoSize) {
                this.size = {
                    width: img.naturalWidth,
                    height: img.naturalHeight
                };
                this.invalidateCache();
            }
            
            // 触发重绘
            this.onImageLoaded?.();
            
        } catch (error) {
            this._imageError = true;
            this._imageLoading = false;
            console.error('Failed to load image:', this.src, error);
        }
    }
    
    getBoundingBox() {
        const { x, y } = this.position;
        const { width, height } = this.size;
        
        return {
            x: x - width / 2,
            y: y - height / 2,
            width,
            height,
            left: x - width / 2,
            top: y - height / 2,
            right: x + width / 2,
            bottom: y + height / 2
        };
    }
    
    containsPoint(point) {
        const bbox = this.getCachedBoundingBox();
        
        if (point.x < bbox.left || point.x > bbox.right ||
            point.y < bbox.top || point.y > bbox.bottom) {
            return false;
        }
        
        // 如果有旋转，进行逆变换检查
        if (this.rotation !== 0) {
            const localPoint = this.inverseTransformPoint(point);
            const localBbox = {
                left: -this.size.width / 2,
                top: -this.size.height / 2,
                right: this.size.width / 2,
                bottom: this.size.height / 2
            };
            
            return localPoint.x >= localBbox.left && localPoint.x <= localBbox.right &&
                   localPoint.y >= localBbox.top && localPoint.y <= localBbox.bottom;
        }
        
        return true;
    }
    
    render(ctx, viewport) {
        const style = styleManager.computeStyle(this);
        
        ctx.save();
        
        // 应用变换
        const matrix = this.getTransformMatrix();
        ctx.setTransform(matrix);
        
        // 设置透明度
        ctx.globalAlpha = style.opacity;
        
        if (this._imageLoaded && this._image) {
            this.renderImage(ctx);
        } else if (this._imageLoading) {
            this.renderPlaceholder(ctx, 'Loading...');
        } else if (this._imageError) {
            this.renderPlaceholder(ctx, 'Error');
        } else {
            this.renderPlaceholder(ctx, 'No Image');
        }
        
        ctx.restore();
    }
    
    renderImage(ctx) {
        const { width, height } = this.size;
        const x = -width / 2;
        const y = -height / 2;
        
        // 应用滤镜
        if (Object.keys(this.filters).length > 0) {
            ctx.filter = this.buildFilterString();
        }
        
        if (this.cropBox) {
            // 裁剪绘制
            ctx.drawImage(
                this._image,
                this.cropBox.x, this.cropBox.y, this.cropBox.width, this.cropBox.height,
                x, y, width, height
            );
        } else {
            // 正常绘制
            ctx.drawImage(this._image, x, y, width, height);
        }
        
        // 重置滤镜
        ctx.filter = 'none';
    }
    
    renderPlaceholder(ctx, text) {
        const { width, height } = this.size;
        const x = -width / 2;
        const y = -height / 2;
        
        // 绘制边框
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, width, height);
        
        // 绘制对角线
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + width, y + height);
        ctx.moveTo(x + width, y);
        ctx.lineTo(x, y + height);
        ctx.stroke();
        
        // 绘制文本
        ctx.fillStyle = '#666';
        ctx.font = '14px Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, 0, 0);
    }
    
    buildFilterString() {
        const filters = [];
        
        if (this.filters.brightness !== undefined) {
            filters.push(`brightness(${this.filters.brightness})`);
        }
        if (this.filters.contrast !== undefined) {
            filters.push(`contrast(${this.filters.contrast})`);
        }
        if (this.filters.saturation !== undefined) {
            filters.push(`saturate(${this.filters.saturation})`);
        }
        if (this.filters.hue !== undefined) {
            filters.push(`hue-rotate(${this.filters.hue}deg)`);
        }
        if (this.filters.blur !== undefined) {
            filters.push(`blur(${this.filters.blur}px)`);
        }
        if (this.filters.sepia !== undefined) {
            filters.push(`sepia(${this.filters.sepia})`);
        }
        if (this.filters.grayscale !== undefined) {
            filters.push(`grayscale(${this.filters.grayscale})`);
        }
        
        return filters.join(' ');
    }
    
    // 设置图片源
    setSrc(src) {
        if (this.src !== src) {
            this.src = src;
            this._imageLoaded = false;
            this._image = null;
            this.loadImage();
            this.invalidateCache();
        }
    }
    
    // 设置裁剪框
    setCropBox(cropBox) {
        this.cropBox = cropBox ? { ...cropBox } : null;
        this.invalidateCache();
    }
    
    // 应用滤镜
    applyFilter(filterName, value) {
        this.filters[filterName] = value;
        this.invalidateCache();
    }
    
    // 移除滤镜
    removeFilter(filterName) {
        delete this.filters[filterName];
        this.invalidateCache();
    }
    
    // 重置滤镜
    resetFilters() {
        this.filters = {};
        this.invalidateCache();
    }
    
    // 获取原始图片尺寸
    getNaturalSize() {
        if (this._imageLoaded && this._image) {
            return {
                width: this._image.naturalWidth,
                height: this._image.naturalHeight
            };
        }
        return null;
    }
    
    // 适应容器大小
    fitToSize(containerSize, mode = 'contain') {
        const naturalSize = this.getNaturalSize();
        if (!naturalSize) return;
        
        let newSize;
        
        switch (mode) {
            case 'contain':
                const scaleContain = Math.min(
                    containerSize.width / naturalSize.width,
                    containerSize.height / naturalSize.height
                );
                newSize = {
                    width: naturalSize.width * scaleContain,
                    height: naturalSize.height * scaleContain
                };
                break;
                
            case 'cover':
                const scaleCover = Math.max(
                    containerSize.width / naturalSize.width,
                    containerSize.height / naturalSize.height
                );
                newSize = {
                    width: naturalSize.width * scaleCover,
                    height: naturalSize.height * scaleCover
                };
                break;
                
            case 'fill':
                newSize = { ...containerSize };
                break;
                
            default:
                newSize = { ...naturalSize };
        }
        
        this.size = newSize;
        this.invalidateCache();
    }
    
    specificGeometryChanged(props) {
        return props.size || props.cropBox || props.src;
    }
    
    serialize() {
        return {
            ...super.serialize(),
            src: this.src,
            size: { ...this.size },
            cropBox: this.cropBox ? { ...this.cropBox } : null,
            filters: { ...this.filters }
        };
    }
}

// 注册图片元素
elementFactory.registerElementType('image', ImageElement);
```

## 5.3 组合元素和分组系统

### 5.3.1 元素分组

实现元素分组功能，支持嵌套分组和批量操作。

```javascript
// 分组元素
class GroupElement extends BaseElement {
    constructor(props = {}) {
        super({ ...props, type: 'group' });
        
        this.children = props.children || [];
        this.expanded = props.expanded ?? true;
        this.clipContent = props.clipContent || false;
        
        // 组合操作模式
        this.groupMode = props.groupMode || 'group'; // 'group' | 'compound' | 'mask'
    }
    
    static schema = {
        type: 'group',
        properties: {
            children: { type: 'array', items: { type: 'string' } }, // 子元素ID数组
            expanded: { type: 'boolean' },
            clipContent: { type: 'boolean' },
            groupMode: { type: 'string', enum: ['group', 'compound', 'mask'] }
        }
    };
    
    getBoundingBox() {
        if (this.children.length === 0) {
            return { x: 0, y: 0, width: 0, height: 0, left: 0, top: 0, right: 0, bottom: 0 };
        }
        
        let left = Infinity, top = Infinity, right = -Infinity, bottom = -Infinity;
        
        this.children.forEach(childId => {
            const child = this.getChildElement(childId);
            if (child) {
                const childBounds = child.getCachedBoundingBox();
                left = Math.min(left, childBounds.left);
                top = Math.min(top, childBounds.top);
                right = Math.max(right, childBounds.right);
                bottom = Math.max(bottom, childBounds.bottom);
            }
        });
        
        if (left === Infinity) {
            return { x: 0, y: 0, width: 0, height: 0, left: 0, top: 0, right: 0, bottom: 0 };
        }
        
        return {
            x: left,
            y: top,
            width: right - left,
            height: bottom - top,
            left,
            top,
            right,
            bottom
        };
    }
    
    containsPoint(point) {
        // 检查子元素是否包含点
        for (const childId of this.children) {
            const child = this.getChildElement(childId);
            if (child && child.containsPoint(point)) {
                return true;
            }
        }
        
        return false;
    }
    
    render(ctx, viewport) {
        if (!this.expanded || this.children.length === 0) return;
        
        const style = styleManager.computeStyle(this);
        
        ctx.save();
        
        // 应用组样式
        ctx.globalAlpha = style.opacity;
        
        // 如果需要裁剪
        if (this.clipContent) {
            const bounds = this.getCachedBoundingBox();
            ctx.beginPath();
            ctx.rect(bounds.left, bounds.top, bounds.width, bounds.height);
            ctx.clip();
        }
        
        // 渲染子元素
        this.children.forEach(childId => {
            const child = this.getChildElement(childId);
            if (child && child.style.visible !== false) {
                child.render(ctx, viewport);
            }
        });
        
        ctx.restore();
        
        // 如果是复合模式，应用特殊效果
        if (this.groupMode === 'compound') {
            this.renderCompoundEffect(ctx, style);
        }
    }
    
    renderCompoundEffect(ctx, style) {
        // 实现复合混合模式
        if (style.blendMode) {
            ctx.globalCompositeOperation = style.blendMode;
        }
    }
    
    // 子元素管理
    addChild(element) {
        if (!this.children.includes(element.id)) {
            this.children.push(element.id);
            element.groupId = this.id;
            this.invalidateCache();
        }
    }
    
    removeChild(elementId) {
        const index = this.children.indexOf(elementId);
        if (index > -1) {
            this.children.splice(index, 1);
            
            const child = this.getChildElement(elementId);
            if (child) {
                child.groupId = null;
            }
            
            this.invalidateCache();
        }
    }
    
    getChildElement(childId) {
        // 这里需要从全局元素管理器获取元素
        return elementManager?.getElementById(childId) || null;
    }
    
    getChildElements() {
        return this.children.map(id => this.getChildElement(id)).filter(Boolean);
    }
    
    // 变换传播
    translate(dx, dy) {
        super.translate(dx, dy);
        
        // 传播变换到子元素
        this.children.forEach(childId => {
            const child = this.getChildElement(childId);
            if (child) {
                child.translate(dx, dy);
            }
        });
    }
    
    rotate(angle, center = null) {
        super.rotate(angle, center);
        
        // 传播旋转到子元素
        const groupCenter = center || this.position;
        this.children.forEach(childId => {
            const child = this.getChildElement(childId);
            if (child) {
                child.rotate(angle, groupCenter);
            }
        });
    }
    
    scaleBy(sx, sy = sx, center = null) {
        super.scaleBy(sx, sy, center);
        
        // 传播缩放到子元素
        const groupCenter = center || this.position;
        this.children.forEach(childId => {
            const child = this.getChildElement(childId);
            if (child) {
                child.scaleBy(sx, sy, groupCenter);
            }
        });
    }
    
    // 展开/折叠
    expand() {
        this.expanded = true;
        this.invalidateCache();
    }
    
    collapse() {
        this.expanded = false;
        this.invalidateCache();
    }
    
    toggle() {
        this.expanded = !this.expanded;
        this.invalidateCache();
    }
    
    // 解组
    ungroup() {
        const childElements = this.getChildElements();
        
        // 清除子元素的组关联
        childElements.forEach(child => {
            child.groupId = null;
        });
        
        this.children = [];
        
        return childElements;
    }
    
    // 深度遍历
    traverseDepthFirst(callback) {
        callback(this);
        
        this.children.forEach(childId => {
            const child = this.getChildElement(childId);
            if (child) {
                if (child instanceof GroupElement) {
                    child.traverseDepthFirst(callback);
                } else {
                    callback(child);
                }
            }
        });
    }
    
    // 查找子元素
    findChild(predicate) {
        for (const childId of this.children) {
            const child = this.getChildElement(childId);
            if (child && predicate(child)) {
                return child;
            }
            
            // 如果是组，递归查找
            if (child instanceof GroupElement) {
                const found = child.findChild(predicate);
                if (found) return found;
            }
        }
        
        return null;
    }
    
    // 获取所有后代元素
    getAllDescendants() {
        const descendants = [];
        
        this.traverseDepthFirst(element => {
            if (element !== this) {
                descendants.push(element);
            }
        });
        
        return descendants;
    }
    
    serialize() {
        return {
            ...super.serialize(),
            children: [...this.children],
            expanded: this.expanded,
            clipContent: this.clipContent,
            groupMode: this.groupMode
        };
    }
}

// 分组管理器
class GroupManager {
    constructor(elementManager) {
        this.elementManager = elementManager;
    }
    
    // 创建分组
    createGroup(elementIds, groupProps = {}) {
        if (elementIds.length === 0) return null;
        
        const elements = elementIds.map(id => this.elementManager.getElementById(id))
                                   .filter(Boolean);
        
        if (elements.length === 0) return null;
        
        // 计算分组中心点
        const bounds = this.calculateGroupBounds(elements);
        const center = {
            x: bounds.left + bounds.width / 2,
            y: bounds.top + bounds.height / 2
        };
        
        // 创建分组元素
        const group = new GroupElement({
            ...groupProps,
            position: center,
            children: elementIds
        });
        
        // 设置子元素的组关联
        elements.forEach(element => {
            element.groupId = group.id;
        });
        
        // 添加到元素管理器
        this.elementManager.addElement(group);
        
        return group;
    }
    
    // 解散分组
    ungroup(groupId) {
        const group = this.elementManager.getElementById(groupId);
        if (!(group instanceof GroupElement)) return [];
        
        const childElements = group.ungroup();
        
        // 从元素管理器移除分组
        this.elementManager.removeElement(groupId);
        
        return childElements;
    }
    
    // 添加元素到分组
    addToGroup(groupId, elementIds) {
        const group = this.elementManager.getElementById(groupId);
        if (!(group instanceof GroupElement)) return false;
        
        elementIds.forEach(elementId => {
            const element = this.elementManager.getElementById(elementId);
            if (element) {
                group.addChild(element);
            }
        });
        
        return true;
    }
    
    // 从分组移除元素
    removeFromGroup(groupId, elementIds) {
        const group = this.elementManager.getElementById(groupId);
        if (!(group instanceof GroupElement)) return false;
        
        elementIds.forEach(elementId => {
            group.removeChild(elementId);
        });
        
        // 如果分组为空，删除分组
        if (group.children.length === 0) {
            this.elementManager.removeElement(groupId);
        }
        
        return true;
    }
    
    // 计算多个元素的边界
    calculateGroupBounds(elements) {
        if (elements.length === 0) {
            return { left: 0, top: 0, right: 0, bottom: 0, width: 0, height: 0 };
        }
        
        let left = Infinity, top = Infinity, right = -Infinity, bottom = -Infinity;
        
        elements.forEach(element => {
            const bounds = element.getCachedBoundingBox();
            left = Math.min(left, bounds.left);
            top = Math.min(top, bounds.top);
            right = Math.max(right, bounds.right);
            bottom = Math.max(bottom, bounds.bottom);
        });
        
        return {
            left,
            top,
            right,
            bottom,
            width: right - left,
            height: bottom - top
        };
    }
    
    // 获取元素的顶级分组
    getTopLevelGroup(elementId) {
        const element = this.elementManager.getElementById(elementId);
        if (!element || !element.groupId) return null;
        
        let currentGroup = this.elementManager.getElementById(element.groupId);
        
        while (currentGroup && currentGroup.groupId) {
            currentGroup = this.elementManager.getElementById(currentGroup.groupId);
        }
        
        return currentGroup;
    }
    
    // 获取分组层次结构
    getGroupHierarchy(elementId) {
        const hierarchy = [];
        const element = this.elementManager.getElementById(elementId);
        
        if (!element) return hierarchy;
        
        let currentGroupId = element.groupId;
        while (currentGroupId) {
            const group = this.elementManager.getElementById(currentGroupId);
            if (group) {
                hierarchy.unshift(group);
                currentGroupId = group.groupId;
            } else {
                break;
            }
        }
        
        return hierarchy;
    }
    
    // 检查元素是否在指定分组中
    isElementInGroup(elementId, groupId) {
        const hierarchy = this.getGroupHierarchy(elementId);
        return hierarchy.some(group => group.id === groupId);
    }
}

// 注册分组元素
elementFactory.registerElementType('group', GroupElement);
```

### 5.3.2 复合路径和布尔运算

实现复合路径系统，支持路径的布尔运算。

```javascript
// 复合路径元素
class CompoundPathElement extends BaseElement {
    constructor(props = {}) {
        super({ ...props, type: 'compound-path' });
        
        this.paths = props.paths || []; // 路径数组
        this.operations = props.operations || []; // 布尔运算数组
        this.fillRule = props.fillRule || 'nonzero'; // 'nonzero' | 'evenodd'
        
        // 缓存计算结果
        this._computedPath = null;
        this._computedPathVersion = 0;
    }
    
    static schema = {
        type: 'compound-path',
        properties: {
            paths: { type: 'array' },
            operations: { type: 'array' },
            fillRule: { type: 'string', enum: ['nonzero', 'evenodd'] }
        }
    };
    
    getBoundingBox() {
        const computedPath = this.getComputedPath();
        return this.calculatePathBounds(computedPath);
    }
    
    containsPoint(point) {
        const computedPath = this.getComputedPath();
        return this.isPointInPath(point, computedPath);
    }
    
    getComputedPath() {
        if (!this._computedPath || this._computedPathVersion < this.version) {
            this._computedPath = this.computePath();
            this._computedPathVersion = this.version;
        }
        return this._computedPath;
    }
    
    computePath() {
        if (this.paths.length === 0) return [];
        
        if (this.paths.length === 1) {
            return this.paths[0];
        }
        
        // 执行布尔运算
        let result = this.paths[0];
        
        for (let i = 1; i < this.paths.length; i++) {
            const operation = this.operations[i - 1] || 'union';
            result = this.performBooleanOperation(result, this.paths[i], operation);
        }
        
        return result;
    }
    
    performBooleanOperation(pathA, pathB, operation) {
        // 简化的布尔运算实现
        // 实际项目中应该使用专门的几何库如 martinez-polygon-clipping
        
        switch (operation) {
            case 'union':
                return this.unionPaths(pathA, pathB);
            case 'difference':
                return this.differencePaths(pathA, pathB);
            case 'intersection':
                return this.intersectionPaths(pathA, pathB);
            case 'xor':
                return this.xorPaths(pathA, pathB);
            default:
                return pathA;
        }
    }
    
    unionPaths(pathA, pathB) {
        // 简化实现：合并两个路径
        return [...pathA, ...pathB];
    }
    
    differencePaths(pathA, pathB) {
        // 简化实现：返回第一个路径
        return pathA;
    }
    
    intersectionPaths(pathA, pathB) {
        // 简化实现：返回重叠部分（需要复杂的几何计算）
        return pathA;
    }
    
    xorPaths(pathA, pathB) {
        // 简化实现：排他或运算
        return [...pathA, ...pathB];
    }
    
    calculatePathBounds(path) {
        if (path.length === 0) {
            return { x: 0, y: 0, width: 0, height: 0, left: 0, top: 0, right: 0, bottom: 0 };
        }
        
        let left = Infinity, top = Infinity, right = -Infinity, bottom = -Infinity;
        
        path.forEach(point => {
            left = Math.min(left, point.x);
            top = Math.min(top, point.y);
            right = Math.max(right, point.x);
            bottom = Math.max(bottom, point.y);
        });
        
        return {
            x: left,
            y: top,
            width: right - left,
            height: bottom - top,
            left,
            top,
            right,
            bottom
        };
    }
    
    isPointInPath(point, path) {
        // 射线法判断点是否在路径内
        let inside = false;
        
        for (let i = 0, j = path.length - 1; i < path.length; j = i++) {
            const xi = path[i].x;
            const yi = path[i].y;
            const xj = path[j].x;
            const yj = path[j].y;
            
            if (((yi > point.y) !== (yj > point.y)) &&
                (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi)) {
                inside = !inside;
            }
        }
        
        return inside;
    }
    
    render(ctx, viewport) {
        const style = styleManager.computeStyle(this);
        const computedPath = this.getComputedPath();
        
        if (computedPath.length === 0) return;
        
        ctx.save();
        
        // 应用变换
        const matrix = this.getTransformMatrix();
        ctx.setTransform(matrix);
        
        // 设置样式
        ctx.fillStyle = style.fill;
        ctx.strokeStyle = style.stroke;
        ctx.lineWidth = style.strokeWidth;
        ctx.globalAlpha = style.opacity;
        
        // 绘制路径
        this.drawPath(ctx, computedPath);
        
        // 填充和描边
        if (style.fill !== 'transparent') {
            ctx.fill(this.fillRule);
        }
        if (style.stroke !== 'transparent' && style.strokeWidth > 0) {
            ctx.stroke();
        }
        
        ctx.restore();
    }
    
    drawPath(ctx, path) {
        if (path.length === 0) return;
        
        ctx.beginPath();
        
        // 假设路径是点数组，实际可能需要处理曲线命令
        ctx.moveTo(path[0].x, path[0].y);
        
        for (let i = 1; i < path.length; i++) {
            ctx.lineTo(path[i].x, path[i].y);
        }
        
        ctx.closePath();
    }
    
    // 路径操作方法
    addPath(path, operation = 'union') {
        this.paths.push(path);
        if (this.paths.length > 1) {
            this.operations.push(operation);
        }
        this.invalidateCache();
    }
    
    removePath(index) {
        if (index >= 0 && index < this.paths.length) {
            this.paths.splice(index, 1);
            
            // 调整操作数组
            if (index < this.operations.length) {
                this.operations.splice(index, 1);
            } else if (index > 0 && this.operations.length >= index) {
                this.operations.splice(index - 1, 1);
            }
            
            this.invalidateCache();
        }
    }
    
    setOperation(index, operation) {
        if (index >= 0 && index < this.operations.length) {
            this.operations[index] = operation;
            this.invalidateCache();
        }
    }
    
    serialize() {
        return {
            ...super.serialize(),
            paths: this.paths.map(path => [...path]),
            operations: [...this.operations],
            fillRule: this.fillRule
        };
    }
}

// 注册复合路径元素
elementFactory.registerElementType('compound-path', CompoundPathElement);
```

## 总结

本章详细介绍了元素系统与图形抽象的构建，包括：

1. **元素抽象基础** - 设计了灵活的基础元素类和样式管理系统
2. **具体元素实现** - 实现了矩形、椭圆、直线、自由绘制、文本、图片等元素
3. **组合元素系统** - 构建了分组管理和复合路径系统
4. **高级功能** - 支持变换、缓存、序列化、布尔运算等

这套元素系统为构建复杂的绘图应用提供了完整的图形抽象层，具有良好的扩展性和性能表现。在下一章中，我们将学习如何构建高效的渲染引擎来显示这些元素。