# 第7章：工具系统与绘图工具

## 学习目标
通过本章学习，你将掌握：
- 工具系统架构设计
- 基础绘图工具实现
- 选择和变换工具
- 路径编辑工具
- 文本编辑工具
- 自定义工具开发
- 工具状态管理
- 工具快捷键和手势
- 工具提示和反馈系统

## 7.1 工具系统架构

### 7.1.1 工具管理器设计

构建一个灵活可扩展的工具管理系统。

```javascript
// 工具管理器
class ToolManager {
    constructor(app) {
        this.app = app;
        this.tools = new Map();
        this.currentTool = null;
        this.previousTool = null;
        this.defaultTool = 'select';
        
        // 工具状态
        this.toolState = {
            isActive: false,
            isDragging: false,
            startPoint: null,
            currentPoint: null,
            modifiers: {
                shift: false,
                ctrl: false,
                alt: false,
                meta: false
            }
        };
        
        // 工具配置
        this.config = {
            snapToGrid: true,
            gridSize: 20,
            snapToObjects: true,
            snapDistance: 10,
            magneticGuides: true,
            showTooltips: true
        };
        
        // 临时绘制层
        this.overlayCanvas = null;
        this.overlayContext = null;
        
        // 工具事件监听器
        this.listeners = new Map();
        
        this.initialize();
    }
    
    initialize() {
        // 创建临时绘制层
        this.createOverlayCanvas();
        
        // 注册内置工具
        this.registerBuiltinTools();
        
        // 设置默认工具
        this.selectTool(this.defaultTool);
        
        // 设置事件监听
        this.setupEventListeners();
    }
    
    createOverlayCanvas() {
        this.overlayCanvas = document.createElement('canvas');
        this.overlayCanvas.style.position = 'absolute';
        this.overlayCanvas.style.pointerEvents = 'none';
        this.overlayCanvas.style.zIndex = '1000';
        
        // 匹配主画布大小
        const mainCanvas = this.app.canvas;
        this.overlayCanvas.width = mainCanvas.width;
        this.overlayCanvas.height = mainCanvas.height;
        this.overlayCanvas.style.width = mainCanvas.style.width;
        this.overlayCanvas.style.height = mainCanvas.style.height;
        
        this.overlayContext = this.overlayCanvas.getContext('2d');
        
        // 添加到DOM
        mainCanvas.parentElement.appendChild(this.overlayCanvas);
    }
    
    registerBuiltinTools() {
        // 注册选择工具
        this.registerTool('select', new SelectTool(this));
        
        // 注册绘图工具
        this.registerTool('rectangle', new RectangleTool(this));
        this.registerTool('ellipse', new EllipseTool(this));
        this.registerTool('line', new LineTool(this));
        this.registerTool('arrow', new ArrowTool(this));
        this.registerTool('freedraw', new FreeDrawTool(this));
        this.registerTool('polygon', new PolygonTool(this));
        
        // 注册文本工具
        this.registerTool('text', new TextTool(this));
        
        // 注册编辑工具
        this.registerTool('eraser', new EraserTool(this));
        this.registerTool('hand', new HandTool(this));
        this.registerTool('zoom', new ZoomTool(this));
    }
    
    // 注册工具
    registerTool(name, tool) {
        this.tools.set(name, tool);
        tool.name = name;
        tool.manager = this;
    }
    
    // 选择工具
    selectTool(name) {
        const tool = this.tools.get(name);
        if (!tool) {
            console.warn(`Tool '${name}' not found`);
            return;
        }
        
        // 停用当前工具
        if (this.currentTool) {
            this.currentTool.deactivate();
            this.previousTool = this.currentTool;
        }
        
        // 激活新工具
        this.currentTool = tool;
        this.currentTool.activate();
        
        // 更新光标
        this.updateCursor();
        
        // 触发工具变更事件
        this.emitEvent('toolChange', {
            previous: this.previousTool?.name,
            current: tool.name
        });
    }
    
    // 获取当前工具
    getCurrentTool() {
        return this.currentTool;
    }
    
    // 临时切换工具
    temporaryTool(name) {
        this.tempToolName = this.currentTool?.name;
        this.selectTool(name);
    }
    
    // 恢复之前的工具
    restoreTool() {
        if (this.tempToolName) {
            this.selectTool(this.tempToolName);
            this.tempToolName = null;
        }
    }
    
    // 设置事件监听
    setupEventListeners() {
        const canvas = this.app.canvas;
        
        // 鼠标事件
        canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
        canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
        canvas.addEventListener('wheel', this.handleWheel.bind(this));
        
        // 触摸事件
        canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));
        canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));
        canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
        
        // 键盘事件
        document.addEventListener('keydown', this.handleKeyDown.bind(this));
        document.addEventListener('keyup', this.handleKeyUp.bind(this));
        
        // 上下文菜单
        canvas.addEventListener('contextmenu', this.handleContextMenu.bind(this));
    }
    
    // 事件处理
    handleMouseDown(event) {
        const point = this.getEventPoint(event);
        this.toolState.isActive = true;
        this.toolState.isDragging = false;
        this.toolState.startPoint = point;
        this.toolState.currentPoint = point;
        
        // 更新修饰键
        this.updateModifiers(event);
        
        // 调用工具处理
        if (this.currentTool) {
            this.currentTool.onMouseDown(point, event);
        }
    }
    
    handleMouseMove(event) {
        const point = this.getEventPoint(event);
        this.toolState.currentPoint = point;
        
        // 检查是否开始拖拽
        if (this.toolState.isActive && !this.toolState.isDragging) {
            const distance = this.getDistance(this.toolState.startPoint, point);
            if (distance > 5) {
                this.toolState.isDragging = true;
                
                if (this.currentTool) {
                    this.currentTool.onDragStart(this.toolState.startPoint, event);
                }
            }
        }
        
        // 更新修饰键
        this.updateModifiers(event);
        
        // 调用工具处理
        if (this.currentTool) {
            if (this.toolState.isDragging) {
                this.currentTool.onDragMove(point, event);
            } else {
                this.currentTool.onMouseMove(point, event);
            }
        }
    }
    
    handleMouseUp(event) {
        const point = this.getEventPoint(event);
        
        // 更新修饰键
        this.updateModifiers(event);
        
        // 调用工具处理
        if (this.currentTool) {
            if (this.toolState.isDragging) {
                this.currentTool.onDragEnd(point, event);
            } else {
                this.currentTool.onMouseUp(point, event);
            }
        }
        
        // 重置状态
        this.toolState.isActive = false;
        this.toolState.isDragging = false;
        this.toolState.startPoint = null;
    }
    
    handleWheel(event) {
        event.preventDefault();
        
        if (this.currentTool) {
            this.currentTool.onWheel(event);
        }
    }
    
    handleTouchStart(event) {
        event.preventDefault();
        const touch = event.touches[0];
        const point = this.getTouchPoint(touch);
        
        // 模拟鼠标事件
        this.handleMouseDown({
            clientX: touch.clientX,
            clientY: touch.clientY,
            ...event
        });
    }
    
    handleTouchMove(event) {
        event.preventDefault();
        const touch = event.touches[0];
        
        // 模拟鼠标事件
        this.handleMouseMove({
            clientX: touch.clientX,
            clientY: touch.clientY,
            ...event
        });
    }
    
    handleTouchEnd(event) {
        event.preventDefault();
        
        // 模拟鼠标事件
        this.handleMouseUp(event);
    }
    
    handleKeyDown(event) {
        // 更新修饰键
        this.updateModifiers(event);
        
        // 工具快捷键
        if (!event.repeat) {
            const tool = this.getToolByShortcut(event.key);
            if (tool) {
                event.preventDefault();
                this.selectTool(tool);
                return;
            }
        }
        
        // 调用工具处理
        if (this.currentTool) {
            this.currentTool.onKeyDown(event);
        }
    }
    
    handleKeyUp(event) {
        // 更新修饰键
        this.updateModifiers(event);
        
        // 调用工具处理
        if (this.currentTool) {
            this.currentTool.onKeyUp(event);
        }
    }
    
    handleContextMenu(event) {
        event.preventDefault();
        
        if (this.currentTool) {
            this.currentTool.onContextMenu(event);
        }
    }
    
    // 获取事件点
    getEventPoint(event) {
        const rect = this.app.canvas.getBoundingClientRect();
        const point = {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top
        };
        
        // 应用捕捉
        if (this.config.snapToGrid) {
            point.x = Math.round(point.x / this.config.gridSize) * this.config.gridSize;
            point.y = Math.round(point.y / this.config.gridSize) * this.config.gridSize;
        }
        
        // 转换到世界坐标
        return this.app.viewport.screenToWorld(point);
    }
    
    getTouchPoint(touch) {
        const rect = this.app.canvas.getBoundingClientRect();
        return {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top
        };
    }
    
    // 更新修饰键
    updateModifiers(event) {
        this.toolState.modifiers = {
            shift: event.shiftKey,
            ctrl: event.ctrlKey || event.metaKey,
            alt: event.altKey,
            meta: event.metaKey
        };
    }
    
    // 获取距离
    getDistance(p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    // 获取工具快捷键
    getToolByShortcut(key) {
        const shortcuts = {
            'v': 'select',
            'r': 'rectangle',
            'o': 'ellipse',
            'l': 'line',
            'a': 'arrow',
            'p': 'freedraw',
            't': 'text',
            'e': 'eraser',
            'h': 'hand',
            'z': 'zoom'
        };
        
        return shortcuts[key.toLowerCase()];
    }
    
    // 更新光标
    updateCursor() {
        if (this.currentTool) {
            this.app.canvas.style.cursor = this.currentTool.getCursor();
        }
    }
    
    // 清除临时绘制
    clearOverlay() {
        this.overlayContext.clearRect(
            0, 0,
            this.overlayCanvas.width,
            this.overlayCanvas.height
        );
    }
    
    // 事件管理
    addEventListener(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        this.listeners.get(event).push(callback);
    }
    
    removeEventListener(event, callback) {
        const callbacks = this.listeners.get(event);
        if (callbacks) {
            const index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        }
    }
    
    emitEvent(event, data) {
        const callbacks = this.listeners.get(event);
        if (callbacks) {
            callbacks.forEach(callback => callback(data));
        }
    }
    
    // 配置管理
    setConfig(config) {
        Object.assign(this.config, config);
    }
    
    getConfig() {
        return { ...this.config };
    }
}

// 基础工具类
class BaseTool {
    constructor(manager) {
        this.manager = manager;
        this.name = '';
        this.cursor = 'default';
        this.isActive = false;
        
        // 工具选项
        this.options = {
            strokeColor: '#000000',
            fillColor: 'transparent',
            strokeWidth: 2,
            opacity: 1,
            lineDash: [],
            fontSize: 16,
            fontFamily: 'Arial'
        };
        
        // 临时数据
        this.tempData = null;
    }
    
    // 生命周期方法
    activate() {
        this.isActive = true;
        this.onActivate();
    }
    
    deactivate() {
        this.isActive = false;
        this.cleanup();
        this.onDeactivate();
    }
    
    onActivate() {
        // 子类实现
    }
    
    onDeactivate() {
        // 子类实现
    }
    
    cleanup() {
        this.manager.clearOverlay();
        this.tempData = null;
    }
    
    // 事件处理方法（子类重写）
    onMouseDown(point, event) {}
    onMouseMove(point, event) {}
    onMouseUp(point, event) {}
    onDragStart(point, event) {}
    onDragMove(point, event) {}
    onDragEnd(point, event) {}
    onKeyDown(event) {}
    onKeyUp(event) {}
    onWheel(event) {}
    onContextMenu(event) {}
    
    // 获取光标
    getCursor() {
        return this.cursor;
    }
    
    // 设置选项
    setOptions(options) {
        Object.assign(this.options, options);
    }
    
    // 获取选项
    getOptions() {
        return { ...this.options };
    }
    
    // 辅助方法
    getApp() {
        return this.manager.app;
    }
    
    getCanvas() {
        return this.manager.app.canvas;
    }
    
    getContext() {
        return this.manager.app.context;
    }
    
    getOverlayContext() {
        return this.manager.overlayContext;
    }
    
    // 创建元素
    createElement(type, props) {
        return this.getApp().elementManager.createElement(type, {
            ...props,
            style: {
                stroke: this.options.strokeColor,
                fill: this.options.fillColor,
                strokeWidth: this.options.strokeWidth,
                opacity: this.options.opacity,
                lineDash: this.options.lineDash,
                ...props.style
            }
        });
    }
    
    // 添加元素
    addElement(element) {
        this.getApp().elementManager.addElement(element);
        this.getApp().renderEngine.markDirty();
    }
    
    // 绘制预览
    drawPreview(ctx, data) {
        // 子类实现
    }
    
    // 捕捉到网格
    snapToGrid(point) {
        const gridSize = this.manager.config.gridSize;
        return {
            x: Math.round(point.x / gridSize) * gridSize,
            y: Math.round(point.y / gridSize) * gridSize
        };
    }
    
    // 捕捉到对象
    snapToObject(point) {
        if (!this.manager.config.snapToObjects) return point;
        
        const snapDistance = this.manager.config.snapDistance;
        const elements = this.getApp().elementManager.getAllElements();
        
        let snappedPoint = { ...point };
        let minDistance = snapDistance;
        
        elements.forEach(element => {
            const bounds = element.getBoundingBox();
            const snapPoints = [
                { x: bounds.left, y: bounds.top },
                { x: bounds.right, y: bounds.top },
                { x: bounds.left, y: bounds.bottom },
                { x: bounds.right, y: bounds.bottom },
                { x: bounds.left + bounds.width / 2, y: bounds.top + bounds.height / 2 }
            ];
            
            snapPoints.forEach(snapPoint => {
                const distance = this.getDistance(point, snapPoint);
                if (distance < minDistance) {
                    minDistance = distance;
                    snappedPoint = snapPoint;
                }
            });
        });
        
        return snappedPoint;
    }
    
    getDistance(p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
}
```

### 7.1.2 工具选项和配置

实现工具选项面板和配置系统。

```javascript
// 工具选项管理器
class ToolOptionsManager {
    constructor(toolManager) {
        this.toolManager = toolManager;
        this.optionsPanels = new Map();
        this.currentPanel = null;
        
        // 全局选项
        this.globalOptions = {
            strokeColor: '#000000',
            fillColor: 'transparent',
            strokeWidth: 2,
            opacity: 1,
            lineDash: [],
            fontSize: 16,
            fontFamily: 'Arial, sans-serif',
            textAlign: 'left',
            roundness: 0,
            roughness: 1,
            strokeStyle: 'solid' // 'solid', 'dashed', 'dotted'
        };
        
        // 预设样式
        this.stylePresets = [
            {
                name: 'Default',
                options: {
                    strokeColor: '#000000',
                    fillColor: 'transparent',
                    strokeWidth: 2
                }
            },
            {
                name: 'Bold',
                options: {
                    strokeColor: '#000000',
                    fillColor: 'transparent',
                    strokeWidth: 4
                }
            },
            {
                name: 'Filled',
                options: {
                    strokeColor: '#000000',
                    fillColor: '#ffd43b',
                    strokeWidth: 2
                }
            },
            {
                name: 'Sketch',
                options: {
                    strokeColor: '#495057',
                    fillColor: 'transparent',
                    strokeWidth: 1,
                    roughness: 2
                }
            }
        ];
        
        // 最近使用的颜色
        this.recentColors = [];
        this.maxRecentColors = 10;
        
        this.initialize();
    }
    
    initialize() {
        this.createOptionsUI();
        this.setupEventListeners();
    }
    
    createOptionsUI() {
        // 创建选项面板容器
        const container = document.createElement('div');
        container.className = 'tool-options-container';
        container.style.cssText = `
            position: fixed;
            top: 60px;
            left: 10px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1000;
        `;
        
        // 颜色选择器
        this.createColorPickers(container);
        
        // 线宽选择器
        this.createStrokeWidthSelector(container);
        
        // 透明度滑块
        this.createOpacitySlider(container);
        
        // 线型选择器
        this.createLineStyleSelector(container);
        
        // 预设样式
        this.createStylePresets(container);
        
        document.body.appendChild(container);
        this.container = container;
    }
    
    createColorPickers(container) {
        const colorSection = document.createElement('div');
        colorSection.className = 'color-section';
        
        // 描边颜色
        const strokeColorPicker = this.createColorPicker('Stroke', this.globalOptions.strokeColor);
        strokeColorPicker.addEventListener('change', (e) => {
            this.updateOption('strokeColor', e.target.value);
            this.addRecentColor(e.target.value);
        });
        
        // 填充颜色
        const fillColorPicker = this.createColorPicker('Fill', this.globalOptions.fillColor);
        fillColorPicker.addEventListener('change', (e) => {
            this.updateOption('fillColor', e.target.value);
            this.addRecentColor(e.target.value);
        });
        
        colorSection.appendChild(strokeColorPicker);
        colorSection.appendChild(fillColorPicker);
        
        // 最近颜色
        const recentColorsDiv = this.createRecentColors();
        colorSection.appendChild(recentColorsDiv);
        
        container.appendChild(colorSection);
    }
    
    createColorPicker(label, defaultColor) {
        const wrapper = document.createElement('div');
        wrapper.style.cssText = 'margin-bottom: 10px;';
        
        const labelElement = document.createElement('label');
        labelElement.textContent = label + ': ';
        labelElement.style.cssText = 'display: inline-block; width: 50px;';
        
        const input = document.createElement('input');
        input.type = 'color';
        input.value = defaultColor;
        input.style.cssText = 'width: 50px; height: 30px; border: none; cursor: pointer;';
        
        wrapper.appendChild(labelElement);
        wrapper.appendChild(input);
        
        return wrapper;
    }
    
    createRecentColors() {
        const wrapper = document.createElement('div');
        wrapper.className = 'recent-colors';
        wrapper.style.cssText = 'margin-top: 10px;';
        
        const label = document.createElement('div');
        label.textContent = 'Recent:';
        label.style.cssText = 'font-size: 12px; margin-bottom: 5px;';
        
        const colorsContainer = document.createElement('div');
        colorsContainer.style.cssText = 'display: flex; gap: 5px; flex-wrap: wrap;';
        
        wrapper.appendChild(label);
        wrapper.appendChild(colorsContainer);
        
        this.recentColorsContainer = colorsContainer;
        
        return wrapper;
    }
    
    createStrokeWidthSelector(container) {
        const wrapper = document.createElement('div');
        wrapper.style.cssText = 'margin-bottom: 10px;';
        
        const label = document.createElement('label');
        label.textContent = 'Stroke Width: ';
        label.style.cssText = 'display: block; margin-bottom: 5px;';
        
        const widthOptions = [1, 2, 3, 4, 6, 8];
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = 'display: flex; gap: 5px;';
        
        widthOptions.forEach(width => {
            const button = document.createElement('button');
            button.style.cssText = `
                width: 30px;
                height: 30px;
                border: 1px solid #ddd;
                background: white;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            // 绘制线条预览
            const line = document.createElement('div');
            line.style.cssText = `
                width: 20px;
                height: ${width}px;
                background: black;
                border-radius: ${width/2}px;
            `;
            
            button.appendChild(line);
            button.addEventListener('click', () => {
                this.updateOption('strokeWidth', width);
                this.highlightSelectedButton(buttonsContainer, button);
            });
            
            buttonsContainer.appendChild(button);
        });
        
        wrapper.appendChild(label);
        wrapper.appendChild(buttonsContainer);
        container.appendChild(wrapper);
    }
    
    createOpacitySlider(container) {
        const wrapper = document.createElement('div');
        wrapper.style.cssText = 'margin-bottom: 10px;';
        
        const label = document.createElement('label');
        label.textContent = `Opacity: ${Math.round(this.globalOptions.opacity * 100)}%`;
        label.style.cssText = 'display: block; margin-bottom: 5px;';
        
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = '0';
        slider.max = '100';
        slider.value = this.globalOptions.opacity * 100;
        slider.style.cssText = 'width: 100%;';
        
        slider.addEventListener('input', (e) => {
            const opacity = e.target.value / 100;
            this.updateOption('opacity', opacity);
            label.textContent = `Opacity: ${e.target.value}%`;
        });
        
        wrapper.appendChild(label);
        wrapper.appendChild(slider);
        container.appendChild(wrapper);
    }
    
    createLineStyleSelector(container) {
        const wrapper = document.createElement('div');
        wrapper.style.cssText = 'margin-bottom: 10px;';
        
        const label = document.createElement('label');
        label.textContent = 'Line Style: ';
        label.style.cssText = 'display: block; margin-bottom: 5px;';
        
        const styles = [
            { name: 'Solid', value: 'solid', dash: [] },
            { name: 'Dashed', value: 'dashed', dash: [10, 10] },
            { name: 'Dotted', value: 'dotted', dash: [2, 8] }
        ];
        
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = 'display: flex; gap: 5px;';
        
        styles.forEach(style => {
            const button = document.createElement('button');
            button.textContent = style.name;
            button.style.cssText = `
                padding: 5px 10px;
                border: 1px solid #ddd;
                background: white;
                cursor: pointer;
            `;
            
            button.addEventListener('click', () => {
                this.updateOption('strokeStyle', style.value);
                this.updateOption('lineDash', style.dash);
                this.highlightSelectedButton(buttonsContainer, button);
            });
            
            buttonsContainer.appendChild(button);
        });
        
        wrapper.appendChild(label);
        wrapper.appendChild(buttonsContainer);
        container.appendChild(wrapper);
    }
    
    createStylePresets(container) {
        const wrapper = document.createElement('div');
        wrapper.style.cssText = 'margin-top: 20px; padding-top: 10px; border-top: 1px solid #eee;';
        
        const label = document.createElement('label');
        label.textContent = 'Style Presets: ';
        label.style.cssText = 'display: block; margin-bottom: 5px;';
        
        const presetsContainer = document.createElement('div');
        presetsContainer.style.cssText = 'display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px;';
        
        this.stylePresets.forEach(preset => {
            const button = document.createElement('button');
            button.textContent = preset.name;
            button.style.cssText = `
                padding: 8px;
                border: 1px solid #ddd;
                background: white;
                cursor: pointer;
                border-radius: 4px;
            `;
            
            button.addEventListener('click', () => {
                this.applyPreset(preset);
            });
            
            presetsContainer.appendChild(button);
        });
        
        wrapper.appendChild(label);
        wrapper.appendChild(presetsContainer);
        container.appendChild(wrapper);
    }
    
    // 更新选项
    updateOption(key, value) {
        this.globalOptions[key] = value;
        
        // 更新当前工具的选项
        const currentTool = this.toolManager.getCurrentTool();
        if (currentTool) {
            currentTool.setOptions({ [key]: value });
        }
        
        // 触发选项变更事件
        this.toolManager.emitEvent('optionChange', { key, value });
    }
    
    // 应用预设
    applyPreset(preset) {
        Object.keys(preset.options).forEach(key => {
            this.updateOption(key, preset.options[key]);
        });
        
        // 更新UI
        this.updateUI();
    }
    
    // 添加最近颜色
    addRecentColor(color) {
        // 移除重复
        const index = this.recentColors.indexOf(color);
        if (index > -1) {
            this.recentColors.splice(index, 1);
        }
        
        // 添加到开头
        this.recentColors.unshift(color);
        
        // 限制数量
        if (this.recentColors.length > this.maxRecentColors) {
            this.recentColors.pop();
        }
        
        // 更新UI
        this.updateRecentColorsUI();
    }
    
    updateRecentColorsUI() {
        if (!this.recentColorsContainer) return;
        
        this.recentColorsContainer.innerHTML = '';
        
        this.recentColors.forEach(color => {
            const colorButton = document.createElement('button');
            colorButton.style.cssText = `
                width: 25px;
                height: 25px;
                background: ${color};
                border: 1px solid #ddd;
                cursor: pointer;
                border-radius: 4px;
            `;
            
            colorButton.addEventListener('click', () => {
                this.updateOption('strokeColor', color);
            });
            
            this.recentColorsContainer.appendChild(colorButton);
        });
    }
    
    highlightSelectedButton(container, selectedButton) {
        container.querySelectorAll('button').forEach(button => {
            button.style.background = 'white';
        });
        selectedButton.style.background = '#e3f2fd';
    }
    
    updateUI() {
        // 更新所有UI控件以反映当前选项
        // 实现细节...
    }
    
    setupEventListeners() {
        // 监听工具变更
        this.toolManager.addEventListener('toolChange', (data) => {
            this.onToolChange(data.current);
        });
    }
    
    onToolChange(toolName) {
        // 根据工具类型显示/隐藏特定选项
        // 实现细节...
    }
    
    // 获取当前选项
    getOptions() {
        return { ...this.globalOptions };
    }
    
    // 设置选项
    setOptions(options) {
        Object.assign(this.globalOptions, options);
        this.updateUI();
    }
}
```

## 7.2 基础绘图工具

### 7.2.1 矩形和椭圆工具

实现基础的形状绘制工具。

```javascript
// 矩形工具
class RectangleTool extends BaseTool {
    constructor(manager) {
        super(manager);
        this.name = 'rectangle';
        this.cursor = 'crosshair';
        this.tempRect = null;
    }
    
    onDragStart(point, event) {
        this.tempRect = {
            startPoint: { ...point },
            endPoint: { ...point }
        };
    }
    
    onDragMove(point, event) {
        if (!this.tempRect) return;
        
        this.tempRect.endPoint = { ...point };
        
        // 按住Shift键绘制正方形
        if (this.manager.toolState.modifiers.shift) {
            this.constrainToSquare();
        }
        
        // 按住Alt键从中心绘制
        if (this.manager.toolState.modifiers.alt) {
            this.drawFromCenter();
        }
        
        // 绘制预览
        this.drawPreview();
    }
    
    onDragEnd(point, event) {
        if (!this.tempRect) return;
        
        const bounds = this.getRectBounds();
        
        // 创建矩形元素
        const rectangle = this.createElement('rectangle', {
            position: {
                x: bounds.x + bounds.width / 2,
                y: bounds.y + bounds.height / 2
            },
            size: {
                width: bounds.width,
                height: bounds.height
            },
            cornerRadius: this.options.roundness || 0
        });
        
        // 添加到场景
        this.addElement(rectangle);
        
        // 清理
        this.cleanup();
    }
    
    constrainToSquare() {
        const dx = this.tempRect.endPoint.x - this.tempRect.startPoint.x;
        const dy = this.tempRect.endPoint.y - this.tempRect.startPoint.y;
        const size = Math.max(Math.abs(dx), Math.abs(dy));
        
        this.tempRect.endPoint = {
            x: this.tempRect.startPoint.x + size * Math.sign(dx),
            y: this.tempRect.startPoint.y + size * Math.sign(dy)
        };
    }
    
    drawFromCenter() {
        const dx = this.tempRect.endPoint.x - this.tempRect.startPoint.x;
        const dy = this.tempRect.endPoint.y - this.tempRect.startPoint.y;
        
        // 调整起点使原始起点成为中心
        const adjustedStart = {
            x: this.tempRect.startPoint.x - dx,
            y: this.tempRect.startPoint.y - dy
        };
        
        this.tempRect = {
            startPoint: adjustedStart,
            endPoint: this.tempRect.endPoint
        };
    }
    
    getRectBounds() {
        if (!this.tempRect) return null;
        
        const x = Math.min(this.tempRect.startPoint.x, this.tempRect.endPoint.x);
        const y = Math.min(this.tempRect.startPoint.y, this.tempRect.endPoint.y);
        const width = Math.abs(this.tempRect.endPoint.x - this.tempRect.startPoint.x);
        const height = Math.abs(this.tempRect.endPoint.y - this.tempRect.startPoint.y);
        
        return { x, y, width, height };
    }
    
    drawPreview() {
        const ctx = this.getOverlayContext();
        const bounds = this.getRectBounds();
        
        if (!bounds || bounds.width === 0 || bounds.height === 0) return;
        
        // 清除之前的预览
        this.manager.clearOverlay();
        
        // 设置样式
        ctx.save();
        ctx.strokeStyle = this.options.strokeColor;
        ctx.fillStyle = this.options.fillColor;
        ctx.lineWidth = this.options.strokeWidth;
        ctx.globalAlpha = this.options.opacity * 0.5;
        
        if (this.options.lineDash.length > 0) {
            ctx.setLineDash(this.options.lineDash);
        }
        
        // 绘制矩形
        if (this.options.roundness > 0) {
            this.drawRoundedRect(ctx, bounds);
        } else {
            ctx.rect(bounds.x, bounds.y, bounds.width, bounds.height);
        }
        
        // 填充和描边
        if (this.options.fillColor !== 'transparent') {
            ctx.fill();
        }
        ctx.stroke();
        
        // 绘制尺寸标注
        this.drawDimensions(ctx, bounds);
        
        ctx.restore();
    }
    
    drawRoundedRect(ctx, bounds) {
        const radius = Math.min(this.options.roundness, bounds.width / 2, bounds.height / 2);
        
        ctx.beginPath();
        ctx.moveTo(bounds.x + radius, bounds.y);
        ctx.lineTo(bounds.x + bounds.width - radius, bounds.y);
        ctx.quadraticCurveTo(bounds.x + bounds.width, bounds.y, bounds.x + bounds.width, bounds.y + radius);
        ctx.lineTo(bounds.x + bounds.width, bounds.y + bounds.height - radius);
        ctx.quadraticCurveTo(bounds.x + bounds.width, bounds.y + bounds.height, bounds.x + bounds.width - radius, bounds.y + bounds.height);
        ctx.lineTo(bounds.x + radius, bounds.y + bounds.height);
        ctx.quadraticCurveTo(bounds.x, bounds.y + bounds.height, bounds.x, bounds.y + bounds.height - radius);
        ctx.lineTo(bounds.x, bounds.y + radius);
        ctx.quadraticCurveTo(bounds.x, bounds.y, bounds.x + radius, bounds.y);
        ctx.closePath();
    }
    
    drawDimensions(ctx, bounds) {
        ctx.save();
        ctx.fillStyle = '#666';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        const text = `${Math.round(bounds.width)} × ${Math.round(bounds.height)}`;
        const x = bounds.x + bounds.width / 2;
        const y = bounds.y + bounds.height / 2;
        
        // 背景
        const metrics = ctx.measureText(text);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.fillRect(
            x - metrics.width / 2 - 4,
            y - 8,
            metrics.width + 8,
            16
        );
        
        // 文本
        ctx.fillStyle = '#666';
        ctx.fillText(text, x, y);
        
        ctx.restore();
    }
    
    cleanup() {
        super.cleanup();
        this.tempRect = null;
    }
}

// 椭圆工具
class EllipseTool extends BaseTool {
    constructor(manager) {
        super(manager);
        this.name = 'ellipse';
        this.cursor = 'crosshair';
        this.tempEllipse = null;
    }
    
    onDragStart(point, event) {
        this.tempEllipse = {
            startPoint: { ...point },
            endPoint: { ...point }
        };
    }
    
    onDragMove(point, event) {
        if (!this.tempEllipse) return;
        
        this.tempEllipse.endPoint = { ...point };
        
        // 按住Shift键绘制圆形
        if (this.manager.toolState.modifiers.shift) {
            this.constrainToCircle();
        }
        
        // 按住Alt键从中心绘制
        if (this.manager.toolState.modifiers.alt) {
            this.drawFromCenter();
        }
        
        // 绘制预览
        this.drawPreview();
    }
    
    onDragEnd(point, event) {
        if (!this.tempEllipse) return;
        
        const bounds = this.getEllipseBounds();
        
        // 创建椭圆元素
        const ellipse = this.createElement('ellipse', {
            position: {
                x: bounds.centerX,
                y: bounds.centerY
            },
            radiusX: bounds.radiusX,
            radiusY: bounds.radiusY
        });
        
        // 添加到场景
        this.addElement(ellipse);
        
        // 清理
        this.cleanup();
    }
    
    constrainToCircle() {
        const dx = this.tempEllipse.endPoint.x - this.tempEllipse.startPoint.x;
        const dy = this.tempEllipse.endPoint.y - this.tempEllipse.startPoint.y;
        const radius = Math.max(Math.abs(dx), Math.abs(dy));
        
        this.tempEllipse.endPoint = {
            x: this.tempEllipse.startPoint.x + radius * Math.sign(dx),
            y: this.tempEllipse.startPoint.y + radius * Math.sign(dy)
        };
    }
    
    drawFromCenter() {
        const dx = this.tempEllipse.endPoint.x - this.tempEllipse.startPoint.x;
        const dy = this.tempEllipse.endPoint.y - this.tempEllipse.startPoint.y;
        
        const adjustedStart = {
            x: this.tempEllipse.startPoint.x - dx,
            y: this.tempEllipse.startPoint.y - dy
        };
        
        this.tempEllipse = {
            startPoint: adjustedStart,
            endPoint: this.tempEllipse.endPoint
        };
    }
    
    getEllipseBounds() {
        if (!this.tempEllipse) return null;
        
        const x = Math.min(this.tempEllipse.startPoint.x, this.tempEllipse.endPoint.x);
        const y = Math.min(this.tempEllipse.startPoint.y, this.tempEllipse.endPoint.y);
        const width = Math.abs(this.tempEllipse.endPoint.x - this.tempEllipse.startPoint.x);
        const height = Math.abs(this.tempEllipse.endPoint.y - this.tempEllipse.startPoint.y);
        
        return {
            x, y, width, height,
            centerX: x + width / 2,
            centerY: y + height / 2,
            radiusX: width / 2,
            radiusY: height / 2
        };
    }
    
    drawPreview() {
        const ctx = this.getOverlayContext();
        const bounds = this.getEllipseBounds();
        
        if (!bounds || bounds.radiusX === 0 || bounds.radiusY === 0) return;
        
        // 清除之前的预览
        this.manager.clearOverlay();
        
        // 设置样式
        ctx.save();
        ctx.strokeStyle = this.options.strokeColor;
        ctx.fillStyle = this.options.fillColor;
        ctx.lineWidth = this.options.strokeWidth;
        ctx.globalAlpha = this.options.opacity * 0.5;
        
        if (this.options.lineDash.length > 0) {
            ctx.setLineDash(this.options.lineDash);
        }
        
        // 绘制椭圆
        ctx.beginPath();
        ctx.ellipse(
            bounds.centerX,
            bounds.centerY,
            bounds.radiusX,
            bounds.radiusY,
            0, 0, 2 * Math.PI
        );
        
        // 填充和描边
        if (this.options.fillColor !== 'transparent') {
            ctx.fill();
        }
        ctx.stroke();
        
        // 绘制尺寸标注
        this.drawDimensions(ctx, bounds);
        
        ctx.restore();
    }
    
    drawDimensions(ctx, bounds) {
        ctx.save();
        ctx.fillStyle = '#666';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        const text = bounds.radiusX === bounds.radiusY
            ? `r: ${Math.round(bounds.radiusX)}`
            : `${Math.round(bounds.radiusX * 2)} × ${Math.round(bounds.radiusY * 2)}`;
        
        // 背景
        const metrics = ctx.measureText(text);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.fillRect(
            bounds.centerX - metrics.width / 2 - 4,
            bounds.centerY - 8,
            metrics.width + 8,
            16
        );
        
        // 文本
        ctx.fillStyle = '#666';
        ctx.fillText(text, bounds.centerX, bounds.centerY);
        
        ctx.restore();
    }
    
    cleanup() {
        super.cleanup();
        this.tempEllipse = null;
    }
}
```

### 7.2.2 线条和箭头工具

实现线条绘制和箭头工具。

```javascript
// 线条工具
class LineTool extends BaseTool {
    constructor(manager) {
        super(manager);
        this.name = 'line';
        this.cursor = 'crosshair';
        this.tempLine = null;
        this.isDrawing = false;
    }
    
    onDragStart(point, event) {
        this.tempLine = {
            points: [{ ...point }],
            isMultiPoint: this.manager.toolState.modifiers.shift
        };
        this.isDrawing = true;
    }
    
    onDragMove(point, event) {
        if (!this.tempLine || !this.isDrawing) return;
        
        // 更新终点
        if (this.tempLine.isMultiPoint) {
            // 多点模式
            const lastPoint = this.tempLine.points[this.tempLine.points.length - 1];
            const distance = this.getDistance(lastPoint, point);
            
            if (distance > 10) {
                this.tempLine.points.push({ ...point });
            }
        } else {
            // 两点模式
            if (this.tempLine.points.length > 1) {
                this.tempLine.points[1] = { ...point };
            } else {
                this.tempLine.points.push({ ...point });
            }
            
            // 按住Shift键约束角度
            if (this.manager.toolState.modifiers.shift) {
                this.constrainAngle();
            }
        }
        
        this.drawPreview();
    }
    
    onDragEnd(point, event) {
        if (!this.tempLine || !this.isDrawing) return;
        
        // 确保至少有两个点
        if (this.tempLine.points.length < 2) {
            this.tempLine.points.push({ ...point });
        }
        
        // 创建线条元素
        const line = this.createElement('line', {
            points: this.tempLine.points.map(p => ({ ...p })),
            arrowStart: false,
            arrowEnd: false
        });
        
        // 添加到场景
        this.addElement(line);
        
        // 清理
        this.cleanup();
    }
    
    onMouseUp(point, event) {
        // 支持点击添加多段线
        if (this.tempLine && this.tempLine.isMultiPoint && this.isDrawing) {
            // 双击结束
            const now = Date.now();
            if (this.lastClickTime && now - this.lastClickTime < 300) {
                this.finishMultiPointLine();
            } else {
                this.lastClickTime = now;
            }
        }
    }
    
    onKeyDown(event) {
        // ESC键取消当前绘制
        if (event.key === 'Escape' && this.isDrawing) {
            this.cleanup();
        }
        
        // Enter键完成多点线
        if (event.key === 'Enter' && this.tempLine && this.tempLine.isMultiPoint) {
            this.finishMultiPointLine();
        }
    }
    
    constrainAngle() {
        if (this.tempLine.points.length !== 2) return;
        
        const start = this.tempLine.points[0];
        const end = this.tempLine.points[1];
        
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        const angle = Math.atan2(dy, dx);
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // 约束到45度的倍数
        const snapAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
        
        this.tempLine.points[1] = {
            x: start.x + Math.cos(snapAngle) * distance,
            y: start.y + Math.sin(snapAngle) * distance
        };
    }
    
    finishMultiPointLine() {
        if (!this.tempLine || this.tempLine.points.length < 2) {
            this.cleanup();
            return;
        }
        
        // 创建线条元素
        const line = this.createElement('line', {
            points: this.tempLine.points.map(p => ({ ...p })),
            arrowStart: false,
            arrowEnd: false
        });
        
        // 添加到场景
        this.addElement(line);
        
        // 清理
        this.cleanup();
    }
    
    drawPreview() {
        const ctx = this.getOverlayContext();
        
        if (!this.tempLine || this.tempLine.points.length < 1) return;
        
        // 清除之前的预览
        this.manager.clearOverlay();
        
        // 设置样式
        ctx.save();
        ctx.strokeStyle = this.options.strokeColor;
        ctx.lineWidth = this.options.strokeWidth;
        ctx.globalAlpha = this.options.opacity * 0.5;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        if (this.options.lineDash.length > 0) {
            ctx.setLineDash(this.options.lineDash);
        }
        
        // 绘制线条
        ctx.beginPath();
        ctx.moveTo(this.tempLine.points[0].x, this.tempLine.points[0].y);
        
        for (let i = 1; i < this.tempLine.points.length; i++) {
            ctx.lineTo(this.tempLine.points[i].x, this.tempLine.points[i].y);
        }
        
        ctx.stroke();
        
        // 绘制端点
        this.drawEndpoints(ctx);
        
        // 绘制长度标注
        if (this.tempLine.points.length === 2) {
            this.drawLength(ctx);
        }
        
        ctx.restore();
    }
    
    drawEndpoints(ctx) {
        ctx.save();
        ctx.fillStyle = this.options.strokeColor;
        
        this.tempLine.points.forEach((point, index) => {
            ctx.beginPath();
            ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
            ctx.fill();
        });
        
        ctx.restore();
    }
    
    drawLength(ctx) {
        const start = this.tempLine.points[0];
        const end = this.tempLine.points[1];
        const distance = this.getDistance(start, end);
        
        if (distance < 20) return;
        
        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2;
        const angle = Math.atan2(end.y - start.y, end.x - start.x);
        
        ctx.save();
        ctx.translate(midX, midY);
        ctx.rotate(angle);
        
        ctx.fillStyle = '#666';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        
        const text = `${Math.round(distance)}px`;
        
        // 背景
        const metrics = ctx.measureText(text);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.fillRect(-metrics.width / 2 - 2, -14, metrics.width + 4, 14);
        
        // 文本
        ctx.fillStyle = '#666';
        ctx.fillText(text, 0, -2);
        
        ctx.restore();
    }
    
    cleanup() {
        super.cleanup();
        this.tempLine = null;
        this.isDrawing = false;
        this.lastClickTime = null;
    }
}

// 箭头工具
class ArrowTool extends LineTool {
    constructor(manager) {
        super(manager);
        this.name = 'arrow';
        this.arrowStyle = 'single'; // 'single', 'double', 'none'
    }
    
    onDragEnd(point, event) {
        if (!this.tempLine || !this.isDrawing) return;
        
        // 确保至少有两个点
        if (this.tempLine.points.length < 2) {
            this.tempLine.points.push({ ...point });
        }
        
        // 创建箭头元素
        const arrow = this.createElement('line', {
            points: this.tempLine.points.map(p => ({ ...p })),
            arrowStart: this.arrowStyle === 'double',
            arrowEnd: this.arrowStyle !== 'none'
        });
        
        // 添加到场景
        this.addElement(arrow);
        
        // 清理
        this.cleanup();
    }
    
    drawPreview() {
        super.drawPreview();
        
        if (!this.tempLine || this.tempLine.points.length < 2) return;
        
        const ctx = this.getOverlayContext();
        
        ctx.save();
        ctx.strokeStyle = this.options.strokeColor;
        ctx.lineWidth = this.options.strokeWidth;
        ctx.globalAlpha = this.options.opacity * 0.5;
        
        // 绘制箭头
        const points = this.tempLine.points;
        
        if (this.arrowStyle !== 'none') {
            this.drawArrowhead(ctx, points[points.length - 2], points[points.length - 1]);
        }
        
        if (this.arrowStyle === 'double') {
            this.drawArrowhead(ctx, points[1], points[0]);
        }
        
        ctx.restore();
    }
    
    drawArrowhead(ctx, from, to) {
        const headLength = this.options.strokeWidth * 5;
        const headAngle = Math.PI / 6;
        
        const angle = Math.atan2(to.y - from.y, to.x - from.x);
        
        ctx.beginPath();
        ctx.moveTo(to.x, to.y);
        ctx.lineTo(
            to.x - headLength * Math.cos(angle - headAngle),
            to.y - headLength * Math.sin(angle - headAngle)
        );
        ctx.moveTo(to.x, to.y);
        ctx.lineTo(
            to.x - headLength * Math.cos(angle + headAngle),
            to.y - headLength * Math.sin(angle + headAngle)
        );
        ctx.stroke();
    }
    
    setArrowStyle(style) {
        this.arrowStyle = style;
    }
}
```

## 7.3 选择和编辑工具

### 7.3.1 选择工具

实现元素选择和多选功能。

```javascript
// 选择工具
class SelectTool extends BaseTool {
    constructor(manager) {
        super(manager);
        this.name = 'select';
        this.cursor = 'default';
        
        this.selectedElements = [];
        this.selectionBox = null;
        this.dragInfo = null;
        this.resizeHandle = null;
        this.rotateHandle = null;
    }
    
    onMouseDown(point, event) {
        // 检查是否点击了控制手柄
        const handle = this.getHandleAt(point);
        if (handle) {
            this.startHandleOperation(handle, point);
            return;
        }
        
        // 检查是否点击了元素
        const element = this.getElementAt(point);
        
        if (element) {
            // 处理元素选择
            if (this.manager.toolState.modifiers.shift) {
                // 添加到选择
                this.toggleElementSelection(element);
            } else if (!this.isElementSelected(element)) {
                // 选择新元素
                this.selectElement(element);
            }
            
            // 准备拖拽
            this.prepareDrag(point);
        } else {
            // 开始框选
            if (!this.manager.toolState.modifiers.shift) {
                this.clearSelection();
            }
            this.startSelectionBox(point);
        }
    }
    
    onDragStart(point, event) {
        if (this.dragInfo) {
            // 开始拖拽元素
            this.dragInfo.isDragging = true;
        }
    }
    
    onDragMove(point, event) {
        if (this.resizeHandle) {
            this.handleResize(point);
        } else if (this.rotateHandle) {
            this.handleRotate(point);
        } else if (this.dragInfo && this.dragInfo.isDragging) {
            this.handleDrag(point);
        } else if (this.selectionBox) {
            this.updateSelectionBox(point);
        }
    }
    
    onDragEnd(point, event) {
        if (this.selectionBox) {
            this.finishSelectionBox();
        } else if (this.dragInfo && this.dragInfo.isDragging) {
            this.finishDrag();
        } else if (this.resizeHandle) {
            this.finishResize();
        } else if (this.rotateHandle) {
            this.finishRotate();
        }
        
        // 清理临时状态
        this.dragInfo = null;
        this.resizeHandle = null;
        this.rotateHandle = null;
        this.selectionBox = null;
    }
    
    onMouseMove(point, event) {
        // 更新光标
        const handle = this.getHandleAt(point);
        if (handle) {
            this.updateCursorForHandle(handle);
        } else {
            const element = this.getElementAt(point);
            this.manager.app.canvas.style.cursor = element ? 'move' : 'default';
        }
    }
    
    onKeyDown(event) {
        // Delete键删除选中元素
        if (event.key === 'Delete' || event.key === 'Backspace') {
            this.deleteSelectedElements();
        }
        
        // Ctrl+A全选
        if (event.ctrlKey && event.key === 'a') {
            event.preventDefault();
            this.selectAll();
        }
        
        // Ctrl+D复制
        if (event.ctrlKey && event.key === 'd') {
            event.preventDefault();
            this.duplicateSelectedElements();
        }
        
        // 方向键移动
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
            event.preventDefault();
            this.moveSelectedElements(event.key, event.shiftKey ? 10 : 1);
        }
    }
    
    // 获取点击位置的元素
    getElementAt(point) {
        const elements = this.getApp().elementManager.getAllElements();
        
        // 从上到下遍历（z-index高的优先）
        for (let i = elements.length - 1; i >= 0; i--) {
            if (elements[i].containsPoint(point)) {
                return elements[i];
            }
        }
        
        return null;
    }
    
    // 选择元素
    selectElement(element) {
        this.selectedElements = [element];
        this.drawSelection();
    }
    
    // 切换元素选择状态
    toggleElementSelection(element) {
        const index = this.selectedElements.indexOf(element);
        if (index > -1) {
            this.selectedElements.splice(index, 1);
        } else {
            this.selectedElements.push(element);
        }
        this.drawSelection();
    }
    
    // 检查元素是否被选中
    isElementSelected(element) {
        return this.selectedElements.includes(element);
    }
    
    // 清除选择
    clearSelection() {
        this.selectedElements = [];
        this.manager.clearOverlay();
    }
    
    // 全选
    selectAll() {
        this.selectedElements = this.getApp().elementManager.getAllElements();
        this.drawSelection();
    }
    
    // 开始框选
    startSelectionBox(point) {
        this.selectionBox = {
            start: { ...point },
            end: { ...point }
        };
    }
    
    // 更新框选
    updateSelectionBox(point) {
        if (!this.selectionBox) return;
        
        this.selectionBox.end = { ...point };
        this.drawSelectionBox();
        
        // 实时更新选中的元素
        this.updateSelectionFromBox();
    }
    
    // 完成框选
    finishSelectionBox() {
        if (!this.selectionBox) return;
        
        this.updateSelectionFromBox();
        this.selectionBox = null;
        this.drawSelection();
    }
    
    // 根据框选更新选择
    updateSelectionFromBox() {
        if (!this.selectionBox) return;
        
        const box = {
            left: Math.min(this.selectionBox.start.x, this.selectionBox.end.x),
            top: Math.min(this.selectionBox.start.y, this.selectionBox.end.y),
            right: Math.max(this.selectionBox.start.x, this.selectionBox.end.x),
            bottom: Math.max(this.selectionBox.start.y, this.selectionBox.end.y)
        };
        
        const elements = this.getApp().elementManager.getAllElements();
        const selected = [];
        
        elements.forEach(element => {
            const bounds = element.getBoundingBox();
            
            // 检查元素是否在框选范围内
            if (bounds.left >= box.left && bounds.right <= box.right &&
                bounds.top >= box.top && bounds.bottom <= box.bottom) {
                selected.push(element);
            }
        });
        
        if (this.manager.toolState.modifiers.shift) {
            // 添加到现有选择
            selected.forEach(element => {
                if (!this.selectedElements.includes(element)) {
                    this.selectedElements.push(element);
                }
            });
        } else {
            this.selectedElements = selected;
        }
    }
    
    // 准备拖拽
    prepareDrag(point) {
        if (this.selectedElements.length === 0) return;
        
        this.dragInfo = {
            startPoint: { ...point },
            isDragging: false,
            originalPositions: this.selectedElements.map(el => ({
                element: el,
                position: { ...el.position }
            }))
        };
    }
    
    // 处理拖拽
    handleDrag(point) {
        if (!this.dragInfo) return;
        
        const dx = point.x - this.dragInfo.startPoint.x;
        const dy = point.y - this.dragInfo.startPoint.y;
        
        // 移动所有选中的元素
        this.dragInfo.originalPositions.forEach(({ element, position }) => {
            element.position.x = position.x + dx;
            element.position.y = position.y + dy;
        });
        
        // 重绘
        this.getApp().renderEngine.markDirty();
        this.drawSelection();
    }
    
    // 完成拖拽
    finishDrag() {
        // 提交变更到历史记录
        // this.getApp().historyManager.commit('move', this.dragInfo);
    }
    
    // 删除选中元素
    deleteSelectedElements() {
        if (this.selectedElements.length === 0) return;
        
        this.selectedElements.forEach(element => {
            this.getApp().elementManager.removeElement(element);
        });
        
        this.clearSelection();
        this.getApp().renderEngine.markDirty();
    }
    
    // 复制选中元素
    duplicateSelectedElements() {
        if (this.selectedElements.length === 0) return;
        
        const duplicated = [];
        
        this.selectedElements.forEach(element => {
            const clone = element.clone();
            clone.position.x += 20;
            clone.position.y += 20;
            
            this.getApp().elementManager.addElement(clone);
            duplicated.push(clone);
        });
        
        // 选中复制的元素
        this.selectedElements = duplicated;
        this.drawSelection();
        this.getApp().renderEngine.markDirty();
    }
    
    // 移动选中元素
    moveSelectedElements(direction, distance) {
        if (this.selectedElements.length === 0) return;
        
        const delta = { x: 0, y: 0 };
        
        switch (direction) {
            case 'ArrowUp':
                delta.y = -distance;
                break;
            case 'ArrowDown':
                delta.y = distance;
                break;
            case 'ArrowLeft':
                delta.x = -distance;
                break;
            case 'ArrowRight':
                delta.x = distance;
                break;
        }
        
        this.selectedElements.forEach(element => {
            element.position.x += delta.x;
            element.position.y += delta.y;
        });
        
        this.getApp().renderEngine.markDirty();
        this.drawSelection();
    }
    
    // 绘制选择框
    drawSelection() {
        const ctx = this.getOverlayContext();
        this.manager.clearOverlay();
        
        if (this.selectedElements.length === 0) return;
        
        ctx.save();
        ctx.strokeStyle = '#007acc';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        
        // 绘制每个选中元素的边界框
        this.selectedElements.forEach(element => {
            const bounds = element.getBoundingBox();
            ctx.strokeRect(bounds.left, bounds.top, bounds.width, bounds.height);
        });
        
        // 绘制控制手柄
        if (this.selectedElements.length === 1) {
            this.drawControlHandles(ctx, this.selectedElements[0]);
        } else {
            this.drawGroupControlHandles(ctx);
        }
        
        ctx.restore();
    }
    
    // 绘制控制手柄
    drawControlHandles(ctx, element) {
        const bounds = element.getBoundingBox();
        const handles = this.getHandlePositions(bounds);
        
        ctx.fillStyle = 'white';
        ctx.strokeStyle = '#007acc';
        ctx.lineWidth = 1;
        ctx.setLineDash([]);
        
        // 调整大小手柄
        handles.resize.forEach(handle => {
            ctx.fillRect(handle.x - 4, handle.y - 4, 8, 8);
            ctx.strokeRect(handle.x - 4, handle.y - 4, 8, 8);
        });
        
        // 旋转手柄
        if (handles.rotate) {
            ctx.beginPath();
            ctx.arc(handles.rotate.x, handles.rotate.y, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }
    }
    
    // 绘制组控制手柄
    drawGroupControlHandles(ctx) {
        const bounds = this.getGroupBounds();
        this.drawControlHandles(ctx, { getBoundingBox: () => bounds });
    }
    
    // 获取选中元素组的边界
    getGroupBounds() {
        if (this.selectedElements.length === 0) return null;
        
        let left = Infinity, top = Infinity, right = -Infinity, bottom = -Infinity;
        
        this.selectedElements.forEach(element => {
            const bounds = element.getBoundingBox();
            left = Math.min(left, bounds.left);
            top = Math.min(top, bounds.top);
            right = Math.max(right, bounds.right);
            bottom = Math.max(bottom, bounds.bottom);
        });
        
        return {
            left, top, right, bottom,
            width: right - left,
            height: bottom - top
        };
    }
    
    // 获取手柄位置
    getHandlePositions(bounds) {
        return {
            resize: [
                { x: bounds.left, y: bounds.top, type: 'nw' },
                { x: bounds.left + bounds.width / 2, y: bounds.top, type: 'n' },
                { x: bounds.right, y: bounds.top, type: 'ne' },
                { x: bounds.right, y: bounds.top + bounds.height / 2, type: 'e' },
                { x: bounds.right, y: bounds.bottom, type: 'se' },
                { x: bounds.left + bounds.width / 2, y: bounds.bottom, type: 's' },
                { x: bounds.left, y: bounds.bottom, type: 'sw' },
                { x: bounds.left, y: bounds.top + bounds.height / 2, type: 'w' }
            ],
            rotate: {
                x: bounds.left + bounds.width / 2,
                y: bounds.top - 20,
                type: 'rotate'
            }
        };
    }
    
    // 获取点击位置的手柄
    getHandleAt(point) {
        if (this.selectedElements.length === 0) return null;
        
        const bounds = this.selectedElements.length === 1
            ? this.selectedElements[0].getBoundingBox()
            : this.getGroupBounds();
            
        const handles = this.getHandlePositions(bounds);
        
        // 检查调整大小手柄
        for (const handle of handles.resize) {
            if (this.isPointInHandle(point, handle)) {
                return handle;
            }
        }
        
        // 检查旋转手柄
        if (handles.rotate && this.isPointInHandle(point, handles.rotate)) {
            return handles.rotate;
        }
        
        return null;
    }
    
    // 检查点是否在手柄内
    isPointInHandle(point, handle) {
        const distance = Math.sqrt(
            Math.pow(point.x - handle.x, 2) +
            Math.pow(point.y - handle.y, 2)
        );
        return distance <= 8;
    }
    
    // 更新手柄光标
    updateCursorForHandle(handle) {
        const cursors = {
            'nw': 'nw-resize',
            'n': 'n-resize',
            'ne': 'ne-resize',
            'e': 'e-resize',
            'se': 'se-resize',
            's': 's-resize',
            'sw': 'sw-resize',
            'w': 'w-resize',
            'rotate': 'grab'
        };
        
        this.manager.app.canvas.style.cursor = cursors[handle.type] || 'default';
    }
    
    // 绘制框选框
    drawSelectionBox() {
        if (!this.selectionBox) return;
        
        const ctx = this.getOverlayContext();
        this.manager.clearOverlay();
        
        ctx.save();
        ctx.strokeStyle = '#007acc';
        ctx.fillStyle = 'rgba(0, 122, 204, 0.1)';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        
        const x = Math.min(this.selectionBox.start.x, this.selectionBox.end.x);
        const y = Math.min(this.selectionBox.start.y, this.selectionBox.end.y);
        const width = Math.abs(this.selectionBox.end.x - this.selectionBox.start.x);
        const height = Math.abs(this.selectionBox.end.y - this.selectionBox.start.y);
        
        ctx.fillRect(x, y, width, height);
        ctx.strokeRect(x, y, width, height);
        
        ctx.restore();
    }
}
```

## 总结

本章详细介绍了工具系统与绘图工具的构建，包括：

1. **工具系统架构** - 设计了灵活的工具管理系统和选项配置
2. **基础绘图工具** - 实现了矩形、椭圆、线条、箭头等基础工具
3. **选择编辑工具** - 构建了完整的选择系统，支持多选、框选、控制手柄
4. **工具选项系统** - 提供了丰富的工具选项和预设样式管理

这套工具系统为构建专业的绘图应用提供了完整的交互基础，具有良好的扩展性和用户体验。在下一章中，我们将学习如何实现手绘风格效果。