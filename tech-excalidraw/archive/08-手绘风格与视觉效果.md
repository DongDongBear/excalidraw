# 第8章：手绘风格与视觉效果

## 学习目标
通过本章学习，你将掌握：
- 手绘风格的理论基础
- RoughJS库的深度应用
- 自定义手绘算法实现
- 线条抖动和变形算法
- 纹理和材质效果
- 阴影和光照效果
- 动画过渡效果
- 性能优化策略

## 8.1 手绘风格理论基础

### 8.1.1 手绘风格特征分析

理解真实手绘的视觉特征，是实现逼真手绘效果的基础。

```javascript
// 手绘风格分析器
class HandDrawnStyleAnalyzer {
    constructor() {
        // 手绘特征参数
        this.characteristics = {
            // 线条不均匀性
            lineVariation: {
                thickness: 0.2,    // 线宽变化幅度
                opacity: 0.15,     // 透明度变化
                position: 0.8      // 位置抖动
            },
            
            // 笔触特性
            strokeProperties: {
                pressure: true,     // 压感变化
                speed: true,        // 速度影响
                direction: true,    // 方向变化
                texture: 0.3       // 纹理强度
            },
            
            // 形状不完美性
            imperfection: {
                cornerRoughness: 0.5,   // 转角粗糙度
                edgeVariation: 0.3,     // 边缘变化
                symmetryBreaking: 0.2   // 对称性破坏
            },
            
            // 阴影和深度
            shadowing: {
                softness: 0.8,          // 阴影柔和度
                irregularity: 0.4,      // 不规则性
                transparency: 0.6       // 透明度
            }
        };
        
        // 手绘工具模拟
        this.tools = {
            pencil: {
                hardness: 0.3,
                texture: 0.8,
                blending: 0.2
            },
            pen: {
                hardness: 0.9,
                texture: 0.1,
                blending: 0.05
            },
            marker: {
                hardness: 0.6,
                texture: 0.4,
                blending: 0.7
            },
            brush: {
                hardness: 0.1,
                texture: 0.9,
                blending: 0.8
            }
        };
    }
    
    // 分析线条特征
    analyzeStroke(points, pressure = null) {
        return {
            length: this.calculatePathLength(points),
            curvature: this.calculateCurvature(points),
            speedVariation: this.calculateSpeedVariation(points),
            pressureVariation: pressure ? this.calculatePressureVariation(pressure) : 0,
            directionChanges: this.calculateDirectionChanges(points),
            smoothness: this.calculateSmoothness(points)
        };
    }
    
    calculatePathLength(points) {
        let length = 0;
        for (let i = 1; i < points.length; i++) {
            const dx = points[i].x - points[i-1].x;
            const dy = points[i].y - points[i-1].y;
            length += Math.sqrt(dx * dx + dy * dy);
        }
        return length;
    }
    
    calculateCurvature(points) {
        if (points.length < 3) return 0;
        
        let totalCurvature = 0;
        for (let i = 1; i < points.length - 1; i++) {
            const prev = points[i-1];
            const curr = points[i];
            const next = points[i+1];
            
            // 计算转角
            const angle1 = Math.atan2(curr.y - prev.y, curr.x - prev.x);
            const angle2 = Math.atan2(next.y - curr.y, next.x - curr.x);
            
            let angleDiff = Math.abs(angle2 - angle1);
            if (angleDiff > Math.PI) {
                angleDiff = 2 * Math.PI - angleDiff;
            }
            
            totalCurvature += angleDiff;
        }
        
        return totalCurvature / (points.length - 2);
    }
    
    calculateSpeedVariation(points) {
        if (points.length < 2) return 0;
        
        const speeds = [];
        for (let i = 1; i < points.length; i++) {
            const dx = points[i].x - points[i-1].x;
            const dy = points[i].y - points[i-1].y;
            const dt = points[i].timestamp - points[i-1].timestamp || 16; // 假设16ms
            speeds.push(Math.sqrt(dx * dx + dy * dy) / dt);
        }
        
        const avgSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;
        const variance = speeds.reduce((acc, speed) => acc + Math.pow(speed - avgSpeed, 2), 0) / speeds.length;
        
        return Math.sqrt(variance) / avgSpeed;
    }
    
    calculatePressureVariation(pressure) {
        const avgPressure = pressure.reduce((a, b) => a + b, 0) / pressure.length;
        const variance = pressure.reduce((acc, p) => acc + Math.pow(p - avgPressure, 2), 0) / pressure.length;
        return Math.sqrt(variance) / avgPressure;
    }
    
    calculateDirectionChanges(points) {
        if (points.length < 3) return 0;
        
        let changes = 0;
        let lastDirection = null;
        
        for (let i = 1; i < points.length; i++) {
            const dx = points[i].x - points[i-1].x;
            const dy = points[i].y - points[i-1].y;
            const direction = Math.atan2(dy, dx);
            
            if (lastDirection !== null) {
                let diff = Math.abs(direction - lastDirection);
                if (diff > Math.PI) {
                    diff = 2 * Math.PI - diff;
                }
                
                if (diff > Math.PI / 6) { // 30度以上算方向改变
                    changes++;
                }
            }
            
            lastDirection = direction;
        }
        
        return changes / (points.length - 2);
    }
    
    calculateSmoothness(points) {
        if (points.length < 3) return 1;
        
        let totalDeviation = 0;
        
        for (let i = 1; i < points.length - 1; i++) {
            const prev = points[i-1];
            const curr = points[i];
            const next = points[i+1];
            
            // 计算期望位置（直线插值）
            const expectedX = (prev.x + next.x) / 2;
            const expectedY = (prev.y + next.y) / 2;
            
            // 计算实际偏差
            const deviation = Math.sqrt(
                Math.pow(curr.x - expectedX, 2) + 
                Math.pow(curr.y - expectedY, 2)
            );
            
            totalDeviation += deviation;
        }
        
        const avgDeviation = totalDeviation / (points.length - 2);
        
        // 转换为平滑度（0-1，1为最平滑）
        return Math.max(0, 1 - avgDeviation / 10);
    }
    
    // 生成手绘风格参数
    generateStyleParameters(strokeAnalysis, toolType = 'pencil') {
        const tool = this.tools[toolType];
        const chars = this.characteristics;
        
        return {
            roughness: Math.min(1, strokeAnalysis.curvature * 2 + chars.imperfection.cornerRoughness),
            bowing: chars.imperfection.edgeVariation * (1 - strokeAnalysis.smoothness),
            stroke: {
                width: this.calculateDynamicStrokeWidth(strokeAnalysis, tool),
                opacity: this.calculateDynamicOpacity(strokeAnalysis, tool),
                roughness: chars.lineVariation.position * tool.texture
            },
            fill: {
                style: tool.texture > 0.5 ? 'hachure' : 'solid',
                opacity: tool.blending * 0.3,
                roughness: chars.imperfection.edgeVariation
            }
        };
    }
    
    calculateDynamicStrokeWidth(analysis, tool) {
        const baseWidth = 2;
        const variation = this.characteristics.lineVariation.thickness;
        const speedFactor = 1 - analysis.speedVariation * 0.5;
        const hardnessFactor = tool.hardness;
        
        return baseWidth * speedFactor * hardnessFactor * (1 + variation);
    }
    
    calculateDynamicOpacity(analysis, tool) {
        const baseOpacity = 1;
        const variation = this.characteristics.lineVariation.opacity;
        const pressureFactor = 1 - analysis.pressureVariation * 0.3;
        const hardnessFactor = tool.hardness;
        
        return baseOpacity * pressureFactor * hardnessFactor * (1 - variation);
    }
}
```

### 8.1.2 随机化和噪声算法

实现各种噪声算法来生成自然的不规则效果。

```javascript
// 噪声生成器
class NoiseGenerator {
    constructor(seed = Date.now()) {
        this.seed = seed;
        this.rng = new SeededRandom(seed);
    }
    
    // Perlin噪声实现
    perlinNoise(x, y, frequency = 1, amplitude = 1, octaves = 1) {
        let value = 0;
        let currentAmplitude = amplitude;
        let currentFrequency = frequency;
        
        for (let i = 0; i < octaves; i++) {
            value += this.noise(x * currentFrequency, y * currentFrequency) * currentAmplitude;
            currentAmplitude *= 0.5;
            currentFrequency *= 2;
        }
        
        return value;
    }
    
    // 基础噪声函数
    noise(x, y) {
        const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
        return (n - Math.floor(n)) * 2 - 1;
    }
    
    // 分数布朗运动
    fbm(x, y, octaves = 4, lacunarity = 2.0, gain = 0.5) {
        let value = 0;
        let amplitude = 1;
        let frequency = 1;
        
        for (let i = 0; i < octaves; i++) {
            value += amplitude * this.noise(x * frequency, y * frequency);
            frequency *= lacunarity;
            amplitude *= gain;
        }
        
        return value;
    }
    
    // 湍流噪声
    turbulence(x, y, size = 1) {
        let value = 0;
        let currentSize = size;
        
        while (currentSize >= 1) {
            value += Math.abs(this.noise(x / currentSize, y / currentSize)) * currentSize;
            currentSize /= 2;
        }
        
        return value / size;
    }
    
    // 细胞噪声（Worley噪声）
    cellularNoise(x, y, scale = 1) {
        const cellX = Math.floor(x * scale);
        const cellY = Math.floor(y * scale);
        
        let minDistance = Infinity;
        
        for (let offsetX = -1; offsetX <= 1; offsetX++) {
            for (let offsetY = -1; offsetY <= 1; offsetY++) {
                const neighborX = cellX + offsetX;
                const neighborY = cellY + offsetY;
                
                // 生成细胞中心点
                const centerX = neighborX + this.rng.random();
                const centerY = neighborY + this.rng.random();
                
                // 计算距离
                const distance = Math.sqrt(
                    Math.pow((x * scale) - centerX, 2) + 
                    Math.pow((y * scale) - centerY, 2)
                );
                
                minDistance = Math.min(minDistance, distance);
            }
        }
        
        return minDistance;
    }
    
    // 脊形噪声
    ridgedNoise(x, y, frequency = 1, amplitude = 1, ridgeOffset = 1) {
        let signal = Math.abs(this.noise(x * frequency, y * frequency));
        signal = ridgeOffset - signal;
        signal = signal * signal;
        return signal * amplitude;
    }
    
    // 多层次脊形噪声
    ridgedFbm(x, y, octaves = 4, lacunarity = 2.0, gain = 0.5, ridgeOffset = 1) {
        let value = 0;
        let amplitude = 1;
        let frequency = 1;
        let weight = 1;
        
        for (let i = 0; i < octaves; i++) {
            let signal = this.ridgedNoise(x, y, frequency, 1, ridgeOffset);
            signal *= weight;
            weight = Math.max(0, Math.min(1, signal * 2));
            
            value += signal * amplitude;
            frequency *= lacunarity;
            amplitude *= gain;
        }
        
        return value;
    }
}

// 伪随机数生成器
class SeededRandom {
    constructor(seed) {
        this.seed = seed;
    }
    
    random() {
        const x = Math.sin(this.seed++) * 10000;
        return x - Math.floor(x);
    }
    
    randomRange(min, max) {
        return min + this.random() * (max - min);
    }
    
    randomInt(min, max) {
        return Math.floor(this.randomRange(min, max + 1));
    }
    
    randomGaussian(mean = 0, variance = 1) {
        // Box-Muller变换
        if (this.hasNextGaussian) {
            this.hasNextGaussian = false;
            return this.nextGaussian * variance + mean;
        }
        
        const v1 = 2 * this.random() - 1;
        const v2 = 2 * this.random() - 1;
        const s = v1 * v1 + v2 * v2;
        
        if (s >= 1 || s === 0) {
            return this.randomGaussian(mean, variance);
        }
        
        const multiplier = Math.sqrt(-2 * Math.log(s) / s);
        this.nextGaussian = v2 * multiplier;
        this.hasNextGaussian = true;
        
        return v1 * multiplier * variance + mean;
    }
}
```

## 8.2 RoughJS集成与定制

### 8.2.1 RoughJS深度应用

深入了解和扩展RoughJS库的功能。

```javascript
// RoughJS集成管理器
class RoughJSIntegration {
    constructor(canvas) {
        this.canvas = canvas;
        this.roughCanvas = rough.canvas(canvas);
        this.roughSvg = null;
        
        // 自定义生成器
        this.customGenerator = new CustomRoughGenerator();
        
        // 样式库
        this.styleLibrary = new RoughStyleLibrary();
        
        // 缓存
        this.shapeCache = new Map();
        this.maxCacheSize = 1000;
    }
    
    // 绘制粗糙矩形
    drawRoughRectangle(x, y, width, height, options = {}) {
        const cacheKey = this.getCacheKey('rectangle', { x, y, width, height }, options);
        
        if (this.shapeCache.has(cacheKey)) {
            return this.shapeCache.get(cacheKey);
        }
        
        // 扩展选项
        const extendedOptions = this.extendOptions(options);
        
        // 生成形状
        const drawable = this.roughCanvas.generator.rectangle(x, y, width, height, extendedOptions);
        
        // 缓存结果
        this.cacheShape(cacheKey, drawable);
        
        return drawable;
    }
    
    // 绘制粗糙椭圆
    drawRoughEllipse(cx, cy, width, height, options = {}) {
        const cacheKey = this.getCacheKey('ellipse', { cx, cy, width, height }, options);
        
        if (this.shapeCache.has(cacheKey)) {
            return this.shapeCache.get(cacheKey);
        }
        
        const extendedOptions = this.extendOptions(options);
        const drawable = this.roughCanvas.generator.ellipse(cx, cy, width, height, extendedOptions);
        
        this.cacheShape(cacheKey, drawable);
        return drawable;
    }
    
    // 绘制粗糙路径
    drawRoughPath(d, options = {}) {
        const cacheKey = this.getCacheKey('path', { d }, options);
        
        if (this.shapeCache.has(cacheKey)) {
            return this.shapeCache.get(cacheKey);
        }
        
        const extendedOptions = this.extendOptions(options);
        const drawable = this.roughCanvas.generator.path(d, extendedOptions);
        
        this.cacheShape(cacheKey, drawable);
        return drawable;
    }
    
    // 绘制自由形状
    drawFreehand(points, options = {}) {
        const pathData = this.pointsToPath(points);
        return this.drawRoughPath(pathData, options);
    }
    
    // 点转路径
    pointsToPath(points) {
        if (points.length < 2) return '';
        
        let path = `M ${points[0].x} ${points[0].y}`;
        
        for (let i = 1; i < points.length; i++) {
            path += ` L ${points[i].x} ${points[i].y}`;
        }
        
        return path;
    }
    
    // 扩展选项
    extendOptions(options) {
        const defaults = {
            roughness: 1,
            bowing: 1,
            stroke: '#000',
            strokeWidth: 1,
            fill: 'transparent',
            fillStyle: 'hachure',
            fillWeight: 1,
            hachureAngle: -41,
            hachureGap: 4,
            curveStepCount: 200,
            curveFitting: 0.95,
            simplification: 0,
            maxRandomnessOffset: 2,
            disableMultiStroke: false,
            disableMultiStrokeFill: false,
            preserveVertices: false
        };
        
        return { ...defaults, ...options };
    }
    
    // 生成缓存键
    getCacheKey(type, geometry, options) {
        const geoStr = JSON.stringify(geometry);
        const optStr = JSON.stringify(options);
        return `${type}_${this.hashString(geoStr + optStr)}`;
    }
    
    // 字符串哈希
    hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // 转换为32位整数
        }
        return hash;
    }
    
    // 缓存形状
    cacheShape(key, drawable) {
        if (this.shapeCache.size >= this.maxCacheSize) {
            // 删除最老的条目
            const firstKey = this.shapeCache.keys().next().value;
            this.shapeCache.delete(firstKey);
        }
        
        this.shapeCache.set(key, drawable);
    }
    
    // 渲染drawable
    render(drawable) {
        this.roughCanvas.draw(drawable);
    }
    
    // 批量渲染
    renderBatch(drawables) {
        drawables.forEach(drawable => {
            this.roughCanvas.draw(drawable);
        });
    }
    
    // 清除缓存
    clearCache() {
        this.shapeCache.clear();
    }
}

// 自定义RoughJS生成器
class CustomRoughGenerator {
    constructor() {
        this.noiseGenerator = new NoiseGenerator();
    }
    
    // 生成更自然的线条
    generateNaturalLine(x1, y1, x2, y2, options = {}) {
        const points = [];
        const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        const segments = Math.max(2, Math.floor(distance / 10));
        
        const roughness = options.roughness || 1;
        const bowing = options.bowing || 1;
        
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const x = x1 + (x2 - x1) * t;
            const y = y1 + (y2 - y1) * t;
            
            // 添加噪声
            const noiseX = this.noiseGenerator.perlinNoise(x * 0.01, y * 0.01) * roughness * 2;
            const noiseY = this.noiseGenerator.perlinNoise(x * 0.01 + 100, y * 0.01 + 100) * roughness * 2;
            
            // 添加弯曲
            const bowingOffset = Math.sin(t * Math.PI) * bowing * (distance * 0.01);
            
            points.push({
                x: x + noiseX,
                y: y + noiseY + bowingOffset
            });
        }
        
        return points;
    }
    
    // 生成自然的曲线
    generateNaturalCurve(points, options = {}) {
        if (points.length < 2) return points;
        
        const smoothness = options.smoothness || 0.5;
        const roughness = options.roughness || 1;
        const result = [];
        
        // 使用Catmull-Rom样条插值
        for (let i = 0; i < points.length - 1; i++) {
            const p0 = points[Math.max(0, i - 1)];
            const p1 = points[i];
            const p2 = points[i + 1];
            const p3 = points[Math.min(points.length - 1, i + 2)];
            
            const segments = 10;
            for (let t = 0; t < segments; t++) {
                const u = t / segments;
                const interpolated = this.catmullRomInterpolate(p0, p1, p2, p3, u);
                
                // 添加噪声
                const noise = this.noiseGenerator.perlinNoise(
                    interpolated.x * 0.01, 
                    interpolated.y * 0.01
                ) * roughness;
                
                result.push({
                    x: interpolated.x + noise,
                    y: interpolated.y + noise
                });
            }
        }
        
        return result;
    }
    
    // Catmull-Rom样条插值
    catmullRomInterpolate(p0, p1, p2, p3, t) {
        const t2 = t * t;
        const t3 = t2 * t;
        
        const x = 0.5 * (
            (2 * p1.x) +
            (-p0.x + p2.x) * t +
            (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 +
            (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3
        );
        
        const y = 0.5 * (
            (2 * p1.y) +
            (-p0.y + p2.y) * t +
            (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 +
            (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3
        );
        
        return { x, y };
    }
    
    // 生成有机形状
    generateOrganicShape(center, radius, sides = 6, options = {}) {
        const points = [];
        const roughness = options.roughness || 1;
        const asymmetry = options.asymmetry || 0.2;
        
        for (let i = 0; i < sides; i++) {
            const angle = (i / sides) * Math.PI * 2;
            
            // 基础位置
            let r = radius;
            
            // 添加不对称性
            r *= (1 + this.noiseGenerator.randomGaussian(0, asymmetry));
            
            // 添加角度变化
            const angleNoise = this.noiseGenerator.perlinNoise(
                Math.cos(angle) * 0.1, 
                Math.sin(angle) * 0.1
            ) * roughness * 0.1;
            
            const x = center.x + Math.cos(angle + angleNoise) * r;
            const y = center.y + Math.sin(angle + angleNoise) * r;
            
            points.push({ x, y });
        }
        
        return points;
    }
}
```

### 8.2.2 填充样式和纹理

实现各种填充样式和纹理效果。

```javascript
// 填充样式管理器
class FillStyleManager {
    constructor() {
        this.patterns = new Map();
        this.textures = new Map();
        this.noiseGenerator = new NoiseGenerator();
    }
    
    // 注册填充样式
    registerFillStyle(name, generator) {
        this.patterns.set(name, generator);
    }
    
    // 生成hachure填充
    generateHachureFill(bounds, options = {}) {
        const {
            angle = -41,
            gap = 4,
            strokeWidth = 1,
            roughness = 1
        } = options;
        
        const lines = [];
        const angleRad = (angle * Math.PI) / 180;
        const cos = Math.cos(angleRad);
        const sin = Math.sin(angleRad);
        
        // 计算填充范围
        const diagonal = Math.sqrt(bounds.width * bounds.width + bounds.height * bounds.height);
        const steps = Math.ceil(diagonal / gap);
        
        for (let i = 0; i < steps; i++) {
            const offset = i * gap - diagonal / 2;
            
            // 计算线条起点和终点
            const startX = bounds.x + bounds.width / 2 + offset * cos;
            const startY = bounds.y + bounds.height / 2 + offset * sin;
            const endX = startX - bounds.height * sin;
            const endY = startY + bounds.height * cos;
            
            // 裁剪到边界内
            const clippedLine = this.clipLineToRect(
                { x: startX, y: startY },
                { x: endX, y: endY },
                bounds
            );
            
            if (clippedLine) {
                // 添加粗糙度
                const roughLine = this.addRoughnessToLine(clippedLine, roughness);
                lines.push(roughLine);
            }
        }
        
        return lines;
    }
    
    // 生成十字hachure填充
    generateCrossHatchFill(bounds, options = {}) {
        const {
            angle1 = -41,
            angle2 = 41,
            gap = 4,
            strokeWidth = 1,
            roughness = 1
        } = options;
        
        const lines1 = this.generateHachureFill(bounds, { 
            ...options, 
            angle: angle1 
        });
        
        const lines2 = this.generateHachureFill(bounds, { 
            ...options, 
            angle: angle2 
        });
        
        return [...lines1, ...lines2];
    }
    
    // 生成点填充
    generateDotsFill(bounds, options = {}) {
        const {
            density = 0.1,
            dotSize = 1,
            roughness = 1,
            irregularity = 0.2
        } = options;
        
        const dots = [];
        const area = bounds.width * bounds.height;
        const dotCount = Math.floor(area * density / 100);
        
        for (let i = 0; i < dotCount; i++) {
            const x = bounds.x + this.noiseGenerator.rng.random() * bounds.width;
            const y = bounds.y + this.noiseGenerator.rng.random() * bounds.height;
            
            // 添加不规则性
            const size = dotSize * (1 + this.noiseGenerator.rng.randomGaussian(0, irregularity));
            
            dots.push({
                x: x,
                y: y,
                size: Math.max(0.5, size)
            });
        }
        
        return dots;
    }
    
    // 生成星形填充
    generateStarsFill(bounds, options = {}) {
        const {
            density = 0.05,
            starSize = 2,
            points = 5,
            roughness = 1
        } = options;
        
        const stars = [];
        const area = bounds.width * bounds.height;
        const starCount = Math.floor(area * density / 100);
        
        for (let i = 0; i < starCount; i++) {
            const x = bounds.x + this.noiseGenerator.rng.random() * bounds.width;
            const y = bounds.y + this.noiseGenerator.rng.random() * bounds.height;
            
            const star = this.generateStar(x, y, starSize, points, roughness);
            stars.push(star);
        }
        
        return stars;
    }
    
    // 生成涂鸦填充
    generateDoodleFill(bounds, options = {}) {
        const {
            density = 0.3,
            strokeWidth = 1,
            roughness = 2,
            curviness = 0.5
        } = options;
        
        const doodles = [];
        const area = bounds.width * bounds.height;
        const doodleCount = Math.floor(area * density / 1000);
        
        for (let i = 0; i < doodleCount; i++) {
            const startX = bounds.x + this.noiseGenerator.rng.random() * bounds.width;
            const startY = bounds.y + this.noiseGenerator.rng.random() * bounds.height;
            
            const doodle = this.generateRandomDoodle(startX, startY, roughness, curviness);
            doodles.push(doodle);
        }
        
        return doodles;
    }
    
    // 生成纹理填充
    generateTextureFill(bounds, textureName, options = {}) {
        const texture = this.textures.get(textureName);
        if (!texture) {
            console.warn(`Texture '${textureName}' not found`);
            return [];
        }
        
        return texture.generate(bounds, options);
    }
    
    // 生成星形
    generateStar(cx, cy, radius, points, roughness) {
        const vertices = [];
        const angleStep = (Math.PI * 2) / points;
        
        for (let i = 0; i < points * 2; i++) {
            const angle = i * angleStep / 2;
            const r = i % 2 === 0 ? radius : radius * 0.5;
            
            // 添加粗糙度
            const roughR = r * (1 + this.noiseGenerator.rng.randomGaussian(0, roughness * 0.1));
            
            const x = cx + Math.cos(angle) * roughR;
            const y = cy + Math.sin(angle) * roughR;
            
            vertices.push({ x, y });
        }
        
        return vertices;
    }
    
    // 生成随机涂鸦
    generateRandomDoodle(startX, startY, roughness, curviness) {
        const points = [];
        const length = 20 + this.noiseGenerator.rng.random() * 40;
        const segments = Math.floor(length / 5);
        
        let currentX = startX;
        let currentY = startY;
        let currentAngle = this.noiseGenerator.rng.random() * Math.PI * 2;
        
        points.push({ x: currentX, y: currentY });
        
        for (let i = 0; i < segments; i++) {
            // 随机改变方向
            currentAngle += this.noiseGenerator.rng.randomGaussian(0, curviness);
            
            // 随机步长
            const stepSize = 3 + this.noiseGenerator.rng.random() * 7;
            
            currentX += Math.cos(currentAngle) * stepSize;
            currentY += Math.sin(currentAngle) * stepSize;
            
            // 添加噪声
            const noiseX = this.noiseGenerator.rng.randomGaussian(0, roughness * 0.5);
            const noiseY = this.noiseGenerator.rng.randomGaussian(0, roughness * 0.5);
            
            points.push({
                x: currentX + noiseX,
                y: currentY + noiseY
            });
        }
        
        return points;
    }
    
    // 裁剪线条到矩形
    clipLineToRect(start, end, rect) {
        // 使用Liang-Barsky算法
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        
        const p = [-dx, dx, -dy, dy];
        const q = [
            start.x - rect.x,
            rect.x + rect.width - start.x,
            start.y - rect.y,
            rect.y + rect.height - start.y
        ];
        
        let t0 = 0, t1 = 1;
        
        for (let i = 0; i < 4; i++) {
            if (p[i] === 0) {
                if (q[i] < 0) return null;
            } else {
                const t = q[i] / p[i];
                if (p[i] < 0) {
                    t0 = Math.max(t0, t);
                } else {
                    t1 = Math.min(t1, t);
                }
            }
        }
        
        if (t0 > t1) return null;
        
        return {
            start: {
                x: start.x + t0 * dx,
                y: start.y + t0 * dy
            },
            end: {
                x: start.x + t1 * dx,
                y: start.y + t1 * dy
            }
        };
    }
    
    // 给线条添加粗糙度
    addRoughnessToLine(line, roughness) {
        if (roughness === 0) return line;
        
        const points = [];
        const distance = Math.sqrt(
            Math.pow(line.end.x - line.start.x, 2) + 
            Math.pow(line.end.y - line.start.y, 2)
        );
        
        const segments = Math.max(2, Math.floor(distance / 10));
        
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const x = line.start.x + (line.end.x - line.start.x) * t;
            const y = line.start.y + (line.end.y - line.start.y) * t;
            
            // 添加垂直于线条方向的噪声
            const perpAngle = Math.atan2(line.end.y - line.start.y, line.end.x - line.start.x) + Math.PI / 2;
            const noise = this.noiseGenerator.rng.randomGaussian(0, roughness);
            
            points.push({
                x: x + Math.cos(perpAngle) * noise,
                y: y + Math.sin(perpAngle) * noise
            });
        }
        
        return points;
    }
}
```

## 8.3 高级视觉效果

### 8.3.1 阴影和光照系统

实现逼真的阴影和光照效果。

```javascript
// 阴影和光照管理器
class ShadowLightingManager {
    constructor() {
        this.lightSources = [];
        this.ambientLight = 0.3;
        this.shadowSettings = {
            enabled: true,
            blur: 4,
            opacity: 0.3,
            offset: { x: 2, y: 2 },
            color: 'rgba(0, 0, 0, 0.3)'
        };
        
        this.noiseGenerator = new NoiseGenerator();
    }
    
    // 添加光源
    addLightSource(x, y, intensity = 1, color = '#ffffff', type = 'point') {
        const light = {
            id: Date.now() + Math.random(),
            x, y,
            intensity,
            color,
            type, // 'point', 'directional', 'spot'
            attenuation: 0.1
        };
        
        this.lightSources.push(light);
        return light.id;
    }
    
    // 移除光源
    removeLightSource(id) {
        const index = this.lightSources.findIndex(light => light.id === id);
        if (index > -1) {
            this.lightSources.splice(index, 1);
        }
    }
    
    // 计算阴影
    calculateShadow(element, shadowReceiver = null) {
        if (!this.shadowSettings.enabled) return null;
        
        const bounds = element.getBoundingBox();
        const shadows = [];
        
        // 为每个光源计算阴影
        this.lightSources.forEach(light => {
            const shadow = this.calculateShadowFromLight(bounds, light, shadowReceiver);
            if (shadow) {
                shadows.push(shadow);
            }
        });
        
        // 合并多个阴影
        return this.mergeShadows(shadows);
    }
    
    // 从单个光源计算阴影
    calculateShadowFromLight(bounds, light, receiver) {
        const lightDirection = this.getLightDirection(bounds, light);
        const shadowLength = this.calculateShadowLength(bounds, light);
        
        // 计算阴影形状
        const shadowShape = this.projectShadow(bounds, lightDirection, shadowLength);
        
        // 添加模糊和不规则性
        const blurredShadow = this.addShadowBlur(shadowShape);
        const irregularShadow = this.addShadowIrregularity(blurredShadow);
        
        return {
            shape: irregularShadow,
            opacity: this.calculateShadowOpacity(bounds, light),
            color: this.shadowSettings.color
        };
    }
    
    // 获取光照方向
    getLightDirection(bounds, light) {
        const centerX = bounds.x + bounds.width / 2;
        const centerY = bounds.y + bounds.height / 2;
        
        if (light.type === 'directional') {
            return { x: 0, y: 1 }; // 向下的平行光
        }
        
        // 点光源
        const dx = centerX - light.x;
        const dy = centerY - light.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        
        return {
            x: dx / length,
            y: dy / length
        };
    }
    
    // 计算阴影长度
    calculateShadowLength(bounds, light) {
        const distance = Math.sqrt(
            Math.pow(bounds.x + bounds.width / 2 - light.x, 2) +
            Math.pow(bounds.y + bounds.height / 2 - light.y, 2)
        );
        
        const height = Math.max(bounds.width, bounds.height) * 0.1; // 假设高度
        return height * distance / (light.intensity * 100);
    }
    
    // 投射阴影
    projectShadow(bounds, direction, length) {
        const points = [
            { x: bounds.x, y: bounds.y },
            { x: bounds.x + bounds.width, y: bounds.y },
            { x: bounds.x + bounds.width, y: bounds.y + bounds.height },
            { x: bounds.x, y: bounds.y + bounds.height }
        ];
        
        // 投射每个顶点
        const shadowPoints = points.map(point => ({
            x: point.x + direction.x * length,
            y: point.y + direction.y * length
        }));
        
        // 组合原始形状和投射形状
        return [...points, ...shadowPoints.reverse()];
    }
    
    // 添加阴影模糊
    addShadowBlur(shadowShape) {
        const blurRadius = this.shadowSettings.blur;
        if (blurRadius === 0) return shadowShape;
        
        return shadowShape.map(point => ({
            x: point.x + this.noiseGenerator.rng.randomGaussian(0, blurRadius * 0.3),
            y: point.y + this.noiseGenerator.rng.randomGaussian(0, blurRadius * 0.3)
        }));
    }
    
    // 添加阴影不规则性
    addShadowIrregularity(shadowShape) {
        return shadowShape.map((point, index) => {
            const irregularity = 0.5; // 不规则程度
            const noise = this.noiseGenerator.perlinNoise(
                point.x * 0.01, 
                point.y * 0.01, 
                0.1, 
                irregularity
            );
            
            return {
                x: point.x + noise,
                y: point.y + noise
            };
        });
    }
    
    // 计算阴影透明度
    calculateShadowOpacity(bounds, light) {
        const distance = Math.sqrt(
            Math.pow(bounds.x + bounds.width / 2 - light.x, 2) +
            Math.pow(bounds.y + bounds.height / 2 - light.y, 2)
        );
        
        const baseOpacity = this.shadowSettings.opacity;
        const attenuatedOpacity = baseOpacity / (1 + light.attenuation * distance * 0.001);
        
        return Math.max(0.1, attenuatedOpacity);
    }
    
    // 合并多个阴影
    mergeShadows(shadows) {
        if (shadows.length === 0) return null;
        if (shadows.length === 1) return shadows[0];
        
        // 简化实现：使用第一个阴影的形状，合并透明度
        const mergedShadow = { ...shadows[0] };
        mergedShadow.opacity = shadows.reduce((acc, shadow) => {
            return Math.min(1, acc + shadow.opacity * 0.5);
        }, 0);
        
        return mergedShadow;
    }
    
    // 计算表面光照
    calculateSurfaceLighting(element, surface = 'top') {
        const bounds = element.getBoundingBox();
        const lighting = {
            diffuse: 0,
            specular: 0,
            ambient: this.ambientLight
        };
        
        this.lightSources.forEach(light => {
            const lightContribution = this.calculateLightContribution(bounds, light, surface);
            lighting.diffuse += lightContribution.diffuse;
            lighting.specular += lightContribution.specular;
        });
        
        // 归一化
        lighting.diffuse = Math.min(1, lighting.diffuse);
        lighting.specular = Math.min(1, lighting.specular);
        
        return lighting;
    }
    
    // 计算单个光源贡献
    calculateLightContribution(bounds, light, surface) {
        const centerX = bounds.x + bounds.width / 2;
        const centerY = bounds.y + bounds.height / 2;
        
        // 光照向量
        const lightVector = {
            x: light.x - centerX,
            y: light.y - centerY,
            z: 100 // 假设光源高度
        };
        
        const lightDistance = Math.sqrt(
            lightVector.x * lightVector.x + 
            lightVector.y * lightVector.y + 
            lightVector.z * lightVector.z
        );
        
        // 归一化
        lightVector.x /= lightDistance;
        lightVector.y /= lightDistance;
        lightVector.z /= lightDistance;
        
        // 表面法向量（假设垂直向上）
        const normal = { x: 0, y: 0, z: 1 };
        
        // 漫反射（Lambertian）
        const dotProduct = Math.max(0, 
            normal.x * lightVector.x + 
            normal.y * lightVector.y + 
            normal.z * lightVector.z
        );
        
        // 距离衰减
        const attenuation = 1 / (1 + light.attenuation * lightDistance * lightDistance);
        
        return {
            diffuse: dotProduct * light.intensity * attenuation,
            specular: 0 // 简化实现暂不考虑镜面反射
        };
    }
    
    // 渲染阴影
    renderShadow(ctx, shadow) {
        if (!shadow) return;
        
        ctx.save();
        
        // 设置阴影样式
        ctx.fillStyle = shadow.color;
        ctx.globalAlpha = shadow.opacity;
        
        // 绘制阴影形状
        ctx.beginPath();
        shadow.shape.forEach((point, index) => {
            if (index === 0) {
                ctx.moveTo(point.x, point.y);
            } else {
                ctx.lineTo(point.x, point.y);
            }
        });
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
    }
    
    // 应用光照到颜色
    applyLightingToColor(baseColor, lighting) {
        const color = this.parseColor(baseColor);
        
        // 计算最终亮度
        const totalLighting = lighting.ambient + lighting.diffuse + lighting.specular;
        const factor = Math.min(1, totalLighting);
        
        return {
            r: Math.round(color.r * factor),
            g: Math.round(color.g * factor),
            b: Math.round(color.b * factor),
            a: color.a
        };
    }
    
    // 解析颜色
    parseColor(color) {
        // 简化实现，支持hex和rgb
        if (color.startsWith('#')) {
            const hex = color.substring(1);
            return {
                r: parseInt(hex.substr(0, 2), 16),
                g: parseInt(hex.substr(2, 2), 16),
                b: parseInt(hex.substr(4, 2), 16),
                a: 1
            };
        }
        
        // 默认黑色
        return { r: 0, g: 0, b: 0, a: 1 };
    }
    
    // 颜色转字符串
    colorToString(color) {
        return `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;
    }
}
```

### 8.3.2 纸张纹理和材质效果

实现各种纸张纹理和材质效果。

```javascript
// 纸张纹理生成器
class PaperTextureGenerator {
    constructor() {
        this.textures = new Map();
        this.noiseGenerator = new NoiseGenerator();
        this.createBuiltinTextures();
    }
    
    createBuiltinTextures() {
        // 创建基础纸张纹理
        this.registerTexture('paper', this.generatePaperTexture.bind(this));
        this.registerTexture('canvas', this.generateCanvasTexture.bind(this));
        this.registerTexture('watercolor', this.generateWatercolorTexture.bind(this));
        this.registerTexture('kraft', this.generateKraftTexture.bind(this));
        this.registerTexture('parchment', this.generateParchmentTexture.bind(this));
        this.registerTexture('rough', this.generateRoughTexture.bind(this));
    }
    
    registerTexture(name, generator) {
        this.textures.set(name, generator);
    }
    
    // 生成纸张纹理
    generatePaperTexture(width, height, options = {}) {
        const {
            roughness = 0.3,
            grainSize = 2,
            baseColor = '#ffffff',
            variation = 0.1
        } = options;
        
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        
        // 基础颜色
        ctx.fillStyle = baseColor;
        ctx.fillRect(0, 0, width, height);
        
        // 获取图像数据
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        // 添加纸张纹理
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const index = (y * width + x) * 4;
                
                // 生成噪声
                const noise = this.noiseGenerator.fbm(
                    x / grainSize, 
                    y / grainSize, 
                    4, 2.0, 0.5
                );
                
                // 应用纹理变化
                const factor = 1 + noise * variation * roughness;
                
                data[index] = Math.min(255, data[index] * factor);     // R
                data[index + 1] = Math.min(255, data[index + 1] * factor); // G
                data[index + 2] = Math.min(255, data[index + 2] * factor); // B
                // Alpha保持不变
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
        return canvas;
    }
    
    // 生成画布纹理
    generateCanvasTexture(width, height, options = {}) {
        const {
            weaveStrength = 0.5,
            threadSize = 3,
            baseColor = '#f8f8f0'
        } = options;
        
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        
        // 基础颜色
        ctx.fillStyle = baseColor;
        ctx.fillRect(0, 0, width, height);
        
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        // 添加编织纹理
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const index = (y * width + x) * 4;
                
                // 计算编织模式
                const warpPhase = Math.sin(x * Math.PI / threadSize);
                const weftPhase = Math.sin(y * Math.PI / threadSize);
                const weave = (warpPhase * weftPhase + 1) / 2;
                
                // 添加噪声
                const noise = this.noiseGenerator.perlinNoise(x * 0.1, y * 0.1);
                
                const factor = 1 - weaveStrength * (weave * 0.3 + noise * 0.1);
                
                data[index] *= factor;
                data[index + 1] *= factor;
                data[index + 2] *= factor;
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
        return canvas;
    }
    
    // 生成水彩纸纹理
    generateWatercolorTexture(width, height, options = {}) {
        const {
            absorption = 0.7,
            fiber = 0.4,
            baseColor = '#fafafa'
        } = options;
        
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = baseColor;
        ctx.fillRect(0, 0, width, height);
        
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        // 添加纤维纹理
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const index = (y * width + x) * 4;
                
                // 多层噪声
                const noise1 = this.noiseGenerator.perlinNoise(x * 0.05, y * 0.05);
                const noise2 = this.noiseGenerator.perlinNoise(x * 0.2, y * 0.2);
                const noise3 = this.noiseGenerator.cellularNoise(x, y, 0.01);
                
                const totalNoise = noise1 * 0.5 + noise2 * 0.3 + noise3 * 0.2;
                const factor = 1 + totalNoise * fiber * absorption;
                
                data[index] = Math.max(0, Math.min(255, data[index] * factor));
                data[index + 1] = Math.max(0, Math.min(255, data[index + 1] * factor));
                data[index + 2] = Math.max(0, Math.min(255, data[index + 2] * factor));
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
        return canvas;
    }
    
    // 生成牛皮纸纹理
    generateKraftTexture(width, height, options = {}) {
        const {
            fiber = 0.8,
            baseColor = '#d4b896'
        } = options;
        
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = baseColor;
        ctx.fillRect(0, 0, width, height);
        
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        // 添加纤维和斑点
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const index = (y * width + x) * 4;
                
                // 纤维纹理
                const fiberNoise = this.noiseGenerator.ridgedFbm(x * 0.01, y * 0.01, 3);
                
                // 污点和不均匀性
                const spotNoise = this.noiseGenerator.cellularNoise(x, y, 0.005);
                
                const factor = 1 + (fiberNoise * 0.4 + spotNoise * 0.3) * fiber;
                
                data[index] *= factor;
                data[index + 1] *= factor;
                data[index + 2] *= factor;
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
        return canvas;
    }
    
    // 生成羊皮纸纹理
    generateParchmentTexture(width, height, options = {}) {
        const {
            aging = 0.6,
            stains = 0.3,
            baseColor = '#f4f1e8'
        } = options;
        
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = baseColor;
        ctx.fillRect(0, 0, width, height);
        
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        // 添加老化效果
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const index = (y * width + x) * 4;
                
                // 老化噪声
                const ageNoise = this.noiseGenerator.turbulence(x * 0.01, y * 0.01, 32);
                
                // 污渍
                const stainNoise = this.noiseGenerator.cellularNoise(x, y, 0.003);
                
                // 边缘褪色效果
                const centerX = width / 2;
                const centerY = height / 2;
                const distanceFromCenter = Math.sqrt(
                    Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2)
                );
                const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY);
                const fadeEffect = 1 - (distanceFromCenter / maxDistance) * 0.2;
                
                const agingFactor = 1 - aging * (ageNoise * 0.4 + stainNoise * stains * 0.6);
                const totalFactor = agingFactor * fadeEffect;
                
                data[index] = Math.max(100, data[index] * totalFactor);
                data[index + 1] = Math.max(90, data[index + 1] * totalFactor);
                data[index + 2] = Math.max(70, data[index + 2] * totalFactor);
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
        return canvas;
    }
    
    // 生成粗糙纹理
    generateRoughTexture(width, height, options = {}) {
        const {
            roughness = 1.0,
            grainSize = 1,
            baseColor = '#ffffff'
        } = options;
        
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = baseColor;
        ctx.fillRect(0, 0, width, height);
        
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        // 添加粗糙纹理
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const index = (y * width + x) * 4;
                
                // 多尺度噪声
                const noise = this.noiseGenerator.fbm(
                    x / grainSize, 
                    y / grainSize, 
                    6, 2.0, 0.6
                );
                
                const factor = 1 + noise * roughness * 0.3;
                
                data[index] = Math.max(0, Math.min(255, data[index] * factor));
                data[index + 1] = Math.max(0, Math.min(255, data[index + 1] * factor));
                data[index + 2] = Math.max(0, Math.min(255, data[index + 2] * factor));
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
        return canvas;
    }
    
    // 获取纹理
    getTexture(name, width, height, options = {}) {
        const generator = this.textures.get(name);
        if (!generator) {
            console.warn(`Texture '${name}' not found`);
            return this.generatePaperTexture(width, height, options);
        }
        
        return generator(width, height, options);
    }
    
    // 应用纹理到canvas
    applyTexture(ctx, textureName, options = {}) {
        const canvas = ctx.canvas;
        const texture = this.getTexture(textureName, canvas.width, canvas.height, options);
        
        // 使用multiply混合模式应用纹理
        ctx.save();
        ctx.globalCompositeOperation = 'multiply';
        ctx.globalAlpha = options.opacity || 0.5;
        ctx.drawImage(texture, 0, 0);
        ctx.restore();
    }
    
    // 创建无缝平铺纹理
    createSeamlessTexture(name, tileSize, options = {}) {
        const texture = this.getTexture(name, tileSize, tileSize, options);
        
        // 创建pattern
        const patternCanvas = document.createElement('canvas');
        patternCanvas.width = tileSize;
        patternCanvas.height = tileSize;
        const patternCtx = patternCanvas.getContext('2d');
        
        patternCtx.drawImage(texture, 0, 0);
        
        return patternCanvas;
    }
}
```

## 总结

本章详细介绍了手绘风格与视觉效果的实现，包括：

1. **手绘风格理论** - 深度分析手绘特征，实现风格参数生成
2. **噪声算法系统** - 实现Perlin、分数布朗运动、湍流等多种噪声
3. **RoughJS集成** - 深度集成和扩展RoughJS功能
4. **填充样式系统** - 实现hachure、点填充、星形填充等多种样式
5. **阴影光照系统** - 完整的3D光照模型和阴影投射
6. **纸张纹理生成** - 多种逼真的纸张和材质纹理

这套手绘风格系统为构建具有艺术感的绘图应用提供了强大的视觉效果基础。在下一章中，我们将学习如何构建协作系统。