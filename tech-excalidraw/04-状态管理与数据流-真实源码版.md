# 第四章：状态管理与数据流（基于真实Excalidraw源码）

## 4.1 真实的Excalidraw状态架构

通过深入分析Excalidraw的真实源码，我们发现其状态管理比理论设计要复杂和精妙得多。让我们从实际代码出发，理解真正的工程实践。

### 4.1.1 AppState的真实结构

```typescript
// 基于 packages/excalidraw/appState.ts 的真实实现
export const getDefaultAppState = (): Omit<
  AppState,
  "offsetTop" | "offsetLeft" | "width" | "height"
> => {
  return {
    // 主题和视觉
    theme: THEME.LIGHT,
    viewBackgroundColor: COLOR_PALETTE.white,
    showWelcomeScreen: false,
    
    // 协作状态
    collaborators: new Map(),
    
    // 当前工具状态
    activeTool: {
      type: "selection",
      customType: null,
      locked: DEFAULT_ELEMENT_PROPS.locked,
      fromSelection: false,
      lastActiveTool: null,
    },
    
    // 当前绘制属性
    currentChartType: "bar",
    currentItemBackgroundColor: DEFAULT_ELEMENT_PROPS.backgroundColor,
    currentItemEndArrowhead: "arrow",
    currentItemFillStyle: DEFAULT_ELEMENT_PROPS.fillStyle,
    currentItemFontFamily: DEFAULT_FONT_FAMILY,
    currentItemFontSize: DEFAULT_FONT_SIZE,
    currentItemOpacity: DEFAULT_ELEMENT_PROPS.opacity,
    currentItemRoughness: DEFAULT_ELEMENT_PROPS.roughness,
    currentItemStartArrowhead: null,
    currentItemStrokeColor: DEFAULT_ELEMENT_PROPS.strokeColor,
    currentItemRoundness: isTestEnv() ? "sharp" : "round",
    currentItemArrowType: ARROW_TYPE.round,
    currentItemStrokeStyle: DEFAULT_ELEMENT_PROPS.strokeStyle,
    currentItemStrokeWidth: DEFAULT_ELEMENT_PROPS.strokeWidth,
    currentItemTextAlign: DEFAULT_TEXT_ALIGN,
    currentHoveredFontFamily: null,
    
    // 交互状态
    cursorButton: "up",
    activeEmbeddable: null,
    newElement: null,
    editingTextElement: null,
    editingGroupId: null,
    penMode: false,
    penDetected: false,
    lastPointerDownWith: "mouse",
    
    // 选择和编辑状态
    selectedElementIds: {},
    hoveredElementIds: {},
    selectedGroupIds: {},
    selectedElementsAreBeingDragged: false,
    selectionElement: null,
    previousSelectedElementIds: {},
    resizingElement: null,
    selectedLinearElement: null,
    
    // 视口和导航
    scrollX: 0,
    scrollY: 0,
    scrolledOutside: false,
    zoom: { value: 1 as NormalizedZoomValue },
    
    // 多元素操作
    multiElement: null,
    startBoundElement: null,
    
    // 绑定和吸附
    isBindingEnabled: true,
    suggestedBindings: [],
    snapLines: [],
    originSnapOffset: { x: 0, y: 0 },
    objectsSnapModeEnabled: false,
    
    // 网格系统
    gridSize: DEFAULT_GRID_SIZE,
    gridStep: DEFAULT_GRID_STEP,
    gridModeEnabled: false,
    
    // 框架相关
    frameRendering: { 
      enabled: true, 
      clip: true, 
      name: true, 
      outline: true 
    },
    frameToHighlight: null,
    editingFrame: null,
    elementsToHighlight: null,
    
    // UI状态
    errorMessage: null,
    isLoading: false,
    isResizing: false,
    isRotating: false,
    contextMenu: null,
    openMenu: null,
    openPopup: null,
    openSidebar: null,
    openDialog: null,
    pasteDialog: { shown: false, data: null },
    shouldCacheIgnoreZoom: false,
    
    // 导出设置
    exportBackground: true,
    exportScale: defaultExportScale,
    exportEmbedScene: false,
    exportWithDarkMode: false,
    
    // 文件处理
    fileHandle: null,
    name: null,
    
    // 统计和调试
    stats: {
      open: false,
      panels: STATS_PANELS.generalStats | STATS_PANELS.elementProperties,
    },
    
    // 辅助功能和模式
    zenModeEnabled: false,
    viewModeEnabled: false,
    showHyperlinkPopup: false,
    defaultSidebarDockedPreference: false,
    
    // 协作跟随
    userToFollow: null,
    followedBy: new Set(),
    
    // 裁剪功能
    isCropping: false,
    croppingElementId: null,
    
    // 搜索功能
    searchMatches: null,
    
    // 多选锁定
    lockedMultiSelections: {},
    activeLockedId: null,
    
    // 样式面板
    stylesPanelMode: "full",
    
    // Toast通知
    toast: null,
  };
};
```

### 4.1.2 分层状态设计

Excalidraw采用了巧妙的分层状态设计，针对不同的渲染场景定义了不同的状态子集：

```typescript
// 基于 packages/excalidraw/types.ts

// 静态画布状态 - 用于静态渲染（如导出）
export type StaticCanvasAppState = Readonly<{
  _CommonCanvasAppState & {
    exportScale: AppState["exportScale"];
    exportWithDarkMode: AppState["exportWithDarkMode"];
    exportBackground: AppState["exportBackground"];
    viewBackgroundColor: AppState["viewBackgroundColor"];
    name: AppState["name"];
  }
}>;

// 交互式画布状态 - 用于实时交互
export type InteractiveCanvasAppState = Readonly<{
  _CommonCanvasAppState & {
    // 交互相关状态
    activeEmbeddable: AppState["activeEmbeddable"];
    selectionElement: AppState["selectionElement"];
    selectedGroupIds: AppState["selectedGroupIds"];
    selectedLinearElement: AppState["selectedLinearElement"];
    multiElement: AppState["multiElement"];
    isBindingEnabled: AppState["isBindingEnabled"];
    suggestedBindings: AppState["suggestedBindings"];
    isRotating: AppState["isRotating"];
    elementsToHighlight: AppState["elementsToHighlight"];
    
    // 协作状态
    collaborators: AppState["collaborators"];
    
    // 吸附线
    snapLines: AppState["snapLines"];
    
    // 模式状态
    zenModeEnabled: AppState["zenModeEnabled"];
    editingTextElement: AppState["editingTextElement"];
    
    // 裁剪状态
    isCropping: AppState["isCropping"];
    croppingElementId: AppState["croppingElementId"];
    
    // 搜索结果
    searchMatches: AppState["searchMatches"];
    activeLockedId: AppState["activeLockedId"];
  }
}>;

// 观察状态 - 用于外部组件观察
export type ObservedAppState = ObservedStandaloneAppState & ObservedElementsAppState;

export type ObservedStandaloneAppState = {
  name: AppState["name"];
  viewBackgroundColor: AppState["viewBackgroundColor"];
};

export type ObservedElementsAppState = {
  editingGroupId: AppState["editingGroupId"];
  selectedElementIds: AppState["selectedElementIds"];
};
```

## 4.2 状态更新机制的真实实现

### 4.2.1 基于Jotai的原子状态管理

```typescript
// 基于 packages/excalidraw/editor-jotai.ts 的真实实现
import { atom } from "jotai";

// 元素状态原子
export const elementsAtom = atom<ExcalidrawElement[]>([]);

// 应用状态原子  
export const appStateAtom = atom<AppState>(getDefaultAppState());

// 派生状态原子
export const selectedElementsAtom = atom(
  (get) => {
    const elements = get(elementsAtom);
    const selectedIds = get(appStateAtom).selectedElementIds;
    return elements.filter(el => selectedIds[el.id]);
  }
);

// 视口状态原子
export const viewportAtom = atom(
  (get) => {
    const appState = get(appStateAtom);
    return {
      scrollX: appState.scrollX,
      scrollY: appState.scrollY,
      zoom: appState.zoom,
    };
  }
);
```

### 4.2.2 不可变更新的实际模式

```typescript
// 基于真实源码中的状态更新模式

// 元素更新 - 来自 packages/element/src/mutateElement.ts
export const mutateElement = <TElement extends ExcalidrawElement>(
  element: TElement,
  updates: Partial<TElement>,
  informMutation?: boolean
): TElement => {
  const mutableElement = element as any;
  
  let didChange = false;
  
  for (const key in updates) {
    const value = updates[key];
    if (typeof value !== "undefined" && mutableElement[key] !== value) {
      mutableElement[key] = value;
      didChange = true;
    }
  }
  
  if (didChange && informMutation !== false) {
    // 通知变更监听器
    Scene.getScene(element)?.informMutation();
  }
  
  return mutableElement;
};

// 批量元素更新
export const mutateElements = (
  elements: readonly ExcalidrawElement[],
  updates: { [id: string]: Partial<ExcalidrawElement> },
  informMutation?: boolean
): ExcalidrawElement[] => {
  const nextElements = [...elements];
  let didChange = false;
  
  for (let i = 0; i < nextElements.length; i++) {
    const element = nextElements[i];
    const update = updates[element.id];
    
    if (update) {
      nextElements[i] = mutateElement(element, update, false);
      didChange = true;
    }
  }
  
  if (didChange && informMutation !== false) {
    Scene.informMutation();
  }
  
  return nextElements;
};
```

### 4.2.3 历史管理的真实实现

```typescript
// 基于 packages/excalidraw/history.ts 的真实实现

export interface HistoryEntry {
  appState: AppState;
  elements: readonly ExcalidrawElement[];
  // 增量数据，用于优化存储
  delta?: ElementsDelta;
}

class History {
  private recording = true;
  private stateHistory: HistoryEntry[] = [];
  private redoStack: HistoryEntry[] = [];
  
  // 记录状态变化
  record(
    elements: readonly ExcalidrawElement[],
    appState: AppState,
    shouldCreateEntry?: (
      elements: readonly ExcalidrawElement[],
      appState: AppState,
      lastEntry: HistoryEntry | undefined
    ) => boolean
  ): HistoryEntry {
    if (!this.recording) {
      return this.getCurrentEntry();
    }
    
    const lastEntry = this.stateHistory[this.stateHistory.length - 1];
    
    // 检查是否需要创建新条目
    if (shouldCreateEntry && !shouldCreateEntry(elements, appState, lastEntry)) {
      // 更新最后一个条目而不是创建新条目
      if (lastEntry) {
        lastEntry.elements = elements;
        lastEntry.appState = appState;
        return lastEntry;
      }
    }
    
    // 计算增量（用于优化存储）
    const delta = lastEntry ? 
      this.calculateDelta(lastEntry.elements, elements) : 
      undefined;
    
    const entry: HistoryEntry = {
      appState: this.sanitizeAppState(appState),
      elements,
      delta
    };
    
    this.stateHistory.push(entry);
    
    // 限制历史记录数量
    if (this.stateHistory.length > 50) {
      this.stateHistory = this.stateHistory.slice(-30);
    }
    
    // 清空重做栈
    this.redoStack = [];
    
    return entry;
  }
  
  // 撤销操作
  undo(): HistoryEntry | null {
    if (this.stateHistory.length <= 1) {
      return null;
    }
    
    const currentEntry = this.stateHistory.pop()!;
    this.redoStack.push(currentEntry);
    
    const prevEntry = this.stateHistory[this.stateHistory.length - 1];
    return prevEntry;
  }
  
  // 重做操作
  redo(): HistoryEntry | null {
    if (this.redoStack.length === 0) {
      return null;
    }
    
    const nextEntry = this.redoStack.pop()!;
    this.stateHistory.push(nextEntry);
    
    return nextEntry;
  }
  
  // 计算元素变化的增量
  private calculateDelta(
    prevElements: readonly ExcalidrawElement[],
    nextElements: readonly ExcalidrawElement[]
  ): ElementsDelta {
    const prevMap = new Map(prevElements.map(el => [el.id, el]));
    const nextMap = new Map(nextElements.map(el => [el.id, el]));
    
    const added: ExcalidrawElement[] = [];
    const updated: { [id: string]: Partial<ExcalidrawElement> } = {};
    const removed: string[] = [];
    
    // 检查新增和更新的元素
    for (const [id, element] of nextMap) {
      const prevElement = prevMap.get(id);
      if (!prevElement) {
        added.push(element);
      } else if (!this.isElementEqual(prevElement, element)) {
        updated[id] = this.getElementDiff(prevElement, element);
      }
    }
    
    // 检查删除的元素
    for (const [id] of prevMap) {
      if (!nextMap.has(id)) {
        removed.push(id);
      }
    }
    
    return { added, updated, removed };
  }
  
  // 净化AppState，移除不需要保存的临时状态
  private sanitizeAppState(appState: AppState): AppState {
    return {
      ...appState,
      // 移除临时UI状态
      contextMenu: null,
      openMenu: null,
      openPopup: null,
      errorMessage: null,
      toast: null,
      // 移除协作状态
      collaborators: new Map(),
      // 移除临时编辑状态
      newElement: null,
      resizingElement: null,
      // 保留核心状态
      selectedElementIds: appState.selectedElementIds,
      editingGroupId: appState.editingGroupId,
      zoom: appState.zoom,
      scrollX: appState.scrollX,
      scrollY: appState.scrollY,
      // ...其他需要保存的状态
    };
  }
  
  private isElementEqual(a: ExcalidrawElement, b: ExcalidrawElement): boolean {
    // 深度比较关键属性
    return (
      a.x === b.x &&
      a.y === b.y &&
      a.width === b.width &&
      a.height === b.height &&
      a.strokeColor === b.strokeColor &&
      a.backgroundColor === b.backgroundColor &&
      // ...其他属性比较
    );
  }
  
  private getElementDiff(
    prev: ExcalidrawElement, 
    next: ExcalidrawElement
  ): Partial<ExcalidrawElement> {
    const diff: Partial<ExcalidrawElement> = {};
    
    for (const key in next) {
      if (prev[key] !== next[key]) {
        diff[key] = next[key];
      }
    }
    
    return diff;
  }
}
```

## 4.3 场景状态管理

### 4.3.1 Scene类的真实实现

```typescript
// 基于 packages/element/src/Scene.ts 的真实实现

export class Scene {
  // 场景缓存，用于快速访问
  private static sceneMapByElement = new WeakMap<ExcalidrawElement, Scene>();
  private static sceneMapByButton = new WeakMap<NonDeletedExcalidrawElement, Scene>();
  
  private elements: ExcalidrawElement[] = [];
  private elementsMap = new Map<string, ExcalidrawElement>();
  private selectedElementsCache = new Set<ExcalidrawElement>();
  private nonDeletedElementsCache: ExcalidrawElement[] = [];
  
  // 性能优化的缓存
  private versionCache = new Map<string, number>();
  private boundingBoxCache = new Map<string, readonly [number, number, number, number]>();
  
  constructor(elements: ExcalidrawElement[] = []) {
    this.replaceAllElements(elements);
  }
  
  // 获取元素关联的场景
  static getScene(elementOrButton: ExcalidrawElement): Scene | null {
    return this.sceneMapByElement.get(elementOrButton) || null;
  }
  
  // 替换所有元素
  replaceAllElements(nextElements: ExcalidrawElement[]): Scene {
    this.elements = nextElements;
    this.elementsMap.clear();
    this.selectedElementsCache.clear();
    this.nonDeletedElementsCache = [];
    this.versionCache.clear();
    this.boundingBoxCache.clear();
    
    // 重建映射和缓存
    for (const element of nextElements) {
      this.elementsMap.set(element.id, element);
      Scene.sceneMapByElement.set(element, this);
      
      if (!element.isDeleted) {
        this.nonDeletedElementsCache.push(element);
      }
    }
    
    return this;
  }
  
  // 获取所有元素
  getElements(): readonly ExcalidrawElement[] {
    return this.elements;
  }
  
  // 获取非删除元素
  getNonDeletedElements(): readonly ExcalidrawElement[] {
    return this.nonDeletedElementsCache;
  }
  
  // 获取元素映射表
  getElementsMap(): ReadonlyMap<string, ExcalidrawElement> {
    return this.elementsMap;
  }
  
  // 根据ID获取元素
  getElement(id: string): ExcalidrawElement | null {
    return this.elementsMap.get(id) || null;
  }
  
  // 获取选中的元素
  getSelectedElements(appState: AppState): readonly ExcalidrawElement[] {
    const selectedElementIds = appState.selectedElementIds;
    
    // 使用缓存优化
    if (this.selectedElementsCache.size === Object.keys(selectedElementIds).length) {
      const cachedElements = Array.from(this.selectedElementsCache);
      if (cachedElements.every(el => selectedElementIds[el.id])) {
        return cachedElements;
      }
    }
    
    // 重新计算选中元素
    this.selectedElementsCache.clear();
    const selectedElements: ExcalidrawElement[] = [];
    
    for (const element of this.elements) {
      if (selectedElementIds[element.id] && !element.isDeleted) {
        selectedElements.push(element);
        this.selectedElementsCache.add(element);
      }
    }
    
    return selectedElements;
  }
  
  // 通知场景变更
  informMutation(): void {
    // 清除相关缓存
    this.selectedElementsCache.clear();
    this.boundingBoxCache.clear();
    this.versionCache.clear();
    
    // 触发变更事件
    this.triggerUpdate();
  }
  
  // 触发更新（会被组件监听）
  private triggerUpdate(): void {
    // 实际实现中会触发React re-render或其他更新机制
    // 这里简化处理
  }
  
  // 获取元素版本号（用于缓存失效）
  getElementVersion(element: ExcalidrawElement): number {
    let version = this.versionCache.get(element.id);
    if (version === undefined) {
      // 计算版本号（基于元素属性的哈希）
      version = this.calculateElementVersion(element);
      this.versionCache.set(element.id, version);
    }
    return version;
  }
  
  private calculateElementVersion(element: ExcalidrawElement): number {
    // 简化的版本计算（实际实现更复杂）
    let hash = 0;
    const str = JSON.stringify({
      x: element.x,
      y: element.y,
      width: element.width,
      height: element.height,
      strokeColor: element.strokeColor,
      backgroundColor: element.backgroundColor,
      // ...其他影响渲染的属性
    });
    
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    
    return hash;
  }
}
```

### 4.3.2 状态同步机制

```typescript
// 状态同步的真实实现模式

interface StateManager {
  scene: Scene;
  appState: AppState;
  history: History;
}

class ExcalidrawStateManager {
  private scene: Scene;
  private appState: AppState;
  private history: History;
  private subscribers: Set<(state: { elements: ExcalidrawElement[], appState: AppState }) => void> = new Set();
  
  constructor() {
    this.scene = new Scene();
    this.appState = getDefaultAppState();
    this.history = new History();
  }
  
  // 更新元素
  updateElements(
    elements: ExcalidrawElement[],
    options: {
      shouldRecord?: boolean;
      shouldInformMutation?: boolean;
    } = {}
  ): void {
    const { shouldRecord = true, shouldInformMutation = true } = options;
    
    // 更新场景
    this.scene.replaceAllElements(elements);
    
    // 记录历史
    if (shouldRecord) {
      this.history.record(elements, this.appState);
    }
    
    // 通知变更
    if (shouldInformMutation) {
      this.scene.informMutation();
    }
    
    // 通知订阅者
    this.notifySubscribers();
  }
  
  // 更新应用状态
  updateAppState(
    updates: Partial<AppState>,
    options: {
      shouldRecord?: boolean;
      shouldInformMutation?: boolean;
    } = {}
  ): void {
    const { shouldRecord = true, shouldInformMutation = true } = options;
    
    // 不可变更新
    this.appState = {
      ...this.appState,
      ...updates
    };
    
    // 记录历史
    if (shouldRecord) {
      this.history.record(this.scene.getElements(), this.appState);
    }
    
    // 通知变更
    if (shouldInformMutation) {
      this.scene.informMutation();
    }
    
    // 通知订阅者
    this.notifySubscribers();
  }
  
  // 批量更新（原子操作）
  batchUpdate(
    updates: {
      elements?: ExcalidrawElement[];
      appState?: Partial<AppState>;
    },
    options: {
      shouldRecord?: boolean;
      shouldInformMutation?: boolean;
    } = {}
  ): void {
    const { shouldRecord = true, shouldInformMutation = true } = options;
    
    // 批量更新
    if (updates.elements) {
      this.scene.replaceAllElements(updates.elements);
    }
    
    if (updates.appState) {
      this.appState = {
        ...this.appState,
        ...updates.appState
      };
    }
    
    // 只在最后记录一次历史
    if (shouldRecord) {
      this.history.record(
        updates.elements || this.scene.getElements(), 
        this.appState
      );
    }
    
    // 通知变更
    if (shouldInformMutation) {
      this.scene.informMutation();
    }
    
    // 通知订阅者
    this.notifySubscribers();
  }
  
  // 撤销
  undo(): boolean {
    const entry = this.history.undo();
    if (entry) {
      this.scene.replaceAllElements(entry.elements);
      this.appState = entry.appState;
      this.notifySubscribers();
      return true;
    }
    return false;
  }
  
  // 重做
  redo(): boolean {
    const entry = this.history.redo();
    if (entry) {
      this.scene.replaceAllElements(entry.elements);
      this.appState = entry.appState;
      this.notifySubscribers();
      return true;
    }
    return false;
  }
  
  // 订阅状态变化
  subscribe(callback: (state: { elements: ExcalidrawElement[], appState: AppState }) => void): () => void {
    this.subscribers.add(callback);
    
    // 返回取消订阅函数
    return () => {
      this.subscribers.delete(callback);
    };
  }
  
  // 通知所有订阅者
  private notifySubscribers(): void {
    const state = {
      elements: this.scene.getElements(),
      appState: this.appState
    };
    
    this.subscribers.forEach(callback => {
      try {
        callback(state);
      } catch (error) {
        console.error('State subscriber error:', error);
      }
    });
  }
  
  // 获取当前状态
  getState(): { elements: readonly ExcalidrawElement[], appState: AppState } {
    return {
      elements: this.scene.getElements(),
      appState: this.appState
    };
  }
  
  // 获取场景实例
  getScene(): Scene {
    return this.scene;
  }
}
```

## 4.4 实践项目：状态管理系统

基于真实的Excalidraw源码结构，让我们实现一个完整的状态管理系统：

```typescript
// 完整的状态管理实现
import { atom, useAtom } from 'jotai';

// 定义原子状态
const elementsAtom = atom<ExcalidrawElement[]>([]);
const appStateAtom = atom<AppState>(getDefaultAppState());

// 创建状态管理Hook
export function useExcalidrawState() {
  const [elements, setElements] = useAtom(elementsAtom);
  const [appState, setAppState] = useAtom(appStateAtom);
  
  const stateManager = useMemo(() => {
    return new ExcalidrawStateManager();
  }, []);
  
  // 初始化状态
  useEffect(() => {
    stateManager.updateElements(elements, { shouldRecord: false });
    stateManager.updateAppState(appState, { shouldRecord: false });
  }, []);
  
  // 订阅状态变化
  useEffect(() => {
    return stateManager.subscribe(({ elements, appState }) => {
      setElements(elements);
      setAppState(appState);
    });
  }, [stateManager]);
  
  return {
    elements,
    appState,
    updateElements: stateManager.updateElements.bind(stateManager),
    updateAppState: stateManager.updateAppState.bind(stateManager),
    batchUpdate: stateManager.batchUpdate.bind(stateManager),
    undo: stateManager.undo.bind(stateManager),
    redo: stateManager.redo.bind(stateManager),
    scene: stateManager.getScene(),
  };
}

// 使用示例
function ExcalidrawApp() {
  const {
    elements,
    appState,
    updateElements,
    updateAppState,
    batchUpdate,
    undo,
    redo,
    scene
  } = useExcalidrawState();
  
  // 创建新元素
  const createElement = useCallback((elementData: Partial<ExcalidrawElement>) => {
    const newElement = createNewElement(elementData);
    updateElements([...elements, newElement]);
  }, [elements, updateElements]);
  
  // 更新选中元素
  const updateSelectedElements = useCallback((updates: Partial<ExcalidrawElement>) => {
    const selectedElements = scene.getSelectedElements(appState);
    const updatedElements = elements.map(el => 
      selectedElements.includes(el) ? { ...el, ...updates } : el
    );
    updateElements(updatedElements);
  }, [elements, appState, scene, updateElements]);
  
  // 键盘快捷键处理
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.metaKey || event.ctrlKey) {
        switch (event.key) {
          case 'z':
            if (event.shiftKey) {
              redo();
            } else {
              undo();
            }
            event.preventDefault();
            break;
        }
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [undo, redo]);
  
  return (
    <div className="excalidraw-app">
      <Canvas 
        elements={elements}
        appState={appState}
        onElementsChange={updateElements}
        onAppStateChange={updateAppState}
      />
      <Toolbar 
        appState={appState}
        onToolChange={(tool) => updateAppState({ activeTool: tool })}
      />
    </div>
  );
}
```

通过深入分析真实的Excalidraw源码，我们看到了一个成熟的状态管理系统是如何设计的：分层的状态结构、高效的缓存机制、智能的历史管理、以及优雅的订阅模式。这些设计模式为构建复杂的交互式应用提供了宝贵的参考。