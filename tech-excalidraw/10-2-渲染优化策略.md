# 第十章第二节：渲染优化策略

## 10.2.1 脏矩形更新系统

脏矩形（Dirty Rectangle）是图形渲染中最重要的优化技术之一，它只重绘发生变化的区域，而不是整个画布。

### 脏矩形管理器

```typescript
interface DirtyRect {
  x: number;
  y: number;
  width: number;
  height: number;
}

class DirtyRectManager {
  private dirtyRects: DirtyRect[] = [];
  private canvasWidth: number;
  private canvasHeight: number;
  private mergeThreshold = 0.3; // 合并阈值：重叠30%以上时合并
  
  constructor(canvasWidth: number, canvasHeight: number) {
    this.canvasWidth = canvasWidth;
    this.canvasHeight = canvasHeight;
  }
  
  // 添加脏矩形
  addDirtyRect(rect: DirtyRect): void {
    // 确保矩形在画布范围内
    const clampedRect = this.clampToCanvas(rect);
    if (clampedRect.width <= 0 || clampedRect.height <= 0) {
      return;
    }
    
    this.dirtyRects.push(clampedRect);
    this.optimizeDirtyRects();
  }
  
  // 标记元素为脏
  markElementDirty(element: ExcalidrawElement, padding = 5): void {
    const bounds = getElementBounds(element);
    
    this.addDirtyRect({
      x: bounds.x - padding,
      y: bounds.y - padding,
      width: bounds.width + padding * 2,
      height: bounds.height + padding * 2
    });
  }
  
  // 标记区域为脏
  markAreaDirty(x: number, y: number, width: number, height: number): void {
    this.addDirtyRect({ x, y, width, height });
  }
  
  // 标记整个画布为脏
  markAllDirty(): void {
    this.dirtyRects = [{
      x: 0,
      y: 0,
      width: this.canvasWidth,
      height: this.canvasHeight
    }];
  }
  
  // 获取所有脏矩形
  getDirtyRects(): DirtyRect[] {
    return [...this.dirtyRects];
  }
  
  // 清除所有脏矩形
  clearDirtyRects(): void {
    this.dirtyRects = [];
  }
  
  // 检查是否有脏矩形
  hasDirtyRects(): boolean {
    return this.dirtyRects.length > 0;
  }
  
  // 获取脏区域的总面积占比
  getDirtyAreaRatio(): number {
    const totalArea = this.canvasWidth * this.canvasHeight;
    const dirtyArea = this.dirtyRects.reduce((sum, rect) => {
      return sum + rect.width * rect.height;
    }, 0);
    
    return dirtyArea / totalArea;
  }
  
  private clampToCanvas(rect: DirtyRect): DirtyRect {
    const x = Math.max(0, Math.min(rect.x, this.canvasWidth));
    const y = Math.max(0, Math.min(rect.y, this.canvasHeight));
    const maxX = Math.max(x, Math.min(rect.x + rect.width, this.canvasWidth));
    const maxY = Math.max(y, Math.min(rect.y + rect.height, this.canvasHeight));
    
    return {
      x,
      y,
      width: maxX - x,
      height: maxY - y
    };
  }
  
  private optimizeDirtyRects(): void {
    if (this.dirtyRects.length <= 1) return;
    
    // 合并重叠的矩形
    let merged = true;
    while (merged && this.dirtyRects.length > 1) {
      merged = false;
      
      for (let i = 0; i < this.dirtyRects.length - 1; i++) {
        for (let j = i + 1; j < this.dirtyRects.length; j++) {
          const rect1 = this.dirtyRects[i];
          const rect2 = this.dirtyRects[j];
          
          if (this.shouldMergeRects(rect1, rect2)) {
            // 合并矩形
            const mergedRect = this.mergeRects(rect1, rect2);
            this.dirtyRects.splice(j, 1);
            this.dirtyRects.splice(i, 1);
            this.dirtyRects.push(mergedRect);
            merged = true;
            break;
          }
        }
        if (merged) break;
      }
    }
    
    // 如果脏区域占比过高，标记全部重绘
    if (this.getDirtyAreaRatio() > 0.6) {
      this.markAllDirty();
    }
  }
  
  private shouldMergeRects(rect1: DirtyRect, rect2: DirtyRect): boolean {
    const intersection = this.getIntersection(rect1, rect2);
    if (!intersection) return false;
    
    const intersectionArea = intersection.width * intersection.height;
    const rect1Area = rect1.width * rect1.height;
    const rect2Area = rect2.width * rect2.height;
    const minArea = Math.min(rect1Area, rect2Area);
    
    return intersectionArea / minArea >= this.mergeThreshold;
  }
  
  private getIntersection(rect1: DirtyRect, rect2: DirtyRect): DirtyRect | null {
    const x = Math.max(rect1.x, rect2.x);
    const y = Math.max(rect1.y, rect2.y);
    const maxX = Math.min(rect1.x + rect1.width, rect2.x + rect2.width);
    const maxY = Math.min(rect1.y + rect1.height, rect2.y + rect2.height);
    
    if (x >= maxX || y >= maxY) {
      return null;
    }
    
    return {
      x,
      y,
      width: maxX - x,
      height: maxY - y
    };
  }
  
  private mergeRects(rect1: DirtyRect, rect2: DirtyRect): DirtyRect {
    const x = Math.min(rect1.x, rect2.x);
    const y = Math.min(rect1.y, rect2.y);
    const maxX = Math.max(rect1.x + rect1.width, rect2.x + rect2.width);
    const maxY = Math.max(rect1.y + rect1.height, rect2.y + rect2.height);
    
    return {
      x,
      y,
      width: maxX - x,
      height: maxY - y
    };
  }
}
```

## 10.2.2 分层渲染系统

分层渲染将不同类型的内容分别渲染到不同的画布层，减少不必要的重绘。

### 渲染层管理器

```typescript
interface RenderLayer {
  canvas: HTMLCanvasElement;
  ctx: CanvasRenderingContext2D;
  zIndex: number;
  isDirty: boolean;
  isVisible: boolean;
  opacity: number;
}

class LayeredRenderer {
  private layers: Map<string, RenderLayer> = new Map();
  private container: HTMLElement;
  private dirtyManager: DirtyRectManager;
  
  constructor(container: HTMLElement, width: number, height: number) {
    this.container = container;
    this.dirtyManager = new DirtyRectManager(width, height);
    this.initializeLayers(width, height);
  }
  
  private initializeLayers(width: number, height: number): void {
    const layerConfigs = [
      { name: 'background', zIndex: 0, opacity: 1 },
      { name: 'elements', zIndex: 10, opacity: 1 },
      { name: 'selection', zIndex: 20, opacity: 0.8 },
      { name: 'ui', zIndex: 30, opacity: 1 },
      { name: 'cursor', zIndex: 40, opacity: 1 }
    ];
    
    layerConfigs.forEach(config => {
      this.createLayer(config.name, config.zIndex, width, height, config.opacity);
    });
  }
  
  private createLayer(
    name: string, 
    zIndex: number, 
    width: number, 
    height: number,
    opacity: number = 1
  ): RenderLayer {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    canvas.style.position = 'absolute';
    canvas.style.zIndex = zIndex.toString();
    canvas.style.pointerEvents = 'none';
    canvas.style.opacity = opacity.toString();
    
    const ctx = canvas.getContext('2d')!;
    
    const layer: RenderLayer = {
      canvas,
      ctx,
      zIndex,
      isDirty: true,
      isVisible: true,
      opacity
    };
    
    this.layers.set(name, layer);
    this.container.appendChild(canvas);
    
    return layer;
  }
  
  // 获取指定层的上下文
  getLayerContext(layerName: string): CanvasRenderingContext2D | null {
    const layer = this.layers.get(layerName);
    return layer ? layer.ctx : null;
  }
  
  // 标记层为脏
  markLayerDirty(layerName: string, rect?: DirtyRect): void {
    const layer = this.layers.get(layerName);
    if (layer) {
      layer.isDirty = true;
      if (rect) {
        this.dirtyManager.addDirtyRect(rect);
      }
    }
  }
  
  // 清除层
  clearLayer(layerName: string, rect?: DirtyRect): void {
    const layer = this.layers.get(layerName);
    if (!layer) return;
    
    if (rect) {
      layer.ctx.clearRect(rect.x, rect.y, rect.width, rect.height);
    } else {
      layer.ctx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
    }
  }
  
  // 渲染所有脏层
  renderDirtyLayers(): void {
    const dirtyRects = this.dirtyManager.getDirtyRects();
    
    if (dirtyRects.length === 0) return;
    
    // 按z-index顺序渲染
    const sortedLayers = Array.from(this.layers.entries())
      .sort(([, a], [, b]) => a.zIndex - b.zIndex);
    
    for (const [layerName, layer] of sortedLayers) {
      if (layer.isDirty && layer.isVisible) {
        this.renderLayer(layerName, dirtyRects);
        layer.isDirty = false;
      }
    }
    
    this.dirtyManager.clearDirtyRects();
  }
  
  private renderLayer(layerName: string, dirtyRects: DirtyRect[]): void {
    const layer = this.layers.get(layerName)!;
    
    // 只清除和重绘脏矩形区域
    for (const rect of dirtyRects) {
      layer.ctx.save();
      
      // 设置裁剪区域
      layer.ctx.beginPath();
      layer.ctx.rect(rect.x, rect.y, rect.width, rect.height);
      layer.ctx.clip();
      
      // 清除区域
      layer.ctx.clearRect(rect.x, rect.y, rect.width, rect.height);
      
      // 渲染该区域的内容
      this.renderLayerContent(layerName, layer.ctx, rect);
      
      layer.ctx.restore();
    }
  }
  
  private renderLayerContent(
    layerName: string, 
    ctx: CanvasRenderingContext2D, 
    rect: DirtyRect
  ): void {
    // 这里会根据层类型渲染对应内容
    // 实际实现会传入相应的渲染函数
    
    switch (layerName) {
      case 'background':
        this.renderBackground(ctx, rect);
        break;
      case 'elements':
        this.renderElements(ctx, rect);
        break;
      case 'selection':
        this.renderSelection(ctx, rect);
        break;
      case 'ui':
        this.renderUI(ctx, rect);
        break;
      case 'cursor':
        this.renderCursor(ctx, rect);
        break;
    }
  }
  
  // 各层的具体渲染方法（示例）
  private renderBackground(ctx: CanvasRenderingContext2D, rect: DirtyRect): void {
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
    
    // 绘制网格
    this.renderGrid(ctx, rect);
  }
  
  private renderGrid(ctx: CanvasRenderingContext2D, rect: DirtyRect): void {
    const gridSize = 20;
    ctx.strokeStyle = '#f0f0f0';
    ctx.lineWidth = 1;
    
    // 垂直线
    const startX = Math.floor(rect.x / gridSize) * gridSize;
    for (let x = startX; x <= rect.x + rect.width; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, rect.y);
      ctx.lineTo(x, rect.y + rect.height);
      ctx.stroke();
    }
    
    // 水平线
    const startY = Math.floor(rect.y / gridSize) * gridSize;
    for (let y = startY; y <= rect.y + rect.height; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(rect.x, y);
      ctx.lineTo(rect.x + rect.width, y);
      ctx.stroke();
    }
  }
  
  private renderElements(ctx: CanvasRenderingContext2D, rect: DirtyRect): void {
    // 渲染与脏矩形相交的元素
    // 这里需要传入元素列表和渲染器
  }
  
  private renderSelection(ctx: CanvasRenderingContext2D, rect: DirtyRect): void {
    // 渲染选择指示器
  }
  
  private renderUI(ctx: CanvasRenderingContext2D, rect: DirtyRect): void {
    // 渲染UI元素
  }
  
  private renderCursor(ctx: CanvasRenderingContext2D, rect: DirtyRect): void {
    // 渲染光标
  }
  
  // 调整画布大小
  resizeLayers(width: number, height: number): void {
    for (const layer of this.layers.values()) {
      layer.canvas.width = width;
      layer.canvas.height = height;
      layer.isDirty = true;
    }
    
    this.dirtyManager = new DirtyRectManager(width, height);
    this.dirtyManager.markAllDirty();
  }
  
  // 显示/隐藏层
  setLayerVisibility(layerName: string, visible: boolean): void {
    const layer = this.layers.get(layerName);
    if (layer) {
      layer.isVisible = visible;
      layer.canvas.style.display = visible ? 'block' : 'none';
    }
  }
  
  // 设置层透明度
  setLayerOpacity(layerName: string, opacity: number): void {
    const layer = this.layers.get(layerName);
    if (layer) {
      layer.opacity = opacity;
      layer.canvas.style.opacity = opacity.toString();
    }
  }
}
```

## 10.2.3 批量渲染优化

批量渲染通过将相似的渲染操作组合在一起来减少上下文切换的开销。

### 渲染批次管理器

```typescript
interface RenderBatch {
  type: 'fill' | 'stroke' | 'text' | 'image';
  style: any;
  operations: Array<{
    element: ExcalidrawElement;
    renderData: any;
  }>;
}

class BatchRenderer {
  private batches: Map<string, RenderBatch> = new Map();
  private ctx: CanvasRenderingContext2D;
  
  constructor(ctx: CanvasRenderingContext2D) {
    this.ctx = ctx;
  }
  
  // 添加元素到批次
  addToBatch(element: ExcalidrawElement, renderData: any): void {
    const batchKey = this.getBatchKey(element);
    
    let batch = this.batches.get(batchKey);
    if (!batch) {
      batch = {
        type: this.getRenderType(element),
        style: this.getElementStyle(element),
        operations: []
      };
      this.batches.set(batchKey, batch);
    }
    
    batch.operations.push({ element, renderData });
  }
  
  // 执行所有批次
  flushBatches(): void {
    // 按类型顺序执行批次
    const typeOrder = ['fill', 'stroke', 'text', 'image'];
    
    for (const type of typeOrder) {
      for (const [key, batch] of this.batches) {
        if (batch.type === type) {
          this.executeBatch(batch);
        }
      }
    }
    
    this.clearBatches();
  }
  
  private getBatchKey(element: ExcalidrawElement): string {
    const type = this.getRenderType(element);
    const style = this.getElementStyle(element);
    
    // 创建基于样式的批次键
    return `${type}-${JSON.stringify(style)}`;
  }
  
  private getRenderType(element: ExcalidrawElement): 'fill' | 'stroke' | 'text' | 'image' {
    if (element.type === 'text') return 'text';
    if (element.type === 'image') return 'image';
    if (element.backgroundColor && element.backgroundColor !== 'transparent') return 'fill';
    return 'stroke';
  }
  
  private getElementStyle(element: ExcalidrawElement): any {
    return {
      strokeColor: element.strokeColor,
      backgroundColor: element.backgroundColor,
      strokeWidth: element.strokeWidth,
      strokeStyle: element.strokeStyle,
      fillStyle: element.fillStyle,
      opacity: element.opacity
    };
  }
  
  private executeBatch(batch: RenderBatch): void {
    this.ctx.save();
    
    // 设置批次样式
    this.applyBatchStyle(batch.style);
    
    // 执行所有操作
    switch (batch.type) {
      case 'fill':
        this.executeFillBatch(batch);
        break;
      case 'stroke':
        this.executeStrokeBatch(batch);
        break;
      case 'text':
        this.executeTextBatch(batch);
        break;
      case 'image':
        this.executeImageBatch(batch);
        break;
    }
    
    this.ctx.restore();
  }
  
  private applyBatchStyle(style: any): void {
    if (style.strokeColor) {
      this.ctx.strokeStyle = style.strokeColor;
    }
    if (style.backgroundColor) {
      this.ctx.fillStyle = style.backgroundColor;
    }
    if (style.strokeWidth) {
      this.ctx.lineWidth = style.strokeWidth;
    }
    if (style.opacity !== undefined) {
      this.ctx.globalAlpha = style.opacity;
    }
    
    // 设置线条样式
    if (style.strokeStyle === 'dashed') {
      this.ctx.setLineDash([5, 5]);
    } else if (style.strokeStyle === 'dotted') {
      this.ctx.setLineDash([2, 2]);
    }
  }
  
  private executeFillBatch(batch: RenderBatch): void {
    this.ctx.beginPath();
    
    for (const { element, renderData } of batch.operations) {
      this.addElementToPath(element, renderData);
    }
    
    this.ctx.fill();
  }
  
  private executeStrokeBatch(batch: RenderBatch): void {
    this.ctx.beginPath();
    
    for (const { element, renderData } of batch.operations) {
      this.addElementToPath(element, renderData);
    }
    
    this.ctx.stroke();
  }
  
  private executeTextBatch(batch: RenderBatch): void {
    for (const { element, renderData } of batch.operations) {
      if (element.type === 'text') {
        this.renderTextElement(element as any, renderData);
      }
    }
  }
  
  private executeImageBatch(batch: RenderBatch): void {
    for (const { element, renderData } of batch.operations) {
      if (element.type === 'image') {
        this.renderImageElement(element as any, renderData);
      }
    }
  }
  
  private addElementToPath(element: ExcalidrawElement, renderData: any): void {
    switch (element.type) {
      case 'rectangle':
        this.ctx.rect(element.x, element.y, element.width, element.height);
        break;
        
      case 'ellipse':
        this.ctx.ellipse(
          element.x + element.width / 2,
          element.y + element.height / 2,
          element.width / 2,
          element.height / 2,
          0, 0, 2 * Math.PI
        );
        break;
        
      case 'line':
        if (renderData.points) {
          const points = renderData.points;
          this.ctx.moveTo(points[0][0], points[0][1]);
          for (let i = 1; i < points.length; i++) {
            this.ctx.lineTo(points[i][0], points[i][1]);
          }
        }
        break;
    }
  }
  
  private renderTextElement(element: any, renderData: any): void {
    this.ctx.font = `${element.fontSize}px ${element.fontFamily}`;
    this.ctx.textAlign = element.textAlign;
    this.ctx.textBaseline = 'top';
    
    const lines = element.text.split('\n');
    lines.forEach((line: string, index: number) => {
      this.ctx.fillText(
        line,
        element.x,
        element.y + index * element.fontSize * 1.2
      );
    });
  }
  
  private renderImageElement(element: any, renderData: any): void {
    if (renderData.image && renderData.image.complete) {
      this.ctx.drawImage(
        renderData.image,
        element.x,
        element.y,
        element.width,
        element.height
      );
    }
  }
  
  private clearBatches(): void {
    this.batches.clear();
  }
  
  // 获取批次统计信息
  getBatchStats(): {
    batchCount: number;
    totalOperations: number;
    batchesByType: Record<string, number>;
  } {
    const stats = {
      batchCount: this.batches.size,
      totalOperations: 0,
      batchesByType: {} as Record<string, number>
    };
    
    for (const batch of this.batches.values()) {
      stats.totalOperations += batch.operations.length;
      stats.batchesByType[batch.type] = (stats.batchesByType[batch.type] || 0) + 1;
    }
    
    return stats;
  }
}
```

这是第10章第2节的内容，专注于渲染优化策略。我会继续创建下一个小节。