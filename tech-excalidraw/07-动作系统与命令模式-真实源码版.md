# 第七章：动作系统与命令模式（基于真实Excalidraw源码）

## 7.1 真实的动作系统架构

通过深入分析Excalidraw的真实源码，我们发现其动作系统采用了经典的命令模式设计，具有高度的可扩展性和模块化。让我们从实际代码出发，理解这个强大的动作系统。

### 7.1.1 动作系统核心类型

```typescript
// 基于 packages/excalidraw/actions/types.ts 的真实实现

// 动作来源
export type ActionSource =
  | "ui"              // 用户界面触发
  | "keyboard"        // 键盘快捷键
  | "contextMenu"     // 右键菜单
  | "api"             // 编程API调用
  | "commandPalette"; // 命令面板

// 动作执行结果
export type ActionResult =
  | {
      // 更新的元素数组
      elements?: readonly ExcalidrawElement[] | null;
      // 更新的应用状态
      appState?: Partial<AppState> | null;
      // 更新的二进制文件
      files?: BinaryFiles | null;
      // 是否捕获此次更新到历史记录
      captureUpdate: CaptureUpdateActionType;
      // 是否替换文件
      replaceFiles?: boolean;
    }
  | false; // 阻止动作执行

// 动作执行函数
type ActionFn = (
  elements: readonly OrderedExcalidrawElement[],
  appState: Readonly<AppState>,
  formData: any,
  app: AppClassProperties,
) => ActionResult | Promise<ActionResult>;

// 动作名称枚举（部分）
export type ActionName =
  // 基础编辑操作
  | "copy" | "cut" | "paste"
  | "duplicateSelection"
  | "deleteSelectedElements"
  | "selectAll"
  | "undo" | "redo"
  
  // 层级操作
  | "sendBackward" | "bringForward"
  | "sendToBack" | "bringToFront"
  
  // 对齐和分布
  | "alignLeft" | "alignRight" | "alignTop" | "alignBottom"
  | "alignVerticallyCentered" | "alignHorizontallyCentered"
  | "distributeHorizontally" | "distributeVertically"
  
  // 样式操作
  | "changeStrokeColor" | "changeBackgroundColor"
  | "changeFillStyle" | "changeStrokeWidth"
  | "changeOpacity" | "changeFontSize"
  
  // 视图操作
  | "zoomIn" | "zoomOut" | "resetZoom"
  | "zoomToFit" | "zoomToFitSelection"
  | "toggleViewMode" | "toggleZenMode"
  
  // 高级功能
  | "groupSelectedElements" | "ungroupSelectedElements"
  | "flipHorizontal" | "flipVertical"
  | "toggleElementLock"
  | "bindText" | "unbindText";

// 动作接口定义
export interface Action {
  // 动作名称
  name: ActionName;
  
  // 显示标签（支持动态计算）
  label: string | ((
    elements: readonly ExcalidrawElement[],
    appState: Readonly<AppState>,
    app: AppClassProperties,
  ) => string);
  
  // 搜索关键词
  keywords?: string[];
  
  // 图标（支持动态图标）
  icon?: React.ReactNode | ((
    appState: UIAppState,
    elements: readonly ExcalidrawElement[],
  ) => React.ReactNode);
  
  // 面板组件（用于属性面板）
  PanelComponent?: React.FC<PanelComponentProps>;
  
  // 动作执行函数
  perform: ActionFn;
  
  // 键盘快捷键优先级
  keyPriority?: number;
  
  // 键盘快捷键测试函数
  keyTest?: (
    event: React.KeyboardEvent | KeyboardEvent,
    appState: AppState,
    elements: readonly ExcalidrawElement[],
    app: AppClassProperties,
  ) => boolean;
  
  // 动作可用性断言
  predicate?: (
    elements: readonly ExcalidrawElement[],
    appState: AppState,
    appProps: AppState,
    app: AppClassProperties,
  ) => boolean;
  
  // 右键菜单可见性
  contextItemPredicate?: (
    elements: readonly ExcalidrawElement[],
    appState: AppState,
  ) => boolean;
  
  // 事件跟踪配置
  trackEvent?: {
    category: string;
    action?: string;
    predicate?: (
      appState: AppState,
      elements: readonly ExcalidrawElement[],
      value: any,
    ) => boolean;
  };
}
```

### 7.1.2 动作管理器实现

```typescript
// 基于 packages/excalidraw/actions/manager.tsx 的真实实现

export class ActionManager {
  private actionsMap = new Map<ActionName, Action>();
  
  constructor() {
    this.registerDefaultActions();
  }
  
  // 注册动作
  registerAction(action: Action): void {
    this.actionsMap.set(action.name, action);
  }
  
  // 批量注册动作
  registerActions(actions: Action[]): void {
    actions.forEach(action => this.registerAction(action));
  }
  
  // 获取动作
  getAction(name: ActionName): Action | undefined {
    return this.actionsMap.get(name);
  }
  
  // 获取所有动作
  getAllActions(): Action[] {
    return Array.from(this.actionsMap.values());
  }
  
  // 执行动作
  async executeAction(
    action: Action,
    source: ActionSource,
    elements: readonly OrderedExcalidrawElement[],
    appState: Readonly<AppState>,
    formData?: any,
    app?: AppClassProperties
  ): Promise<ActionResult> {
    // 检查动作是否可执行
    if (action.predicate && !action.predicate(elements, appState, app)) {
      return false;
    }
    
    // 记录动作事件
    this.trackAction(action, source, appState, elements, app, formData);
    
    try {
      // 执行动作
      const result = await action.perform(elements, appState, formData, app);
      
      // 验证结果
      if (!result || typeof result === 'boolean') {
        return result;
      }
      
      // 后处理
      return this.postProcessResult(result, action);
      
    } catch (error) {
      console.error(`Error executing action ${action.name}:`, error);
      return false;
    }
  }
  
  // 根据键盘事件查找动作
  findActionByKeyboardEvent(
    event: React.KeyboardEvent | KeyboardEvent,
    appState: AppState,
    elements: readonly ExcalidrawElement[],
    app: AppClassProperties
  ): Action | null {
    const actions = Array.from(this.actionsMap.values())
      .filter(action => action.keyTest)
      .sort((a, b) => (b.keyPriority || 0) - (a.keyPriority || 0));
    
    for (const action of actions) {
      if (action.keyTest!(event, appState, elements, app)) {
        return action;
      }
    }
    
    return null;
  }
  
  // 获取适用于当前上下文的动作
  getAvailableActions(
    elements: readonly ExcalidrawElement[],
    appState: AppState,
    app: AppClassProperties
  ): Action[] {
    return Array.from(this.actionsMap.values()).filter(action => 
      !action.predicate || action.predicate(elements, appState, app)
    );
  }
  
  // 获取右键菜单动作
  getContextMenuActions(
    elements: readonly ExcalidrawElement[],
    appState: AppState
  ): Action[] {
    return Array.from(this.actionsMap.values()).filter(action => 
      action.contextItemPredicate && action.contextItemPredicate(elements, appState)
    );
  }
  
  private trackAction(
    action: Action,
    source: ActionSource,
    appState: Readonly<AppState>,
    elements: readonly ExcalidrawElement[],
    app: AppClassProperties,
    value: any
  ): void {
    if (action.trackEvent) {
      try {
        if (typeof action.trackEvent === "object") {
          const shouldTrack = action.trackEvent.predicate
            ? action.trackEvent.predicate(appState, elements, value)
            : true;
            
          if (shouldTrack) {
            trackEvent(
              action.trackEvent.category,
              action.trackEvent.action || action.name,
              `${source} (${app.device.editor.isMobile ? "mobile" : "desktop"})`,
            );
          }
        }
      } catch (error) {
        console.error("error while logging action:", error);
      }
    }
  }
  
  private postProcessResult(result: ActionResult, action: Action): ActionResult {
    if (typeof result === 'boolean') {
      return result;
    }
    
    // 默认的后处理逻辑
    return {
      ...result,
      captureUpdate: result.captureUpdate ?? action.trackEvent ? "ephemeral" : "immediate"
    };
  }
  
  private registerDefaultActions(): void {
    // 注册所有默认动作
    this.registerActions([
      actionCopy,
      actionCut,
      actionPaste,
      actionDuplicateSelection,
      actionDeleteSelected,
      actionSelectAll,
      actionUndo,
      actionRedo,
      // ... 更多动作
    ]);
  }
}
```

## 7.2 具体动作实现示例

### 7.2.1 基础编辑动作

```typescript
// 基于 packages/excalidraw/actions/actionDeleteSelected.tsx 的真实实现

export const actionDeleteSelectedElements: Action = {
  name: "deleteSelectedElements",
  label: "labels.deleteSelectedElements",
  icon: TrashIcon,
  trackEvent: {
    category: "element",
  },
  keyTest: (event) => event.key === KEY.DELETE || event.key === KEY.BACKSPACE,
  
  predicate: (elements, appState) => {
    return Object.keys(appState.selectedElementIds).length > 0;
  },
  
  perform: (elements, appState, _, app) => {
    const selectedElementIds = appState.selectedElementIds;
    const selectedElements = elements.filter(el => selectedElementIds[el.id]);
    
    if (selectedElements.length === 0) {
      return false;
    }
    
    // 检查是否有锁定的元素
    const lockedElements = selectedElements.filter(el => el.locked);
    if (lockedElements.length > 0) {
      // 显示锁定元素警告
      app.setToast({
        message: "Cannot delete locked elements",
        type: "warning",
      });
      return false;
    }
    
    // 执行删除
    const nextElements = elements.map(el => 
      selectedElementIds[el.id] 
        ? { ...el, isDeleted: true } 
        : el
    );
    
    // 处理绑定文本
    const elementsToUpdate = new Set<string>();
    selectedElements.forEach(element => {
      if (element.boundElements) {
        element.boundElements.forEach(boundElement => {
          if (boundElement.type === "text") {
            elementsToUpdate.add(boundElement.id);
          }
        });
      }
    });
    
    // 更新绑定元素
    const finalElements = nextElements.map(el => {
      if (elementsToUpdate.has(el.id) && isTextElement(el)) {
        return { ...el, containerId: null };
      }
      return el;
    });
    
    return {
      elements: finalElements,
      appState: {
        ...appState,
        selectedElementIds: {},
      },
      captureUpdate: "immediate",
    };
  },
};

// 基于 packages/excalidraw/actions/actionDuplicateSelection.tsx 的真实实现

export const actionDuplicateSelection: Action = {
  name: "duplicateSelection",
  label: "labels.duplicateSelection",
  icon: DuplicateIcon,
  trackEvent: { category: "element" },
  keyTest: (event) => 
    event[KEYS.CTRL_OR_CMD] && 
    event.key === KEYS.D && 
    !event.shiftKey,
  
  predicate: (elements, appState) => {
    return Object.keys(appState.selectedElementIds).length > 0;
  },
  
  perform: (elements, appState, _, app) => {
    const selectedElements = elements.filter(el => 
      appState.selectedElementIds[el.id]
    );
    
    if (selectedElements.length === 0) {
      return false;
    }
    
    // 计算偏移量
    const DUPLICATE_OFFSET = 20;
    const offset = { x: DUPLICATE_OFFSET, y: DUPLICATE_OFFSET };
    
    // 复制元素
    const duplicatedElements = selectedElements.map(element => {
      const newElement = {
        ...element,
        id: randomId(),
        x: element.x + offset.x,
        y: element.y + offset.y,
        seed: randomInteger(),
        version: 1,
        versionNonce: randomInteger(),
        updated: getUpdatedTimestamp(),
      };
      
      // 处理绑定关系
      if (element.boundElements) {
        newElement.boundElements = null; // 重新建立绑定关系
      }
      
      return newElement;
    });
    
    // 处理群组关系
    const groupIdMap = new Map<string, string>();
    duplicatedElements.forEach((element, index) => {
      const originalElement = selectedElements[index];
      
      if (originalElement.groupIds.length > 0) {
        const newGroupIds = originalElement.groupIds.map(groupId => {
          if (!groupIdMap.has(groupId)) {
            groupIdMap.set(groupId, randomId());
          }
          return groupIdMap.get(groupId)!;
        });
        
        element.groupIds = newGroupIds;
      }
    });
    
    // 重新建立绑定关系
    const bindingMap = new Map<string, string>();
    selectedElements.forEach((element, index) => {
      bindingMap.set(element.id, duplicatedElements[index].id);
    });
    
    duplicatedElements.forEach((element, index) => {
      const originalElement = selectedElements[index];
      
      if (originalElement.boundElements) {
        element.boundElements = originalElement.boundElements
          .map(bound => {
            const newId = bindingMap.get(bound.id);
            return newId ? { ...bound, id: newId } : null;
          })
          .filter(bound => bound !== null);
      }
    });
    
    // 更新选中状态
    const newSelectedElementIds: Record<string, boolean> = {};
    duplicatedElements.forEach(element => {
      newSelectedElementIds[element.id] = true;
    });
    
    return {
      elements: [...elements, ...duplicatedElements],
      appState: {
        ...appState,
        selectedElementIds: newSelectedElementIds,
      },
      captureUpdate: "immediate",
    };
  },
};
```

### 7.2.2 样式变更动作

```typescript
// 基于 packages/excalidraw/actions/actionProperties.tsx 的真实实现

export const actionChangeStrokeColor: Action = {
  name: "changeStrokeColor",
  label: "Change stroke color",
  icon: StrokeColorIcon,
  trackEvent: { category: "element", action: "changeStrokeColor" },
  
  predicate: (elements, appState) => {
    return Object.keys(appState.selectedElementIds).length > 0;
  },
  
  PanelComponent: ({ elements, appState, updateData }) => (
    <ColorPicker
      label="Stroke"
      color={getCurrentStrokeColor(elements, appState)}
      onChange={(color) => updateData({ strokeColor: color })}
      colors={COLOR_PALETTE}
    />
  ),
  
  perform: (elements, appState, formData, app) => {
    const selectedElementIds = appState.selectedElementIds;
    const { strokeColor } = formData;
    
    if (!strokeColor || Object.keys(selectedElementIds).length === 0) {
      return false;
    }
    
    const nextElements = elements.map(element => {
      if (selectedElementIds[element.id]) {
        return mutateElement(element, { strokeColor });
      }
      return element;
    });
    
    return {
      elements: nextElements,
      appState: {
        ...appState,
        currentItemStrokeColor: strokeColor,
      },
      captureUpdate: "ephemeral",
    };
  },
};

// 通用样式变更动作工厂
const createStyleChangeAction = <T extends keyof ExcalidrawElement>(
  property: T,
  actionName: ActionName,
  label: string,
  icon: React.ReactNode
): Action => {
  return {
    name: actionName,
    label,
    icon,
    trackEvent: { category: "element", action: actionName },
    
    predicate: (elements, appState) => {
      return Object.keys(appState.selectedElementIds).length > 0;
    },
    
    perform: (elements, appState, formData) => {
      const selectedElementIds = appState.selectedElementIds;
      const value = formData[property];
      
      if (value === undefined || Object.keys(selectedElementIds).length === 0) {
        return false;
      }
      
      const nextElements = elements.map(element => {
        if (selectedElementIds[element.id]) {
          return mutateElement(element, { [property]: value } as any);
        }
        return element;
      });
      
      return {
        elements: nextElements,
        appState: {
          ...appState,
          [`currentItem${property.charAt(0).toUpperCase() + property.slice(1)}`]: value,
        } as any,
        captureUpdate: "ephemeral",
      };
    },
  };
};

// 使用工厂创建样式动作
export const actionChangeBackgroundColor = createStyleChangeAction(
  "backgroundColor",
  "changeBackgroundColor",
  "Change background color",
  BackgroundColorIcon
);

export const actionChangeStrokeWidth = createStyleChangeAction(
  "strokeWidth",
  "changeStrokeWidth", 
  "Change stroke width",
  StrokeWidthIcon
);

export const actionChangeOpacity = createStyleChangeAction(
  "opacity",
  "changeOpacity",
  "Change opacity",
  OpacityIcon
);
```

### 7.2.3 复杂动作：对齐操作

```typescript
// 基于 packages/excalidraw/actions/actionAlign.tsx 的真实实现

const getElementsAlignment = (
  elements: readonly ExcalidrawElement[]
): {
  minX: number;
  maxX: number;
  minY: number;
  maxY: number;
  centerX: number;
  centerY: number;
} => {
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  
  elements.forEach(element => {
    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);
    minX = Math.min(minX, x1);
    maxX = Math.max(maxX, x2);
    minY = Math.min(minY, y1);
    maxY = Math.max(maxY, y2);
  });
  
  return {
    minX,
    maxX,
    minY,
    maxY,
    centerX: (minX + maxX) / 2,
    centerY: (minY + maxY) / 2,
  };
};

export const actionAlignLeft: Action = {
  name: "alignLeft",
  label: "Align left",
  icon: AlignLeftIcon,
  trackEvent: { category: "element", action: "align" },
  keyTest: (event) => 
    event[KEYS.CTRL_OR_CMD] && 
    event.shiftKey && 
    event.key === "ArrowLeft",
  
  predicate: (elements, appState) => {
    const selectedElements = elements.filter(el => 
      appState.selectedElementIds[el.id]
    );
    return selectedElements.length > 1;
  },
  
  perform: (elements, appState) => {
    const selectedElements = elements.filter(el => 
      appState.selectedElementIds[el.id]
    );
    
    if (selectedElements.length < 2) {
      return false;
    }
    
    const alignment = getElementsAlignment(selectedElements);
    
    const nextElements = elements.map(element => {
      if (!appState.selectedElementIds[element.id]) {
        return element;
      }
      
      const [x1] = getElementAbsoluteCoords(element);
      const offset = alignment.minX - x1;
      
      return mutateElement(element, {
        x: element.x + offset
      });
    });
    
    return {
      elements: nextElements,
      captureUpdate: "immediate",
    };
  },
};

export const actionAlignCenter: Action = {
  name: "alignHorizontallyCentered",
  label: "Align center",
  icon: AlignCenterIcon,
  trackEvent: { category: "element", action: "align" },
  
  predicate: (elements, appState) => {
    const selectedElements = elements.filter(el => 
      appState.selectedElementIds[el.id]
    );
    return selectedElements.length > 1;
  },
  
  perform: (elements, appState) => {
    const selectedElements = elements.filter(el => 
      appState.selectedElementIds[el.id]
    );
    
    if (selectedElements.length < 2) {
      return false;
    }
    
    const alignment = getElementsAlignment(selectedElements);
    
    const nextElements = elements.map(element => {
      if (!appState.selectedElementIds[element.id]) {
        return element;
      }
      
      const [x1, , x2] = getElementAbsoluteCoords(element);
      const elementCenterX = (x1 + x2) / 2;
      const offset = alignment.centerX - elementCenterX;
      
      return mutateElement(element, {
        x: element.x + offset
      });
    });
    
    return {
      elements: nextElements,
      captureUpdate: "immediate",
    };
  },
};

// 分布动作
export const actionDistributeHorizontally: Action = {
  name: "distributeHorizontally",
  label: "Distribute horizontally",
  icon: DistributeHorizontallyIcon,
  trackEvent: { category: "element", action: "distribute" },
  
  predicate: (elements, appState) => {
    const selectedElements = elements.filter(el => 
      appState.selectedElementIds[el.id]
    );
    return selectedElements.length > 2;
  },
  
  perform: (elements, appState) => {
    const selectedElements = elements.filter(el => 
      appState.selectedElementIds[el.id]
    );
    
    if (selectedElements.length < 3) {
      return false;
    }
    
    // 按X坐标排序
    const sortedElements = selectedElements
      .map(element => ({
        element,
        bounds: getElementAbsoluteCoords(element),
      }))
      .sort((a, b) => a.bounds[0] - b.bounds[0]);
    
    const firstElement = sortedElements[0];
    const lastElement = sortedElements[sortedElements.length - 1];
    
    const totalSpacing = lastElement.bounds[0] - firstElement.bounds[2];
    const elementSpacing = totalSpacing / (sortedElements.length - 1);
    
    const nextElements = elements.map(element => {
      const sortedIndex = sortedElements.findIndex(
        item => item.element.id === element.id
      );
      
      if (sortedIndex === -1 || sortedIndex === 0 || sortedIndex === sortedElements.length - 1) {
        return element;
      }
      
      const targetX = firstElement.bounds[2] + (elementSpacing * sortedIndex);
      const currentBounds = getElementAbsoluteCoords(element);
      const offset = targetX - currentBounds[0];
      
      return mutateElement(element, {
        x: element.x + offset
      });
    });
    
    return {
      elements: nextElements,
      captureUpdate: "immediate",
    };
  },
};
```

## 7.3 键盘快捷键系统

### 7.3.1 快捷键管理器

```typescript
// 基于 packages/excalidraw/actions/shortcuts.ts 的真实实现

export const KEYS = {
  ARROW_DOWN: "ArrowDown",
  ARROW_LEFT: "ArrowLeft", 
  ARROW_RIGHT: "ArrowRight",
  ARROW_UP: "ArrowUp",
  BACKSPACE: "Backspace",
  DELETE: "Delete",
  ENTER: "Enter",
  ESCAPE: "Escape",
  SPACE: " ",
  TAB: "Tab",
  CTRL_OR_CMD: "ctrlOrCmd", // 虚拟键，表示Ctrl(Windows)或Cmd(Mac)
} as const;

export interface ShortcutDefinition {
  keys: string[];
  description: string;
  action: ActionName;
  group: string;
  predicate?: (
    elements: readonly ExcalidrawElement[],
    appState: AppState
  ) => boolean;
}

class ShortcutManager {
  private shortcuts: ShortcutDefinition[] = [];
  private actionManager: ActionManager;
  
  constructor(actionManager: ActionManager) {
    this.actionManager = actionManager;
    this.initializeDefaultShortcuts();
  }
  
  // 处理键盘事件
  handleKeyboardEvent(
    event: KeyboardEvent,
    elements: readonly ExcalidrawElement[],
    appState: AppState,
    app: AppClassProperties
  ): boolean {
    // 在某些情况下忽略快捷键
    if (this.shouldIgnoreKeyboardEvent(event, appState)) {
      return false;
    }
    
    // 查找匹配的动作
    const action = this.actionManager.findActionByKeyboardEvent(
      event, 
      appState, 
      elements, 
      app
    );
    
    if (!action) {
      return false;
    }
    
    // 阻止默认行为
    event.preventDefault();
    event.stopPropagation();
    
    // 执行动作
    this.actionManager.executeAction(
      action,
      "keyboard",
      elements as OrderedExcalidrawElement[],
      appState,
      null,
      app
    );
    
    return true;
  }
  
  // 注册快捷键
  registerShortcut(shortcut: ShortcutDefinition): void {
    this.shortcuts.push(shortcut);
  }
  
  // 获取所有快捷键
  getAllShortcuts(): ShortcutDefinition[] {
    return [...this.shortcuts];
  }
  
  // 按分组获取快捷键
  getShortcutsByGroup(group: string): ShortcutDefinition[] {
    return this.shortcuts.filter(shortcut => shortcut.group === group);
  }
  
  // 检查键盘组合
  static matchesKeyCombination(
    event: KeyboardEvent,
    keys: string[]
  ): boolean {
    const eventKeys = new Set<string>();
    
    // 添加修饰键
    if (event.ctrlKey || event.metaKey) eventKeys.add("ctrlOrCmd");
    if (event.altKey) eventKeys.add("alt");
    if (event.shiftKey) eventKeys.add("shift");
    
    // 添加主键
    eventKeys.add(event.key);
    
    // 检查是否匹配
    const requiredKeys = new Set(keys);
    
    return (
      eventKeys.size === requiredKeys.size &&
      [...eventKeys].every(key => requiredKeys.has(key))
    );
  }
  
  private shouldIgnoreKeyboardEvent(
    event: KeyboardEvent,
    appState: AppState
  ): boolean {
    // 在编辑文本时忽略大多数快捷键
    if (appState.editingTextElement) {
      const allowedKeys = new Set(['Escape', 'Enter', 'Tab']);
      return !allowedKeys.has(event.key);
    }
    
    // 在输入框聚焦时忽略快捷键
    const target = event.target as HTMLElement;
    if (target && (
      target.nodeName === "INPUT" || 
      target.nodeName === "TEXTAREA" ||
      target.contentEditable === "true"
    )) {
      return true;
    }
    
    // 在某些对话框打开时忽略快捷键
    if (appState.openDialog || appState.openMenu) {
      return true;
    }
    
    return false;
  }
  
  private initializeDefaultShortcuts(): void {
    this.shortcuts = [
      // 基础编辑
      {
        keys: ["ctrlOrCmd", "c"],
        description: "Copy",
        action: "copy",
        group: "edit",
      },
      {
        keys: ["ctrlOrCmd", "x"],
        description: "Cut",
        action: "cut",
        group: "edit",
      },
      {
        keys: ["ctrlOrCmd", "v"],
        description: "Paste",
        action: "paste",
        group: "edit",
      },
      {
        keys: ["ctrlOrCmd", "d"],
        description: "Duplicate",
        action: "duplicateSelection",
        group: "edit",
      },
      {
        keys: ["Delete"],
        description: "Delete selected",
        action: "deleteSelectedElements",
        group: "edit",
      },
      {
        keys: ["ctrlOrCmd", "a"],
        description: "Select all",
        action: "selectAll",
        group: "edit",
      },
      
      // 历史操作
      {
        keys: ["ctrlOrCmd", "z"],
        description: "Undo",
        action: "undo",
        group: "edit",
      },
      {
        keys: ["ctrlOrCmd", "shift", "z"],
        description: "Redo",
        action: "redo",
        group: "edit",
      },
      
      // 视图操作
      {
        keys: ["ctrlOrCmd", "+"],
        description: "Zoom in",
        action: "zoomIn",
        group: "view",
      },
      {
        keys: ["ctrlOrCmd", "-"],
        description: "Zoom out", 
        action: "zoomOut",
        group: "view",
      },
      {
        keys: ["ctrlOrCmd", "0"],
        description: "Reset zoom",
        action: "resetZoom",
        group: "view",
      },
      {
        keys: ["ctrlOrCmd", "1"],
        description: "Zoom to fit",
        action: "zoomToFit",
        group: "view",
      },
      
      // 对齐操作
      {
        keys: ["ctrlOrCmd", "shift", "ArrowLeft"],
        description: "Align left",
        action: "alignLeft",
        group: "align",
        predicate: (elements, appState) => {
          const selected = elements.filter(el => appState.selectedElementIds[el.id]);
          return selected.length > 1;
        },
      },
      {
        keys: ["ctrlOrCmd", "shift", "ArrowRight"],
        description: "Align right",
        action: "alignRight", 
        group: "align",
        predicate: (elements, appState) => {
          const selected = elements.filter(el => appState.selectedElementIds[el.id]);
          return selected.length > 1;
        },
      },
      
      // 层级操作
      {
        keys: ["ctrlOrCmd", "shift", "]"],
        description: "Bring to front",
        action: "bringToFront",
        group: "arrange",
      },
      {
        keys: ["ctrlOrCmd", "]"],
        description: "Bring forward",
        action: "bringForward",
        group: "arrange",
      },
      {
        keys: ["ctrlOrCmd", "["],
        description: "Send backward",
        action: "sendBackward",
        group: "arrange",
      },
      {
        keys: ["ctrlOrCmd", "shift", "["],
        description: "Send to back",
        action: "sendToBack",
        group: "arrange",
      },
      
      // 群组操作
      {
        keys: ["ctrlOrCmd", "g"],
        description: "Group selection",
        action: "groupSelectedElements",
        group: "arrange",
      },
      {
        keys: ["ctrlOrCmd", "shift", "g"],
        description: "Ungroup selection",
        action: "ungroupSelectedElements",
        group: "arrange",
      },
    ];
  }
}
```

## 7.4 命令面板系统

### 7.4.1 命令面板实现

```typescript
// 命令面板组件
interface CommandPaletteProps {
  isOpen: boolean;
  onClose: () => void;
  actionManager: ActionManager;
  elements: readonly ExcalidrawElement[];
  appState: AppState;
  app: AppClassProperties;
}

const CommandPalette: React.FC<CommandPaletteProps> = ({
  isOpen,
  onClose,
  actionManager,
  elements,
  appState,
  app,
}) => {
  const [query, setQuery] = useState("");
  const [selectedIndex, setSelectedIndex] = useState(0);
  
  // 获取可用动作
  const availableActions = useMemo(() => {
    return actionManager.getAvailableActions(elements, appState, app);
  }, [actionManager, elements, appState, app]);
  
  // 过滤和搜索动作
  const filteredActions = useMemo(() => {
    if (!query.trim()) {
      return availableActions;
    }
    
    const normalizedQuery = query.toLowerCase().trim();
    
    return availableActions.filter(action => {
      // 搜索标签
      const label = typeof action.label === "string" 
        ? action.label 
        : action.label(elements, appState, app);
      
      if (label.toLowerCase().includes(normalizedQuery)) {
        return true;
      }
      
      // 搜索关键词
      if (action.keywords) {
        return action.keywords.some(keyword => 
          keyword.toLowerCase().includes(normalizedQuery)
        );
      }
      
      return false;
    });
  }, [availableActions, query, elements, appState, app]);
  
  // 执行选中的动作
  const executeSelectedAction = useCallback(() => {
    const selectedAction = filteredActions[selectedIndex];
    if (selectedAction) {
      actionManager.executeAction(
        selectedAction,
        "commandPalette",
        elements as OrderedExcalidrawElement[],
        appState,
        null,
        app
      );
      onClose();
    }
  }, [filteredActions, selectedIndex, actionManager, elements, appState, app, onClose]);
  
  // 键盘导航
  const handleKeyDown = useCallback((event: React.KeyboardEvent) => {
    switch (event.key) {
      case "ArrowDown":
        event.preventDefault();
        setSelectedIndex(prev => 
          Math.min(prev + 1, filteredActions.length - 1)
        );
        break;
        
      case "ArrowUp":
        event.preventDefault();
        setSelectedIndex(prev => Math.max(prev - 1, 0));
        break;
        
      case "Enter":
        event.preventDefault();
        executeSelectedAction();
        break;
        
      case "Escape":
        event.preventDefault();
        onClose();
        break;
    }
  }, [filteredActions.length, executeSelectedAction, onClose]);
  
  // 重置选择索引当过滤结果改变
  useEffect(() => {
    setSelectedIndex(0);
  }, [filteredActions]);
  
  if (!isOpen) return null;
  
  return (
    <div className="command-palette-overlay">
      <div className="command-palette">
        <div className="command-palette-header">
          <input
            type="text"
            placeholder="Search commands..."
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            onKeyDown={handleKeyDown}
            autoFocus
          />
        </div>
        
        <div className="command-palette-results">
          {filteredActions.length === 0 ? (
            <div className="no-results">No commands found</div>
          ) : (
            filteredActions.map((action, index) => {
              const label = typeof action.label === "string"
                ? action.label
                : action.label(elements, appState, app);
              
              return (
                <div
                  key={action.name}
                  className={`command-item ${index === selectedIndex ? "selected" : ""}`}
                  onClick={() => {
                    setSelectedIndex(index);
                    executeSelectedAction();
                  }}
                >
                  <div className="command-icon">
                    {typeof action.icon === "function" 
                      ? action.icon(appState, elements)
                      : action.icon
                    }
                  </div>
                  <div className="command-label">{label}</div>
                  <div className="command-shortcut">
                    {getActionShortcut(action.name)}
                  </div>
                </div>
              );
            })
          )}
        </div>
        
        <div className="command-palette-footer">
          <div className="command-palette-tips">
            <span>↑↓ to navigate</span>
            <span>↵ to execute</span>
            <span>ESC to close</span>
          </div>
        </div>
      </div>
    </div>
  );
};

// 获取动作的快捷键显示
const getActionShortcut = (actionName: ActionName): string => {
  const shortcutMap: Record<ActionName, string> = {
    "copy": "⌘C",
    "cut": "⌘X", 
    "paste": "⌘V",
    "duplicateSelection": "⌘D",
    "deleteSelectedElements": "Del",
    "selectAll": "⌘A",
    "undo": "⌘Z",
    "redo": "⌘⇧Z",
    "zoomIn": "⌘+",
    "zoomOut": "⌘-",
    "resetZoom": "⌘0",
    // ... 更多快捷键映射
  };
  
  return shortcutMap[actionName] || "";
};
```

## 7.5 实践项目：完整的动作系统

```typescript
// 完整的动作系统集成
class ExcalidrawActionSystem {
  private actionManager: ActionManager;
  private shortcutManager: ShortcutManager;
  private canvas: HTMLCanvasElement;
  
  constructor(canvas: HTMLCanvasElement) {
    this.canvas = canvas;
    this.actionManager = new ActionManager();
    this.shortcutManager = new ShortcutManager(this.actionManager);
    
    this.setupEventListeners();
  }
  
  // 设置事件监听器
  private setupEventListeners(): void {
    // 全局键盘事件
    window.addEventListener("keydown", this.handleGlobalKeyDown);
    
    // 画布特定事件
    this.canvas.addEventListener("keydown", this.handleCanvasKeyDown);
    this.canvas.addEventListener("contextmenu", this.handleContextMenu);
  }
  
  private handleGlobalKeyDown = (event: KeyboardEvent) => {
    // 处理全局快捷键
    const elements = this.getCurrentElements();
    const appState = this.getCurrentAppState();
    const app = this.getAppInstance();
    
    this.shortcutManager.handleKeyboardEvent(event, elements, appState, app);
  };
  
  private handleCanvasKeyDown = (event: KeyboardEvent) => {
    // 处理画布特定快捷键
    const elements = this.getCurrentElements();
    const appState = this.getCurrentAppState();
    const app = this.getAppInstance();
    
    this.shortcutManager.handleKeyboardEvent(event, elements, appState, app);
  };
  
  private handleContextMenu = (event: MouseEvent) => {
    event.preventDefault();
    
    const elements = this.getCurrentElements();
    const appState = this.getCurrentAppState();
    
    // 获取上下文菜单动作
    const contextActions = this.actionManager.getContextMenuActions(elements, appState);
    
    // 显示上下文菜单
    this.showContextMenu(event.clientX, event.clientY, contextActions);
  };
  
  // 注册自定义动作
  registerCustomAction(action: Action): void {
    this.actionManager.registerAction(action);
  }
  
  // 执行动作
  async executeAction(
    actionName: ActionName,
    source: ActionSource = "api",
    formData?: any
  ): Promise<ActionResult> {
    const action = this.actionManager.getAction(actionName);
    if (!action) {
      throw new Error(`Action ${actionName} not found`);
    }
    
    const elements = this.getCurrentElements();
    const appState = this.getCurrentAppState();
    const app = this.getAppInstance();
    
    return this.actionManager.executeAction(
      action,
      source,
      elements,
      appState,
      formData,
      app
    );
  }
  
  // 获取可用动作
  getAvailableActions(): Action[] {
    const elements = this.getCurrentElements();
    const appState = this.getCurrentAppState();
    const app = this.getAppInstance();
    
    return this.actionManager.getAvailableActions(elements, appState, app);
  }
  
  // 显示命令面板
  showCommandPalette(): void {
    const elements = this.getCurrentElements();
    const appState = this.getCurrentAppState();
    const app = this.getAppInstance();
    
    // 实际实现会显示 React 组件
    console.log("Showing command palette with actions:", 
      this.actionManager.getAvailableActions(elements, appState, app)
    );
  }
  
  // 获取快捷键帮助
  getShortcutHelp(): { [group: string]: ShortcutDefinition[] } {
    const shortcuts = this.shortcutManager.getAllShortcuts();
    const grouped: { [group: string]: ShortcutDefinition[] } = {};
    
    shortcuts.forEach(shortcut => {
      if (!grouped[shortcut.group]) {
        grouped[shortcut.group] = [];
      }
      grouped[shortcut.group].push(shortcut);
    });
    
    return grouped;
  }
  
  // 清理资源
  dispose(): void {
    window.removeEventListener("keydown", this.handleGlobalKeyDown);
    this.canvas.removeEventListener("keydown", this.handleCanvasKeyDown);
    this.canvas.removeEventListener("contextmenu", this.handleContextMenu);
  }
  
  // 这些方法需要与应用状态系统集成
  private getCurrentElements(): readonly ExcalidrawElement[] {
    // 实际实现会从状态管理器获取
    return [];
  }
  
  private getCurrentAppState(): AppState {
    // 实际实现会从状态管理器获取
    return {} as AppState;
  }
  
  private getAppInstance(): AppClassProperties {
    // 实际实现会返回应用实例
    return {} as AppClassProperties;
  }
  
  private showContextMenu(
    x: number,
    y: number,
    actions: Action[]
  ): void {
    // 实际实现会显示上下文菜单
    console.log("Showing context menu at", x, y, "with actions:", actions);
  }
}

// 使用示例
const canvas = document.getElementById('canvas') as HTMLCanvasElement;
const actionSystem = new ExcalidrawActionSystem(canvas);

// 注册自定义动作
actionSystem.registerCustomAction({
  name: "customAction" as ActionName,
  label: "My Custom Action",
  icon: "🎨",
  perform: (elements, appState) => {
    console.log("Custom action executed!");
    return { elements, captureUpdate: "immediate" };
  },
});

// 执行动作
await actionSystem.executeAction("duplicateSelection");

// 显示命令面板
actionSystem.showCommandPalette();

// 获取快捷键帮助
const shortcuts = actionSystem.getShortcutHelp();
console.log("Available shortcuts:", shortcuts);
```

通过深入分析真实的Excalidraw动作系统源码，我们看到了一个成熟的命令模式实现：类型安全的动作定义、强大的键盘快捷键系统、灵活的命令面板、以及完整的生命周期管理。这个系统为构建功能丰富的交互式应用提供了强有力的基础。