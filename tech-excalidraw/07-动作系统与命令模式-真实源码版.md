# ç¬¬ä¸ƒç« ï¼šåŠ¨ä½œç³»ç»Ÿä¸å‘½ä»¤æ¨¡å¼ï¼ˆåŸºäºçœŸå®Excalidrawæºç ï¼‰

## 7.1 çœŸå®çš„åŠ¨ä½œç³»ç»Ÿæ¶æ„

é€šè¿‡æ·±å…¥åˆ†æExcalidrawçš„çœŸå®æºç ï¼Œæˆ‘ä»¬å‘ç°å…¶åŠ¨ä½œç³»ç»Ÿé‡‡ç”¨äº†ç»å…¸çš„å‘½ä»¤æ¨¡å¼è®¾è®¡ï¼Œå…·æœ‰é«˜åº¦çš„å¯æ‰©å±•æ€§å’Œæ¨¡å—åŒ–ã€‚è®©æˆ‘ä»¬ä»å®é™…ä»£ç å‡ºå‘ï¼Œç†è§£è¿™ä¸ªå¼ºå¤§çš„åŠ¨ä½œç³»ç»Ÿã€‚

### 7.1.1 åŠ¨ä½œç³»ç»Ÿæ ¸å¿ƒç±»å‹

```typescript
// åŸºäº packages/excalidraw/actions/types.ts çš„çœŸå®å®ç°

// åŠ¨ä½œæ¥æº
export type ActionSource =
  | "ui"              // ç”¨æˆ·ç•Œé¢è§¦å‘
  | "keyboard"        // é”®ç›˜å¿«æ·é”®
  | "contextMenu"     // å³é”®èœå•
  | "api"             // ç¼–ç¨‹APIè°ƒç”¨
  | "commandPalette"; // å‘½ä»¤é¢æ¿

// åŠ¨ä½œæ‰§è¡Œç»“æœ
export type ActionResult =
  | {
      // æ›´æ–°çš„å…ƒç´ æ•°ç»„
      elements?: readonly ExcalidrawElement[] | null;
      // æ›´æ–°çš„åº”ç”¨çŠ¶æ€
      appState?: Partial<AppState> | null;
      // æ›´æ–°çš„äºŒè¿›åˆ¶æ–‡ä»¶
      files?: BinaryFiles | null;
      // æ˜¯å¦æ•è·æ­¤æ¬¡æ›´æ–°åˆ°å†å²è®°å½•
      captureUpdate: CaptureUpdateActionType;
      // æ˜¯å¦æ›¿æ¢æ–‡ä»¶
      replaceFiles?: boolean;
    }
  | false; // é˜»æ­¢åŠ¨ä½œæ‰§è¡Œ

// åŠ¨ä½œæ‰§è¡Œå‡½æ•°
type ActionFn = (
  elements: readonly OrderedExcalidrawElement[],
  appState: Readonly<AppState>,
  formData: any,
  app: AppClassProperties,
) => ActionResult | Promise<ActionResult>;

// åŠ¨ä½œåç§°æšä¸¾ï¼ˆéƒ¨åˆ†ï¼‰
export type ActionName =
  // åŸºç¡€ç¼–è¾‘æ“ä½œ
  | "copy" | "cut" | "paste"
  | "duplicateSelection"
  | "deleteSelectedElements"
  | "selectAll"
  | "undo" | "redo"
  
  // å±‚çº§æ“ä½œ
  | "sendBackward" | "bringForward"
  | "sendToBack" | "bringToFront"
  
  // å¯¹é½å’Œåˆ†å¸ƒ
  | "alignLeft" | "alignRight" | "alignTop" | "alignBottom"
  | "alignVerticallyCentered" | "alignHorizontallyCentered"
  | "distributeHorizontally" | "distributeVertically"
  
  // æ ·å¼æ“ä½œ
  | "changeStrokeColor" | "changeBackgroundColor"
  | "changeFillStyle" | "changeStrokeWidth"
  | "changeOpacity" | "changeFontSize"
  
  // è§†å›¾æ“ä½œ
  | "zoomIn" | "zoomOut" | "resetZoom"
  | "zoomToFit" | "zoomToFitSelection"
  | "toggleViewMode" | "toggleZenMode"
  
  // é«˜çº§åŠŸèƒ½
  | "groupSelectedElements" | "ungroupSelectedElements"
  | "flipHorizontal" | "flipVertical"
  | "toggleElementLock"
  | "bindText" | "unbindText";

// åŠ¨ä½œæ¥å£å®šä¹‰
export interface Action {
  // åŠ¨ä½œåç§°
  name: ActionName;
  
  // æ˜¾ç¤ºæ ‡ç­¾ï¼ˆæ”¯æŒåŠ¨æ€è®¡ç®—ï¼‰
  label: string | ((
    elements: readonly ExcalidrawElement[],
    appState: Readonly<AppState>,
    app: AppClassProperties,
  ) => string);
  
  // æœç´¢å…³é”®è¯
  keywords?: string[];
  
  // å›¾æ ‡ï¼ˆæ”¯æŒåŠ¨æ€å›¾æ ‡ï¼‰
  icon?: React.ReactNode | ((
    appState: UIAppState,
    elements: readonly ExcalidrawElement[],
  ) => React.ReactNode);
  
  // é¢æ¿ç»„ä»¶ï¼ˆç”¨äºå±æ€§é¢æ¿ï¼‰
  PanelComponent?: React.FC<PanelComponentProps>;
  
  // åŠ¨ä½œæ‰§è¡Œå‡½æ•°
  perform: ActionFn;
  
  // é”®ç›˜å¿«æ·é”®ä¼˜å…ˆçº§
  keyPriority?: number;
  
  // é”®ç›˜å¿«æ·é”®æµ‹è¯•å‡½æ•°
  keyTest?: (
    event: React.KeyboardEvent | KeyboardEvent,
    appState: AppState,
    elements: readonly ExcalidrawElement[],
    app: AppClassProperties,
  ) => boolean;
  
  // åŠ¨ä½œå¯ç”¨æ€§æ–­è¨€
  predicate?: (
    elements: readonly ExcalidrawElement[],
    appState: AppState,
    appProps: AppState,
    app: AppClassProperties,
  ) => boolean;
  
  // å³é”®èœå•å¯è§æ€§
  contextItemPredicate?: (
    elements: readonly ExcalidrawElement[],
    appState: AppState,
  ) => boolean;
  
  // äº‹ä»¶è·Ÿè¸ªé…ç½®
  trackEvent?: {
    category: string;
    action?: string;
    predicate?: (
      appState: AppState,
      elements: readonly ExcalidrawElement[],
      value: any,
    ) => boolean;
  };
}
```

### 7.1.2 åŠ¨ä½œç®¡ç†å™¨å®ç°

```typescript
// åŸºäº packages/excalidraw/actions/manager.tsx çš„çœŸå®å®ç°

export class ActionManager {
  private actionsMap = new Map<ActionName, Action>();
  
  constructor() {
    this.registerDefaultActions();
  }
  
  // æ³¨å†ŒåŠ¨ä½œ
  registerAction(action: Action): void {
    this.actionsMap.set(action.name, action);
  }
  
  // æ‰¹é‡æ³¨å†ŒåŠ¨ä½œ
  registerActions(actions: Action[]): void {
    actions.forEach(action => this.registerAction(action));
  }
  
  // è·å–åŠ¨ä½œ
  getAction(name: ActionName): Action | undefined {
    return this.actionsMap.get(name);
  }
  
  // è·å–æ‰€æœ‰åŠ¨ä½œ
  getAllActions(): Action[] {
    return Array.from(this.actionsMap.values());
  }
  
  // æ‰§è¡ŒåŠ¨ä½œ
  async executeAction(
    action: Action,
    source: ActionSource,
    elements: readonly OrderedExcalidrawElement[],
    appState: Readonly<AppState>,
    formData?: any,
    app?: AppClassProperties
  ): Promise<ActionResult> {
    // æ£€æŸ¥åŠ¨ä½œæ˜¯å¦å¯æ‰§è¡Œ
    if (action.predicate && !action.predicate(elements, appState, app)) {
      return false;
    }
    
    // è®°å½•åŠ¨ä½œäº‹ä»¶
    this.trackAction(action, source, appState, elements, app, formData);
    
    try {
      // æ‰§è¡ŒåŠ¨ä½œ
      const result = await action.perform(elements, appState, formData, app);
      
      // éªŒè¯ç»“æœ
      if (!result || typeof result === 'boolean') {
        return result;
      }
      
      // åå¤„ç†
      return this.postProcessResult(result, action);
      
    } catch (error) {
      console.error(`Error executing action ${action.name}:`, error);
      return false;
    }
  }
  
  // æ ¹æ®é”®ç›˜äº‹ä»¶æŸ¥æ‰¾åŠ¨ä½œ
  findActionByKeyboardEvent(
    event: React.KeyboardEvent | KeyboardEvent,
    appState: AppState,
    elements: readonly ExcalidrawElement[],
    app: AppClassProperties
  ): Action | null {
    const actions = Array.from(this.actionsMap.values())
      .filter(action => action.keyTest)
      .sort((a, b) => (b.keyPriority || 0) - (a.keyPriority || 0));
    
    for (const action of actions) {
      if (action.keyTest!(event, appState, elements, app)) {
        return action;
      }
    }
    
    return null;
  }
  
  // è·å–é€‚ç”¨äºå½“å‰ä¸Šä¸‹æ–‡çš„åŠ¨ä½œ
  getAvailableActions(
    elements: readonly ExcalidrawElement[],
    appState: AppState,
    app: AppClassProperties
  ): Action[] {
    return Array.from(this.actionsMap.values()).filter(action => 
      !action.predicate || action.predicate(elements, appState, app)
    );
  }
  
  // è·å–å³é”®èœå•åŠ¨ä½œ
  getContextMenuActions(
    elements: readonly ExcalidrawElement[],
    appState: AppState
  ): Action[] {
    return Array.from(this.actionsMap.values()).filter(action => 
      action.contextItemPredicate && action.contextItemPredicate(elements, appState)
    );
  }
  
  private trackAction(
    action: Action,
    source: ActionSource,
    appState: Readonly<AppState>,
    elements: readonly ExcalidrawElement[],
    app: AppClassProperties,
    value: any
  ): void {
    if (action.trackEvent) {
      try {
        if (typeof action.trackEvent === "object") {
          const shouldTrack = action.trackEvent.predicate
            ? action.trackEvent.predicate(appState, elements, value)
            : true;
            
          if (shouldTrack) {
            trackEvent(
              action.trackEvent.category,
              action.trackEvent.action || action.name,
              `${source} (${app.device.editor.isMobile ? "mobile" : "desktop"})`,
            );
          }
        }
      } catch (error) {
        console.error("error while logging action:", error);
      }
    }
  }
  
  private postProcessResult(result: ActionResult, action: Action): ActionResult {
    if (typeof result === 'boolean') {
      return result;
    }
    
    // é»˜è®¤çš„åå¤„ç†é€»è¾‘
    return {
      ...result,
      captureUpdate: result.captureUpdate ?? action.trackEvent ? "ephemeral" : "immediate"
    };
  }
  
  private registerDefaultActions(): void {
    // æ³¨å†Œæ‰€æœ‰é»˜è®¤åŠ¨ä½œ
    this.registerActions([
      actionCopy,
      actionCut,
      actionPaste,
      actionDuplicateSelection,
      actionDeleteSelected,
      actionSelectAll,
      actionUndo,
      actionRedo,
      // ... æ›´å¤šåŠ¨ä½œ
    ]);
  }
}
```

## 7.2 å…·ä½“åŠ¨ä½œå®ç°ç¤ºä¾‹

### 7.2.1 åŸºç¡€ç¼–è¾‘åŠ¨ä½œ

```typescript
// åŸºäº packages/excalidraw/actions/actionDeleteSelected.tsx çš„çœŸå®å®ç°

export const actionDeleteSelectedElements: Action = {
  name: "deleteSelectedElements",
  label: "labels.deleteSelectedElements",
  icon: TrashIcon,
  trackEvent: {
    category: "element",
  },
  keyTest: (event) => event.key === KEY.DELETE || event.key === KEY.BACKSPACE,
  
  predicate: (elements, appState) => {
    return Object.keys(appState.selectedElementIds).length > 0;
  },
  
  perform: (elements, appState, _, app) => {
    const selectedElementIds = appState.selectedElementIds;
    const selectedElements = elements.filter(el => selectedElementIds[el.id]);
    
    if (selectedElements.length === 0) {
      return false;
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰é”å®šçš„å…ƒç´ 
    const lockedElements = selectedElements.filter(el => el.locked);
    if (lockedElements.length > 0) {
      // æ˜¾ç¤ºé”å®šå…ƒç´ è­¦å‘Š
      app.setToast({
        message: "Cannot delete locked elements",
        type: "warning",
      });
      return false;
    }
    
    // æ‰§è¡Œåˆ é™¤
    const nextElements = elements.map(el => 
      selectedElementIds[el.id] 
        ? { ...el, isDeleted: true } 
        : el
    );
    
    // å¤„ç†ç»‘å®šæ–‡æœ¬
    const elementsToUpdate = new Set<string>();
    selectedElements.forEach(element => {
      if (element.boundElements) {
        element.boundElements.forEach(boundElement => {
          if (boundElement.type === "text") {
            elementsToUpdate.add(boundElement.id);
          }
        });
      }
    });
    
    // æ›´æ–°ç»‘å®šå…ƒç´ 
    const finalElements = nextElements.map(el => {
      if (elementsToUpdate.has(el.id) && isTextElement(el)) {
        return { ...el, containerId: null };
      }
      return el;
    });
    
    return {
      elements: finalElements,
      appState: {
        ...appState,
        selectedElementIds: {},
      },
      captureUpdate: "immediate",
    };
  },
};

// åŸºäº packages/excalidraw/actions/actionDuplicateSelection.tsx çš„çœŸå®å®ç°

export const actionDuplicateSelection: Action = {
  name: "duplicateSelection",
  label: "labels.duplicateSelection",
  icon: DuplicateIcon,
  trackEvent: { category: "element" },
  keyTest: (event) => 
    event[KEYS.CTRL_OR_CMD] && 
    event.key === KEYS.D && 
    !event.shiftKey,
  
  predicate: (elements, appState) => {
    return Object.keys(appState.selectedElementIds).length > 0;
  },
  
  perform: (elements, appState, _, app) => {
    const selectedElements = elements.filter(el => 
      appState.selectedElementIds[el.id]
    );
    
    if (selectedElements.length === 0) {
      return false;
    }
    
    // è®¡ç®—åç§»é‡
    const DUPLICATE_OFFSET = 20;
    const offset = { x: DUPLICATE_OFFSET, y: DUPLICATE_OFFSET };
    
    // å¤åˆ¶å…ƒç´ 
    const duplicatedElements = selectedElements.map(element => {
      const newElement = {
        ...element,
        id: randomId(),
        x: element.x + offset.x,
        y: element.y + offset.y,
        seed: randomInteger(),
        version: 1,
        versionNonce: randomInteger(),
        updated: getUpdatedTimestamp(),
      };
      
      // å¤„ç†ç»‘å®šå…³ç³»
      if (element.boundElements) {
        newElement.boundElements = null; // é‡æ–°å»ºç«‹ç»‘å®šå…³ç³»
      }
      
      return newElement;
    });
    
    // å¤„ç†ç¾¤ç»„å…³ç³»
    const groupIdMap = new Map<string, string>();
    duplicatedElements.forEach((element, index) => {
      const originalElement = selectedElements[index];
      
      if (originalElement.groupIds.length > 0) {
        const newGroupIds = originalElement.groupIds.map(groupId => {
          if (!groupIdMap.has(groupId)) {
            groupIdMap.set(groupId, randomId());
          }
          return groupIdMap.get(groupId)!;
        });
        
        element.groupIds = newGroupIds;
      }
    });
    
    // é‡æ–°å»ºç«‹ç»‘å®šå…³ç³»
    const bindingMap = new Map<string, string>();
    selectedElements.forEach((element, index) => {
      bindingMap.set(element.id, duplicatedElements[index].id);
    });
    
    duplicatedElements.forEach((element, index) => {
      const originalElement = selectedElements[index];
      
      if (originalElement.boundElements) {
        element.boundElements = originalElement.boundElements
          .map(bound => {
            const newId = bindingMap.get(bound.id);
            return newId ? { ...bound, id: newId } : null;
          })
          .filter(bound => bound !== null);
      }
    });
    
    // æ›´æ–°é€‰ä¸­çŠ¶æ€
    const newSelectedElementIds: Record<string, boolean> = {};
    duplicatedElements.forEach(element => {
      newSelectedElementIds[element.id] = true;
    });
    
    return {
      elements: [...elements, ...duplicatedElements],
      appState: {
        ...appState,
        selectedElementIds: newSelectedElementIds,
      },
      captureUpdate: "immediate",
    };
  },
};
```

### 7.2.2 æ ·å¼å˜æ›´åŠ¨ä½œ

```typescript
// åŸºäº packages/excalidraw/actions/actionProperties.tsx çš„çœŸå®å®ç°

export const actionChangeStrokeColor: Action = {
  name: "changeStrokeColor",
  label: "Change stroke color",
  icon: StrokeColorIcon,
  trackEvent: { category: "element", action: "changeStrokeColor" },
  
  predicate: (elements, appState) => {
    return Object.keys(appState.selectedElementIds).length > 0;
  },
  
  PanelComponent: ({ elements, appState, updateData }) => (
    <ColorPicker
      label="Stroke"
      color={getCurrentStrokeColor(elements, appState)}
      onChange={(color) => updateData({ strokeColor: color })}
      colors={COLOR_PALETTE}
    />
  ),
  
  perform: (elements, appState, formData, app) => {
    const selectedElementIds = appState.selectedElementIds;
    const { strokeColor } = formData;
    
    if (!strokeColor || Object.keys(selectedElementIds).length === 0) {
      return false;
    }
    
    const nextElements = elements.map(element => {
      if (selectedElementIds[element.id]) {
        return mutateElement(element, { strokeColor });
      }
      return element;
    });
    
    return {
      elements: nextElements,
      appState: {
        ...appState,
        currentItemStrokeColor: strokeColor,
      },
      captureUpdate: "ephemeral",
    };
  },
};

// é€šç”¨æ ·å¼å˜æ›´åŠ¨ä½œå·¥å‚
const createStyleChangeAction = <T extends keyof ExcalidrawElement>(
  property: T,
  actionName: ActionName,
  label: string,
  icon: React.ReactNode
): Action => {
  return {
    name: actionName,
    label,
    icon,
    trackEvent: { category: "element", action: actionName },
    
    predicate: (elements, appState) => {
      return Object.keys(appState.selectedElementIds).length > 0;
    },
    
    perform: (elements, appState, formData) => {
      const selectedElementIds = appState.selectedElementIds;
      const value = formData[property];
      
      if (value === undefined || Object.keys(selectedElementIds).length === 0) {
        return false;
      }
      
      const nextElements = elements.map(element => {
        if (selectedElementIds[element.id]) {
          return mutateElement(element, { [property]: value } as any);
        }
        return element;
      });
      
      return {
        elements: nextElements,
        appState: {
          ...appState,
          [`currentItem${property.charAt(0).toUpperCase() + property.slice(1)}`]: value,
        } as any,
        captureUpdate: "ephemeral",
      };
    },
  };
};

// ä½¿ç”¨å·¥å‚åˆ›å»ºæ ·å¼åŠ¨ä½œ
export const actionChangeBackgroundColor = createStyleChangeAction(
  "backgroundColor",
  "changeBackgroundColor",
  "Change background color",
  BackgroundColorIcon
);

export const actionChangeStrokeWidth = createStyleChangeAction(
  "strokeWidth",
  "changeStrokeWidth", 
  "Change stroke width",
  StrokeWidthIcon
);

export const actionChangeOpacity = createStyleChangeAction(
  "opacity",
  "changeOpacity",
  "Change opacity",
  OpacityIcon
);
```

### 7.2.3 å¤æ‚åŠ¨ä½œï¼šå¯¹é½æ“ä½œ

```typescript
// åŸºäº packages/excalidraw/actions/actionAlign.tsx çš„çœŸå®å®ç°

const getElementsAlignment = (
  elements: readonly ExcalidrawElement[]
): {
  minX: number;
  maxX: number;
  minY: number;
  maxY: number;
  centerX: number;
  centerY: number;
} => {
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  
  elements.forEach(element => {
    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);
    minX = Math.min(minX, x1);
    maxX = Math.max(maxX, x2);
    minY = Math.min(minY, y1);
    maxY = Math.max(maxY, y2);
  });
  
  return {
    minX,
    maxX,
    minY,
    maxY,
    centerX: (minX + maxX) / 2,
    centerY: (minY + maxY) / 2,
  };
};

export const actionAlignLeft: Action = {
  name: "alignLeft",
  label: "Align left",
  icon: AlignLeftIcon,
  trackEvent: { category: "element", action: "align" },
  keyTest: (event) => 
    event[KEYS.CTRL_OR_CMD] && 
    event.shiftKey && 
    event.key === "ArrowLeft",
  
  predicate: (elements, appState) => {
    const selectedElements = elements.filter(el => 
      appState.selectedElementIds[el.id]
    );
    return selectedElements.length > 1;
  },
  
  perform: (elements, appState) => {
    const selectedElements = elements.filter(el => 
      appState.selectedElementIds[el.id]
    );
    
    if (selectedElements.length < 2) {
      return false;
    }
    
    const alignment = getElementsAlignment(selectedElements);
    
    const nextElements = elements.map(element => {
      if (!appState.selectedElementIds[element.id]) {
        return element;
      }
      
      const [x1] = getElementAbsoluteCoords(element);
      const offset = alignment.minX - x1;
      
      return mutateElement(element, {
        x: element.x + offset
      });
    });
    
    return {
      elements: nextElements,
      captureUpdate: "immediate",
    };
  },
};

export const actionAlignCenter: Action = {
  name: "alignHorizontallyCentered",
  label: "Align center",
  icon: AlignCenterIcon,
  trackEvent: { category: "element", action: "align" },
  
  predicate: (elements, appState) => {
    const selectedElements = elements.filter(el => 
      appState.selectedElementIds[el.id]
    );
    return selectedElements.length > 1;
  },
  
  perform: (elements, appState) => {
    const selectedElements = elements.filter(el => 
      appState.selectedElementIds[el.id]
    );
    
    if (selectedElements.length < 2) {
      return false;
    }
    
    const alignment = getElementsAlignment(selectedElements);
    
    const nextElements = elements.map(element => {
      if (!appState.selectedElementIds[element.id]) {
        return element;
      }
      
      const [x1, , x2] = getElementAbsoluteCoords(element);
      const elementCenterX = (x1 + x2) / 2;
      const offset = alignment.centerX - elementCenterX;
      
      return mutateElement(element, {
        x: element.x + offset
      });
    });
    
    return {
      elements: nextElements,
      captureUpdate: "immediate",
    };
  },
};

// åˆ†å¸ƒåŠ¨ä½œ
export const actionDistributeHorizontally: Action = {
  name: "distributeHorizontally",
  label: "Distribute horizontally",
  icon: DistributeHorizontallyIcon,
  trackEvent: { category: "element", action: "distribute" },
  
  predicate: (elements, appState) => {
    const selectedElements = elements.filter(el => 
      appState.selectedElementIds[el.id]
    );
    return selectedElements.length > 2;
  },
  
  perform: (elements, appState) => {
    const selectedElements = elements.filter(el => 
      appState.selectedElementIds[el.id]
    );
    
    if (selectedElements.length < 3) {
      return false;
    }
    
    // æŒ‰Xåæ ‡æ’åº
    const sortedElements = selectedElements
      .map(element => ({
        element,
        bounds: getElementAbsoluteCoords(element),
      }))
      .sort((a, b) => a.bounds[0] - b.bounds[0]);
    
    const firstElement = sortedElements[0];
    const lastElement = sortedElements[sortedElements.length - 1];
    
    const totalSpacing = lastElement.bounds[0] - firstElement.bounds[2];
    const elementSpacing = totalSpacing / (sortedElements.length - 1);
    
    const nextElements = elements.map(element => {
      const sortedIndex = sortedElements.findIndex(
        item => item.element.id === element.id
      );
      
      if (sortedIndex === -1 || sortedIndex === 0 || sortedIndex === sortedElements.length - 1) {
        return element;
      }
      
      const targetX = firstElement.bounds[2] + (elementSpacing * sortedIndex);
      const currentBounds = getElementAbsoluteCoords(element);
      const offset = targetX - currentBounds[0];
      
      return mutateElement(element, {
        x: element.x + offset
      });
    });
    
    return {
      elements: nextElements,
      captureUpdate: "immediate",
    };
  },
};
```

## 7.3 é”®ç›˜å¿«æ·é”®ç³»ç»Ÿ

### 7.3.1 å¿«æ·é”®ç®¡ç†å™¨

```typescript
// åŸºäº packages/excalidraw/actions/shortcuts.ts çš„çœŸå®å®ç°

export const KEYS = {
  ARROW_DOWN: "ArrowDown",
  ARROW_LEFT: "ArrowLeft", 
  ARROW_RIGHT: "ArrowRight",
  ARROW_UP: "ArrowUp",
  BACKSPACE: "Backspace",
  DELETE: "Delete",
  ENTER: "Enter",
  ESCAPE: "Escape",
  SPACE: " ",
  TAB: "Tab",
  CTRL_OR_CMD: "ctrlOrCmd", // è™šæ‹Ÿé”®ï¼Œè¡¨ç¤ºCtrl(Windows)æˆ–Cmd(Mac)
} as const;

export interface ShortcutDefinition {
  keys: string[];
  description: string;
  action: ActionName;
  group: string;
  predicate?: (
    elements: readonly ExcalidrawElement[],
    appState: AppState
  ) => boolean;
}

class ShortcutManager {
  private shortcuts: ShortcutDefinition[] = [];
  private actionManager: ActionManager;
  
  constructor(actionManager: ActionManager) {
    this.actionManager = actionManager;
    this.initializeDefaultShortcuts();
  }
  
  // å¤„ç†é”®ç›˜äº‹ä»¶
  handleKeyboardEvent(
    event: KeyboardEvent,
    elements: readonly ExcalidrawElement[],
    appState: AppState,
    app: AppClassProperties
  ): boolean {
    // åœ¨æŸäº›æƒ…å†µä¸‹å¿½ç•¥å¿«æ·é”®
    if (this.shouldIgnoreKeyboardEvent(event, appState)) {
      return false;
    }
    
    // æŸ¥æ‰¾åŒ¹é…çš„åŠ¨ä½œ
    const action = this.actionManager.findActionByKeyboardEvent(
      event, 
      appState, 
      elements, 
      app
    );
    
    if (!action) {
      return false;
    }
    
    // é˜»æ­¢é»˜è®¤è¡Œä¸º
    event.preventDefault();
    event.stopPropagation();
    
    // æ‰§è¡ŒåŠ¨ä½œ
    this.actionManager.executeAction(
      action,
      "keyboard",
      elements as OrderedExcalidrawElement[],
      appState,
      null,
      app
    );
    
    return true;
  }
  
  // æ³¨å†Œå¿«æ·é”®
  registerShortcut(shortcut: ShortcutDefinition): void {
    this.shortcuts.push(shortcut);
  }
  
  // è·å–æ‰€æœ‰å¿«æ·é”®
  getAllShortcuts(): ShortcutDefinition[] {
    return [...this.shortcuts];
  }
  
  // æŒ‰åˆ†ç»„è·å–å¿«æ·é”®
  getShortcutsByGroup(group: string): ShortcutDefinition[] {
    return this.shortcuts.filter(shortcut => shortcut.group === group);
  }
  
  // æ£€æŸ¥é”®ç›˜ç»„åˆ
  static matchesKeyCombination(
    event: KeyboardEvent,
    keys: string[]
  ): boolean {
    const eventKeys = new Set<string>();
    
    // æ·»åŠ ä¿®é¥°é”®
    if (event.ctrlKey || event.metaKey) eventKeys.add("ctrlOrCmd");
    if (event.altKey) eventKeys.add("alt");
    if (event.shiftKey) eventKeys.add("shift");
    
    // æ·»åŠ ä¸»é”®
    eventKeys.add(event.key);
    
    // æ£€æŸ¥æ˜¯å¦åŒ¹é…
    const requiredKeys = new Set(keys);
    
    return (
      eventKeys.size === requiredKeys.size &&
      [...eventKeys].every(key => requiredKeys.has(key))
    );
  }
  
  private shouldIgnoreKeyboardEvent(
    event: KeyboardEvent,
    appState: AppState
  ): boolean {
    // åœ¨ç¼–è¾‘æ–‡æœ¬æ—¶å¿½ç•¥å¤§å¤šæ•°å¿«æ·é”®
    if (appState.editingTextElement) {
      const allowedKeys = new Set(['Escape', 'Enter', 'Tab']);
      return !allowedKeys.has(event.key);
    }
    
    // åœ¨è¾“å…¥æ¡†èšç„¦æ—¶å¿½ç•¥å¿«æ·é”®
    const target = event.target as HTMLElement;
    if (target && (
      target.nodeName === "INPUT" || 
      target.nodeName === "TEXTAREA" ||
      target.contentEditable === "true"
    )) {
      return true;
    }
    
    // åœ¨æŸäº›å¯¹è¯æ¡†æ‰“å¼€æ—¶å¿½ç•¥å¿«æ·é”®
    if (appState.openDialog || appState.openMenu) {
      return true;
    }
    
    return false;
  }
  
  private initializeDefaultShortcuts(): void {
    this.shortcuts = [
      // åŸºç¡€ç¼–è¾‘
      {
        keys: ["ctrlOrCmd", "c"],
        description: "Copy",
        action: "copy",
        group: "edit",
      },
      {
        keys: ["ctrlOrCmd", "x"],
        description: "Cut",
        action: "cut",
        group: "edit",
      },
      {
        keys: ["ctrlOrCmd", "v"],
        description: "Paste",
        action: "paste",
        group: "edit",
      },
      {
        keys: ["ctrlOrCmd", "d"],
        description: "Duplicate",
        action: "duplicateSelection",
        group: "edit",
      },
      {
        keys: ["Delete"],
        description: "Delete selected",
        action: "deleteSelectedElements",
        group: "edit",
      },
      {
        keys: ["ctrlOrCmd", "a"],
        description: "Select all",
        action: "selectAll",
        group: "edit",
      },
      
      // å†å²æ“ä½œ
      {
        keys: ["ctrlOrCmd", "z"],
        description: "Undo",
        action: "undo",
        group: "edit",
      },
      {
        keys: ["ctrlOrCmd", "shift", "z"],
        description: "Redo",
        action: "redo",
        group: "edit",
      },
      
      // è§†å›¾æ“ä½œ
      {
        keys: ["ctrlOrCmd", "+"],
        description: "Zoom in",
        action: "zoomIn",
        group: "view",
      },
      {
        keys: ["ctrlOrCmd", "-"],
        description: "Zoom out", 
        action: "zoomOut",
        group: "view",
      },
      {
        keys: ["ctrlOrCmd", "0"],
        description: "Reset zoom",
        action: "resetZoom",
        group: "view",
      },
      {
        keys: ["ctrlOrCmd", "1"],
        description: "Zoom to fit",
        action: "zoomToFit",
        group: "view",
      },
      
      // å¯¹é½æ“ä½œ
      {
        keys: ["ctrlOrCmd", "shift", "ArrowLeft"],
        description: "Align left",
        action: "alignLeft",
        group: "align",
        predicate: (elements, appState) => {
          const selected = elements.filter(el => appState.selectedElementIds[el.id]);
          return selected.length > 1;
        },
      },
      {
        keys: ["ctrlOrCmd", "shift", "ArrowRight"],
        description: "Align right",
        action: "alignRight", 
        group: "align",
        predicate: (elements, appState) => {
          const selected = elements.filter(el => appState.selectedElementIds[el.id]);
          return selected.length > 1;
        },
      },
      
      // å±‚çº§æ“ä½œ
      {
        keys: ["ctrlOrCmd", "shift", "]"],
        description: "Bring to front",
        action: "bringToFront",
        group: "arrange",
      },
      {
        keys: ["ctrlOrCmd", "]"],
        description: "Bring forward",
        action: "bringForward",
        group: "arrange",
      },
      {
        keys: ["ctrlOrCmd", "["],
        description: "Send backward",
        action: "sendBackward",
        group: "arrange",
      },
      {
        keys: ["ctrlOrCmd", "shift", "["],
        description: "Send to back",
        action: "sendToBack",
        group: "arrange",
      },
      
      // ç¾¤ç»„æ“ä½œ
      {
        keys: ["ctrlOrCmd", "g"],
        description: "Group selection",
        action: "groupSelectedElements",
        group: "arrange",
      },
      {
        keys: ["ctrlOrCmd", "shift", "g"],
        description: "Ungroup selection",
        action: "ungroupSelectedElements",
        group: "arrange",
      },
    ];
  }
}
```

## 7.4 å‘½ä»¤é¢æ¿ç³»ç»Ÿ

### 7.4.1 å‘½ä»¤é¢æ¿å®ç°

```typescript
// å‘½ä»¤é¢æ¿ç»„ä»¶
interface CommandPaletteProps {
  isOpen: boolean;
  onClose: () => void;
  actionManager: ActionManager;
  elements: readonly ExcalidrawElement[];
  appState: AppState;
  app: AppClassProperties;
}

const CommandPalette: React.FC<CommandPaletteProps> = ({
  isOpen,
  onClose,
  actionManager,
  elements,
  appState,
  app,
}) => {
  const [query, setQuery] = useState("");
  const [selectedIndex, setSelectedIndex] = useState(0);
  
  // è·å–å¯ç”¨åŠ¨ä½œ
  const availableActions = useMemo(() => {
    return actionManager.getAvailableActions(elements, appState, app);
  }, [actionManager, elements, appState, app]);
  
  // è¿‡æ»¤å’Œæœç´¢åŠ¨ä½œ
  const filteredActions = useMemo(() => {
    if (!query.trim()) {
      return availableActions;
    }
    
    const normalizedQuery = query.toLowerCase().trim();
    
    return availableActions.filter(action => {
      // æœç´¢æ ‡ç­¾
      const label = typeof action.label === "string" 
        ? action.label 
        : action.label(elements, appState, app);
      
      if (label.toLowerCase().includes(normalizedQuery)) {
        return true;
      }
      
      // æœç´¢å…³é”®è¯
      if (action.keywords) {
        return action.keywords.some(keyword => 
          keyword.toLowerCase().includes(normalizedQuery)
        );
      }
      
      return false;
    });
  }, [availableActions, query, elements, appState, app]);
  
  // æ‰§è¡Œé€‰ä¸­çš„åŠ¨ä½œ
  const executeSelectedAction = useCallback(() => {
    const selectedAction = filteredActions[selectedIndex];
    if (selectedAction) {
      actionManager.executeAction(
        selectedAction,
        "commandPalette",
        elements as OrderedExcalidrawElement[],
        appState,
        null,
        app
      );
      onClose();
    }
  }, [filteredActions, selectedIndex, actionManager, elements, appState, app, onClose]);
  
  // é”®ç›˜å¯¼èˆª
  const handleKeyDown = useCallback((event: React.KeyboardEvent) => {
    switch (event.key) {
      case "ArrowDown":
        event.preventDefault();
        setSelectedIndex(prev => 
          Math.min(prev + 1, filteredActions.length - 1)
        );
        break;
        
      case "ArrowUp":
        event.preventDefault();
        setSelectedIndex(prev => Math.max(prev - 1, 0));
        break;
        
      case "Enter":
        event.preventDefault();
        executeSelectedAction();
        break;
        
      case "Escape":
        event.preventDefault();
        onClose();
        break;
    }
  }, [filteredActions.length, executeSelectedAction, onClose]);
  
  // é‡ç½®é€‰æ‹©ç´¢å¼•å½“è¿‡æ»¤ç»“æœæ”¹å˜
  useEffect(() => {
    setSelectedIndex(0);
  }, [filteredActions]);
  
  if (!isOpen) return null;
  
  return (
    <div className="command-palette-overlay">
      <div className="command-palette">
        <div className="command-palette-header">
          <input
            type="text"
            placeholder="Search commands..."
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            onKeyDown={handleKeyDown}
            autoFocus
          />
        </div>
        
        <div className="command-palette-results">
          {filteredActions.length === 0 ? (
            <div className="no-results">No commands found</div>
          ) : (
            filteredActions.map((action, index) => {
              const label = typeof action.label === "string"
                ? action.label
                : action.label(elements, appState, app);
              
              return (
                <div
                  key={action.name}
                  className={`command-item ${index === selectedIndex ? "selected" : ""}`}
                  onClick={() => {
                    setSelectedIndex(index);
                    executeSelectedAction();
                  }}
                >
                  <div className="command-icon">
                    {typeof action.icon === "function" 
                      ? action.icon(appState, elements)
                      : action.icon
                    }
                  </div>
                  <div className="command-label">{label}</div>
                  <div className="command-shortcut">
                    {getActionShortcut(action.name)}
                  </div>
                </div>
              );
            })
          )}
        </div>
        
        <div className="command-palette-footer">
          <div className="command-palette-tips">
            <span>â†‘â†“ to navigate</span>
            <span>â†µ to execute</span>
            <span>ESC to close</span>
          </div>
        </div>
      </div>
    </div>
  );
};

// è·å–åŠ¨ä½œçš„å¿«æ·é”®æ˜¾ç¤º
const getActionShortcut = (actionName: ActionName): string => {
  const shortcutMap: Record<ActionName, string> = {
    "copy": "âŒ˜C",
    "cut": "âŒ˜X", 
    "paste": "âŒ˜V",
    "duplicateSelection": "âŒ˜D",
    "deleteSelectedElements": "Del",
    "selectAll": "âŒ˜A",
    "undo": "âŒ˜Z",
    "redo": "âŒ˜â‡§Z",
    "zoomIn": "âŒ˜+",
    "zoomOut": "âŒ˜-",
    "resetZoom": "âŒ˜0",
    // ... æ›´å¤šå¿«æ·é”®æ˜ å°„
  };
  
  return shortcutMap[actionName] || "";
};
```

## 7.5 å®è·µé¡¹ç›®ï¼šå®Œæ•´çš„åŠ¨ä½œç³»ç»Ÿ

```typescript
// å®Œæ•´çš„åŠ¨ä½œç³»ç»Ÿé›†æˆ
class ExcalidrawActionSystem {
  private actionManager: ActionManager;
  private shortcutManager: ShortcutManager;
  private canvas: HTMLCanvasElement;
  
  constructor(canvas: HTMLCanvasElement) {
    this.canvas = canvas;
    this.actionManager = new ActionManager();
    this.shortcutManager = new ShortcutManager(this.actionManager);
    
    this.setupEventListeners();
  }
  
  // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
  private setupEventListeners(): void {
    // å…¨å±€é”®ç›˜äº‹ä»¶
    window.addEventListener("keydown", this.handleGlobalKeyDown);
    
    // ç”»å¸ƒç‰¹å®šäº‹ä»¶
    this.canvas.addEventListener("keydown", this.handleCanvasKeyDown);
    this.canvas.addEventListener("contextmenu", this.handleContextMenu);
  }
  
  private handleGlobalKeyDown = (event: KeyboardEvent) => {
    // å¤„ç†å…¨å±€å¿«æ·é”®
    const elements = this.getCurrentElements();
    const appState = this.getCurrentAppState();
    const app = this.getAppInstance();
    
    this.shortcutManager.handleKeyboardEvent(event, elements, appState, app);
  };
  
  private handleCanvasKeyDown = (event: KeyboardEvent) => {
    // å¤„ç†ç”»å¸ƒç‰¹å®šå¿«æ·é”®
    const elements = this.getCurrentElements();
    const appState = this.getCurrentAppState();
    const app = this.getAppInstance();
    
    this.shortcutManager.handleKeyboardEvent(event, elements, appState, app);
  };
  
  private handleContextMenu = (event: MouseEvent) => {
    event.preventDefault();
    
    const elements = this.getCurrentElements();
    const appState = this.getCurrentAppState();
    
    // è·å–ä¸Šä¸‹æ–‡èœå•åŠ¨ä½œ
    const contextActions = this.actionManager.getContextMenuActions(elements, appState);
    
    // æ˜¾ç¤ºä¸Šä¸‹æ–‡èœå•
    this.showContextMenu(event.clientX, event.clientY, contextActions);
  };
  
  // æ³¨å†Œè‡ªå®šä¹‰åŠ¨ä½œ
  registerCustomAction(action: Action): void {
    this.actionManager.registerAction(action);
  }
  
  // æ‰§è¡ŒåŠ¨ä½œ
  async executeAction(
    actionName: ActionName,
    source: ActionSource = "api",
    formData?: any
  ): Promise<ActionResult> {
    const action = this.actionManager.getAction(actionName);
    if (!action) {
      throw new Error(`Action ${actionName} not found`);
    }
    
    const elements = this.getCurrentElements();
    const appState = this.getCurrentAppState();
    const app = this.getAppInstance();
    
    return this.actionManager.executeAction(
      action,
      source,
      elements,
      appState,
      formData,
      app
    );
  }
  
  // è·å–å¯ç”¨åŠ¨ä½œ
  getAvailableActions(): Action[] {
    const elements = this.getCurrentElements();
    const appState = this.getCurrentAppState();
    const app = this.getAppInstance();
    
    return this.actionManager.getAvailableActions(elements, appState, app);
  }
  
  // æ˜¾ç¤ºå‘½ä»¤é¢æ¿
  showCommandPalette(): void {
    const elements = this.getCurrentElements();
    const appState = this.getCurrentAppState();
    const app = this.getAppInstance();
    
    // å®é™…å®ç°ä¼šæ˜¾ç¤º React ç»„ä»¶
    console.log("Showing command palette with actions:", 
      this.actionManager.getAvailableActions(elements, appState, app)
    );
  }
  
  // è·å–å¿«æ·é”®å¸®åŠ©
  getShortcutHelp(): { [group: string]: ShortcutDefinition[] } {
    const shortcuts = this.shortcutManager.getAllShortcuts();
    const grouped: { [group: string]: ShortcutDefinition[] } = {};
    
    shortcuts.forEach(shortcut => {
      if (!grouped[shortcut.group]) {
        grouped[shortcut.group] = [];
      }
      grouped[shortcut.group].push(shortcut);
    });
    
    return grouped;
  }
  
  // æ¸…ç†èµ„æº
  dispose(): void {
    window.removeEventListener("keydown", this.handleGlobalKeyDown);
    this.canvas.removeEventListener("keydown", this.handleCanvasKeyDown);
    this.canvas.removeEventListener("contextmenu", this.handleContextMenu);
  }
  
  // è¿™äº›æ–¹æ³•éœ€è¦ä¸åº”ç”¨çŠ¶æ€ç³»ç»Ÿé›†æˆ
  private getCurrentElements(): readonly ExcalidrawElement[] {
    // å®é™…å®ç°ä¼šä»çŠ¶æ€ç®¡ç†å™¨è·å–
    return [];
  }
  
  private getCurrentAppState(): AppState {
    // å®é™…å®ç°ä¼šä»çŠ¶æ€ç®¡ç†å™¨è·å–
    return {} as AppState;
  }
  
  private getAppInstance(): AppClassProperties {
    // å®é™…å®ç°ä¼šè¿”å›åº”ç”¨å®ä¾‹
    return {} as AppClassProperties;
  }
  
  private showContextMenu(
    x: number,
    y: number,
    actions: Action[]
  ): void {
    // å®é™…å®ç°ä¼šæ˜¾ç¤ºä¸Šä¸‹æ–‡èœå•
    console.log("Showing context menu at", x, y, "with actions:", actions);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const canvas = document.getElementById('canvas') as HTMLCanvasElement;
const actionSystem = new ExcalidrawActionSystem(canvas);

// æ³¨å†Œè‡ªå®šä¹‰åŠ¨ä½œ
actionSystem.registerCustomAction({
  name: "customAction" as ActionName,
  label: "My Custom Action",
  icon: "ğŸ¨",
  perform: (elements, appState) => {
    console.log("Custom action executed!");
    return { elements, captureUpdate: "immediate" };
  },
});

// æ‰§è¡ŒåŠ¨ä½œ
await actionSystem.executeAction("duplicateSelection");

// æ˜¾ç¤ºå‘½ä»¤é¢æ¿
actionSystem.showCommandPalette();

// è·å–å¿«æ·é”®å¸®åŠ©
const shortcuts = actionSystem.getShortcutHelp();
console.log("Available shortcuts:", shortcuts);
```

é€šè¿‡æ·±å…¥åˆ†æçœŸå®çš„ExcalidrawåŠ¨ä½œç³»ç»Ÿæºç ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†ä¸€ä¸ªæˆç†Ÿçš„å‘½ä»¤æ¨¡å¼å®ç°ï¼šç±»å‹å®‰å…¨çš„åŠ¨ä½œå®šä¹‰ã€å¼ºå¤§çš„é”®ç›˜å¿«æ·é”®ç³»ç»Ÿã€çµæ´»çš„å‘½ä»¤é¢æ¿ã€ä»¥åŠå®Œæ•´çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚è¿™ä¸ªç³»ç»Ÿä¸ºæ„å»ºåŠŸèƒ½ä¸°å¯Œçš„äº¤äº’å¼åº”ç”¨æä¾›äº†å¼ºæœ‰åŠ›çš„åŸºç¡€ã€‚