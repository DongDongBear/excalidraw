# 第十章第三节：内存管理与缓存

## 10.3.1 对象池模式

对象池模式通过重用对象来减少垃圾回收的压力，特别适用于频繁创建和销毁的临时对象。

### 通用对象池实现

```typescript
class ObjectPool<T> {
  private pool: T[] = [];
  private createFn: () => T;
  private resetFn: (obj: T) => void;
  private maxSize: number;
  
  constructor(
    createFn: () => T,
    resetFn: (obj: T) => void,
    maxSize: number = 100
  ) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    this.maxSize = maxSize;
  }
  
  // 获取对象
  acquire(): T {
    if (this.pool.length > 0) {
      return this.pool.pop()!;
    }
    return this.createFn();
  }
  
  // 归还对象
  release(obj: T): void {
    if (this.pool.length < this.maxSize) {
      this.resetFn(obj);
      this.pool.push(obj);
    }
  }
  
  // 预热池子
  warmUp(count: number): void {
    for (let i = 0; i < count; i++) {
      this.pool.push(this.createFn());
    }
  }
  
  // 获取池子状态
  getStatus(): { poolSize: number; maxSize: number } {
    return {
      poolSize: this.pool.length,
      maxSize: this.maxSize
    };
  }
  
  // 清空池子
  clear(): void {
    this.pool.length = 0;
  }
}

// Vector2 对象池
const vector2Pool = new ObjectPool<Vector2>(
  () => new Vector2(0, 0),
  (vec) => vec.set(0, 0),
  200
);

// 临时矩形对象池
interface TempRect {
  x: number;
  y: number;
  width: number;
  height: number;
}

const rectPool = new ObjectPool<TempRect>(
  () => ({ x: 0, y: 0, width: 0, height: 0 }),
  (rect) => {
    rect.x = 0;
    rect.y = 0;
    rect.width = 0;
    rect.height = 0;
  },
  100
);

// 路径点数组池
const pointArrayPool = new ObjectPool<number[][]>(
  () => [],
  (arr) => arr.length = 0,
  50
);
```

### 渲染上下文对象池

```typescript
// 渲染状态对象池
interface RenderState {
  fillStyle: string;
  strokeStyle: string;
  lineWidth: number;
  globalAlpha: number;
  lineDash: number[];
  font: string;
  textAlign: CanvasTextAlign;
  textBaseline: CanvasTextBaseline;
}

class RenderStatePool {
  private static pool = new ObjectPool<RenderState>(
    () => ({
      fillStyle: '#000000',
      strokeStyle: '#000000',
      lineWidth: 1,
      globalAlpha: 1,
      lineDash: [],
      font: '16px Arial',
      textAlign: 'left',
      textBaseline: 'top'
    }),
    (state) => {
      state.fillStyle = '#000000';
      state.strokeStyle = '#000000';
      state.lineWidth = 1;
      state.globalAlpha = 1;
      state.lineDash = [];
      state.font = '16px Arial';
      state.textAlign = 'left';
      state.textBaseline = 'top';
    },
    50
  );
  
  static acquire(): RenderState {
    return this.pool.acquire();
  }
  
  static release(state: RenderState): void {
    this.pool.release(state);
  }
}

// 变换矩阵对象池
class Transform2DPool {
  private static pool = new ObjectPool<Transform2D>(
    () => new Transform2D(),
    (transform) => transform.reset(),
    30
  );
  
  static acquire(): Transform2D {
    return this.pool.acquire();
  }
  
  static release(transform: Transform2D): void {
    this.pool.release(transform);
  }
}
```

## 10.3.2 渲染缓存系统

缓存系统通过存储渲染结果来避免重复计算，特别适用于复杂的图形元素。

### 元素渲染缓存

```typescript
interface RenderCache {
  canvas: HTMLCanvasElement;
  ctx: CanvasRenderingContext2D;
  bounds: DirtyRect;
  version: number;
  lastUsed: number;
}

class ElementRenderCache {
  private cache = new Map<string, RenderCache>();
  private maxCacheSize = 100;
  private maxCacheAge = 60000; // 1分钟
  
  // 获取元素的缓存
  getCache(elementId: string, version: number): RenderCache | null {
    const cached = this.cache.get(elementId);
    
    if (cached && cached.version === version) {
      cached.lastUsed = Date.now();
      return cached;
    }
    
    return null;
  }
  
  // 设置元素缓存
  setCache(
    elementId: string, 
    version: number, 
    bounds: DirtyRect,
    renderFn: (ctx: CanvasRenderingContext2D) => void
  ): RenderCache {
    // 清理过期缓存
    this.cleanupExpiredCache();
    
    // 如果缓存已满，清理最旧的
    if (this.cache.size >= this.maxCacheSize) {
      this.evictOldestCache();
    }
    
    // 创建缓存画布
    const canvas = document.createElement('canvas');
    canvas.width = Math.ceil(bounds.width);
    canvas.height = Math.ceil(bounds.height);
    const ctx = canvas.getContext('2d')!;
    
    // 调整坐标系到缓存画布
    ctx.translate(-bounds.x, -bounds.y);
    
    // 执行渲染
    renderFn(ctx);
    
    const cache: RenderCache = {
      canvas,
      ctx,
      bounds,
      version,
      lastUsed: Date.now()
    };
    
    this.cache.set(elementId, cache);
    return cache;
  }
  
  // 使用缓存渲染
  renderFromCache(
    targetCtx: CanvasRenderingContext2D,
    cache: RenderCache
  ): void {
    targetCtx.drawImage(
      cache.canvas,
      cache.bounds.x,
      cache.bounds.y
    );
  }
  
  // 使元素缓存失效
  invalidateCache(elementId: string): void {
    this.cache.delete(elementId);
  }
  
  // 清理过期缓存
  private cleanupExpiredCache(): void {
    const now = Date.now();
    
    for (const [id, cache] of this.cache) {
      if (now - cache.lastUsed > this.maxCacheAge) {
        this.cache.delete(id);
      }
    }
  }
  
  // 清理最旧的缓存
  private evictOldestCache(): void {
    let oldestId = '';
    let oldestTime = Date.now();
    
    for (const [id, cache] of this.cache) {
      if (cache.lastUsed < oldestTime) {
        oldestTime = cache.lastUsed;
        oldestId = id;
      }
    }
    
    if (oldestId) {
      this.cache.delete(oldestId);
    }
  }
  
  // 获取缓存统计
  getCacheStats(): {
    size: number;
    maxSize: number;
    hitRate: number;
    memoryUsage: number;
  } {
    let memoryUsage = 0;
    
    for (const cache of this.cache.values()) {
      memoryUsage += cache.canvas.width * cache.canvas.height * 4; // RGBA
    }
    
    return {
      size: this.cache.size,
      maxSize: this.maxCacheSize,
      hitRate: this.calculateHitRate(),
      memoryUsage: memoryUsage / (1024 * 1024) // MB
    };
  }
  
  private calculateHitRate(): number {
    // 这里需要跟踪命中和未命中次数
    // 简化实现，返回固定值
    return 0.75;
  }
}
```

### 路径缓存系统

```typescript
interface PathCache {
  path: Path2D;
  bounds: DirtyRect;
  version: number;
  complexity: number; // 路径复杂度
}

class PathCacheManager {
  private pathCache = new Map<string, PathCache>();
  private maxCacheSize = 200;
  
  // 获取路径缓存
  getPathCache(element: ExcalidrawElement): PathCache | null {
    const cacheKey = this.getPathCacheKey(element);
    const cached = this.pathCache.get(cacheKey);
    
    if (cached && cached.version === element.version) {
      return cached;
    }
    
    return null;
  }
  
  // 设置路径缓存
  setPathCache(element: ExcalidrawElement, path: Path2D): void {
    if (this.pathCache.size >= this.maxCacheSize) {
      this.evictLowComplexityPaths();
    }
    
    const bounds = getElementBounds(element);
    const complexity = this.calculatePathComplexity(element);
    
    const cache: PathCache = {
      path,
      bounds,
      version: element.version || 0,
      complexity
    };
    
    const cacheKey = this.getPathCacheKey(element);
    this.pathCache.set(cacheKey, cache);
  }
  
  private getPathCacheKey(element: ExcalidrawElement): string {
    // 基于元素关键属性生成缓存键
    return `${element.type}-${element.id}-${element.version || 0}`;
  }
  
  private calculatePathComplexity(element: ExcalidrawElement): number {
    switch (element.type) {
      case 'rectangle':
      case 'ellipse':
        return 1; // 简单图形
      
      case 'line':
        return (element as any).points?.length || 2;
      
      case 'freedraw':
        return ((element as any).points?.length || 0) / 10;
      
      default:
        return 5;
    }
  }
  
  private evictLowComplexityPaths(): void {
    // 按复杂度排序，删除最简单的路径
    const sortedEntries = Array.from(this.pathCache.entries())
      .sort(([, a], [, b]) => a.complexity - b.complexity);
    
    // 删除最简单的25%
    const deleteCount = Math.floor(this.pathCache.size * 0.25);
    for (let i = 0; i < deleteCount; i++) {
      this.pathCache.delete(sortedEntries[i][0]);
    }
  }
}
```

## 10.3.3 内存监控与垃圾回收

### 内存使用监控器

```typescript
class MemoryMonitor {
  private memoryHistory: Array<{
    timestamp: number;
    used: number;
    total: number;
    elementCount: number;
  }> = [];
  
  private gcThreshold = 100 * 1024 * 1024; // 100MB阈值
  private isMonitoring = false;
  private monitorInterval: number | null = null;
  
  startMonitoring(): void {
    if (this.isMonitoring) return;
    
    this.isMonitoring = true;
    this.monitorInterval = window.setInterval(() => {
      this.recordMemoryUsage();
    }, 5000); // 每5秒记录一次
  }
  
  stopMonitoring(): void {
    if (!this.isMonitoring) return;
    
    this.isMonitoring = false;
    if (this.monitorInterval) {
      clearInterval(this.monitorInterval);
      this.monitorInterval = null;
    }
  }
  
  private recordMemoryUsage(): void {
    if ('memory' in performance) {
      const memInfo = (performance as any).memory;
      
      const record = {
        timestamp: Date.now(),
        used: memInfo.usedJSHeapSize,
        total: memInfo.totalJSHeapSize,
        elementCount: this.getElementCount()
      };
      
      this.memoryHistory.push(record);
      
      // 限制历史记录数量
      if (this.memoryHistory.length > 200) {
        this.memoryHistory = this.memoryHistory.slice(-150);
      }
      
      // 检查是否需要GC
      if (memInfo.usedJSHeapSize > this.gcThreshold) {
        this.suggestGarbageCollection();
      }
    }
  }
  
  private getElementCount(): number {
    // 这里需要获取当前元素数量
    // 实际实现会传入元素数量获取函数
    return 0;
  }
  
  private suggestGarbageCollection(): void {
    console.warn('Memory usage high, suggesting cleanup');
    
    // 触发清理事件
    window.dispatchEvent(new CustomEvent('memorycleanup', {
      detail: { usage: this.getCurrentMemoryUsage() }
    }));
  }
  
  getCurrentMemoryUsage(): {
    used: number;
    total: number;
    percentage: number;
  } | null {
    if ('memory' in performance) {
      const memInfo = (performance as any).memory;
      return {
        used: memInfo.usedJSHeapSize,
        total: memInfo.totalJSHeapSize,
        percentage: (memInfo.usedJSHeapSize / memInfo.totalJSHeapSize) * 100
      };
    }
    return null;
  }
  
  getMemoryTrend(): 'increasing' | 'stable' | 'decreasing' {
    if (this.memoryHistory.length < 5) return 'stable';
    
    const recent = this.memoryHistory.slice(-5);
    const trend = recent.reduce((sum, record, index) => {
      if (index === 0) return 0;
      const prev = recent[index - 1];
      return sum + (record.used - prev.used);
    }, 0);
    
    if (trend > 10 * 1024 * 1024) return 'increasing'; // 增长超过10MB
    if (trend < -10 * 1024 * 1024) return 'decreasing';
    return 'stable';
  }
  
  getMemoryHistory(): typeof this.memoryHistory {
    return [...this.memoryHistory];
  }
}
```

### 智能垃圾回收管理器

```typescript
class GarbageCollectionManager {
  private elementCache: ElementRenderCache;
  private pathCache: PathCacheManager;
  private memoryMonitor: MemoryMonitor;
  
  private cleanupCallbacks: Array<() => void> = [];
  
  constructor(
    elementCache: ElementRenderCache,
    pathCache: PathCacheManager,
    memoryMonitor: MemoryMonitor
  ) {
    this.elementCache = elementCache;
    this.pathCache = pathCache;
    this.memoryMonitor = memoryMonitor;
    
    this.setupMemoryPressureHandler();
  }
  
  private setupMemoryPressureHandler(): void {
    // 监听内存清理事件
    window.addEventListener('memorycleanup', () => {
      this.performCleanup();
    });
    
    // 监听页面可见性变化
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        this.performAggressiveCleanup();
      }
    });
    
    // 定期检查内存趋势
    setInterval(() => {
      const trend = this.memoryMonitor.getMemoryTrend();
      if (trend === 'increasing') {
        this.performGradualCleanup();
      }
    }, 30000); // 每30秒检查一次
  }
  
  // 注册清理回调
  registerCleanupCallback(callback: () => void): void {
    this.cleanupCallbacks.push(callback);
  }
  
  // 执行清理
  performCleanup(): void {
    console.log('Performing memory cleanup');
    
    // 清理缓存
    this.cleanupCaches();
    
    // 执行注册的清理回调
    this.cleanupCallbacks.forEach(callback => {
      try {
        callback();
      } catch (error) {
        console.error('Cleanup callback error:', error);
      }
    });
    
    // 强制垃圾回收（如果可用）
    this.forceGarbageCollection();
  }
  
  // 渐进式清理
  performGradualCleanup(): void {
    console.log('Performing gradual cleanup');
    
    // 清理部分缓存
    this.cleanupCaches(0.3); // 清理30%
  }
  
  // 激进清理
  performAggressiveCleanup(): void {
    console.log('Performing aggressive cleanup');
    
    // 清理大部分缓存
    this.cleanupCaches(0.8); // 清理80%
    
    // 清理对象池
    this.cleanupObjectPools();
  }
  
  private cleanupCaches(ratio: number = 1): void {
    // 这里需要访问缓存的清理方法
    // 实际实现会调用缓存管理器的清理方法
    console.log(`Cleaning up ${(ratio * 100).toFixed(0)}% of caches`);
  }
  
  private cleanupObjectPools(): void {
    // 清理对象池
    vector2Pool.clear();
    rectPool.clear();
    pointArrayPool.clear();
    
    console.log('Cleared object pools');
  }
  
  private forceGarbageCollection(): void {
    // 尝试强制垃圾回收
    if ('gc' in window) {
      (window as any).gc();
    } else if ('webkitGC' in window) {
      (window as any).webkitGC();
    }
  }
  
  // 获取清理统计
  getCleanupStats(): {
    lastCleanup: number;
    cleanupCount: number;
    memoryFreed: number;
  } {
    // 返回清理统计信息
    return {
      lastCleanup: Date.now(),
      cleanupCount: 0,
      memoryFreed: 0
    };
  }
}
```

### 内存泄漏检测器

```typescript
class MemoryLeakDetector {
  private objectCounts = new Map<string, number>();
  private intervalId: number | null = null;
  
  startDetection(): void {
    if (this.intervalId) return;
    
    this.intervalId = window.setInterval(() => {
      this.checkForLeaks();
    }, 60000); // 每分钟检查一次
  }
  
  stopDetection(): void {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }
  
  private checkForLeaks(): void {
    const currentCounts = this.getCurrentObjectCounts();
    
    for (const [type, count] of currentCounts) {
      const previousCount = this.objectCounts.get(type) || 0;
      const growth = count - previousCount;
      
      if (growth > 100) { // 如果某类对象增长超过100个
        console.warn(`Potential memory leak detected: ${type} objects increased by ${growth}`);
      }
      
      this.objectCounts.set(type, count);
    }
  }
  
  private getCurrentObjectCounts(): Map<string, number> {
    const counts = new Map<string, number>();
    
    // 计算各种对象的数量
    // 这里需要根据实际应用来实现
    counts.set('elements', this.countElements());
    counts.set('eventListeners', this.countEventListeners());
    counts.set('canvases', document.querySelectorAll('canvas').length);
    
    return counts;
  }
  
  private countElements(): number {
    // 计算当前元素数量
    return 0;
  }
  
  private countEventListeners(): number {
    // 估算事件监听器数量
    return 0;
  }
}
```

这是第10章第3节的内容，专注于内存管理与缓存。接下来我会继续创建第4节。