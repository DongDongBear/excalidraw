# 第10章：协作系统与实时同步-真实源码版

## 10.1 协作系统概览

Excalidraw的协作系统是一个精心设计的实时多用户编辑系统，支持多人同时在同一画布上进行绘制和编辑。通过分析真实源码，我们来深入理解这个复杂但高效的协作架构。

### 10.1.1 协作系统核心组件

Excalidraw的协作系统主要由以下几个核心组件构成：

1. **协作者类型定义** - 定义协作者的数据结构
2. **实时指针同步** - 同步各用户的鼠标指针位置
3. **激光笔轨迹系统** - 支持演示和指引功能
4. **用户跟踪机制** - 支持跟随其他用户的视角
5. **协作状态渲染** - 在画布上渲染协作者信息

## 10.2 协作者数据结构

### 10.2.1 核心类型定义

```typescript
// packages/excalidraw/types.ts - 协作者核心类型
export type SocketId = string & { _brand: "SocketId" };

export type Collaborator = Readonly<{
  // 指针位置信息
  pointer?: CollaboratorPointer;
  // 鼠标按键状态
  button?: "up" | "down";
  // 选中的元素ID集合
  selectedElementIds?: AppState["selectedElementIds"];
  // 用户名
  username?: string | null;
  // 用户活动状态
  userState?: UserIdleState;
  // 用户颜色主题
  color?: {
    background: string;
    stroke: string;
  };
  // 用户头像URL（如果不存在则使用用户名首字母）
  avatarUrl?: string;
  // 用户ID（用于过滤重复头像）
  id?: string;
  // Socket连接ID
  socketId?: SocketId;
  // 是否为当前用户
  isCurrentUser?: boolean;
  // 音视频通话状态
  isInCall?: boolean;
  isSpeaking?: boolean;
  isMuted?: boolean;
}>;
```

### 10.2.2 协作者指针类型

```typescript
export type CollaboratorPointer = {
  x: number;
  y: number;
  tool: "pointer" | "laser";
  /**
   * 是否渲染光标和用户名
   * 在只想渲染激光轨迹时很有用
   * @default true
   */
  renderCursor?: boolean;
  /**
   * 明确的激光颜色
   * @default 协作者的光标颜色
   */
  laserColor?: string;
};
```

### 10.2.3 用户跟踪类型

```typescript
export type UserToFollow = {
  socketId: SocketId;
  username: string;
};
```

## 10.3 AppState中的协作状态

### 10.3.1 协作相关状态属性

在AppState中，协作功能通过多个属性进行管理：

```typescript
// packages/excalidraw/types.ts - AppState中的协作状态
export interface AppState {
  // 协作者映射表（Socket ID -> 协作者信息）
  collaborators: Map<SocketId, Collaborator>;

  // 正在跟踪的用户
  userToFollow: UserToFollow | null;

  // 跟踪当前用户的用户Socket ID集合
  followedBy: Set<SocketId>;

  // 其他协作相关状态...
}
```

### 10.3.2 协作状态在不同渲染场景中的使用

协作状态在不同的渲染场景中有不同的配置：

```typescript
// packages/excalidraw/scene/types.ts - 交互式画布渲染配置
export type InteractiveCanvasRenderConfig = {
  // 远程选中的元素映射（元素ID -> Socket ID列表）
  remoteSelectedElementIds: Map<ExcalidrawElement["id"], SocketId[]>;
  
  // 远程指针的视口坐标
  remotePointerViewportCoords: Map<SocketId, { x: number; y: number }>;
  
  // 远程指针的用户状态
  remotePointerUserStates: Map<SocketId, UserIdleState>;
  
  // 远程指针的用户名
  remotePointerUsernames: Map<SocketId, string>;
  
  // 远程指针的按键状态
  remotePointerButton: Map<SocketId, string | undefined>;
  
  // 选中元素的颜色
  selectionColor: string;
  
  // 是否渲染滚动条
  renderScrollbars?: boolean;
};
```

## 10.4 激光笔轨迹系统

### 10.4.1 LaserTrails类架构

激光笔是Excalidraw协作功能的重要组成部分，用于演示和指引：

```typescript
// packages/excalidraw/laser-trails.ts - 激光轨迹系统
export class LaserTrails implements Trail {
  // 本地用户的激光轨迹
  public localTrail: AnimatedTrail;
  
  // 协作者的激光轨迹映射
  private collabTrails = new Map<SocketId, AnimatedTrail>();
  
  // SVG容器
  private container?: SVGSVGElement;

  constructor(
    private animationFrameHandler: AnimationFrameHandler,
    private app: App,
  ) {
    this.animationFrameHandler.register(this, this.onFrame.bind(this));

    // 初始化本地轨迹
    this.localTrail = new AnimatedTrail(animationFrameHandler, app, {
      ...this.getTrailOptions(),
      fill: () => DEFAULT_LASER_COLOR,
    });
  }
}
```

### 10.4.2 轨迹配置和动画

激光轨迹系统包含复杂的动画和衰减效果：

```typescript
// 轨迹配置选项
private getTrailOptions() {
  return {
    simplify: 0,
    streamline: 0.4,
    sizeMapping: (c) => {
      const DECAY_TIME = 1000;  // 衰减时间
      const DECAY_LENGTH = 50;  // 衰减长度
      
      // 基于时间的衰减
      const t = Math.max(
        0,
        1 - (performance.now() - c.pressure) / DECAY_TIME,
      );
      
      // 基于长度的衰减
      const l = (DECAY_LENGTH - 
        Math.min(DECAY_LENGTH, c.totalLength - c.currentIndex)) / DECAY_LENGTH;

      return Math.min(easeOut(l), easeOut(t));
    },
  } as Partial<LaserPointerOptions>;
}
```

### 10.4.3 协作轨迹管理

协作者的激光轨迹通过动态创建和管理实现：

```typescript
// 更新协作轨迹
private updateCollabTrails() {
  if (!this.container || this.app.state.collaborators.size === 0) {
    return;
  }

  for (const [key, collaborator] of this.app.state.collaborators.entries()) {
    let trail!: AnimatedTrail;

    // 如果协作者轨迹不存在，创建新的轨迹
    if (!this.collabTrails.has(key)) {
      trail = new AnimatedTrail(this.animationFrameHandler, this.app, {
        ...this.getTrailOptions(),
        fill: () =>
          collaborator.pointer?.laserColor ||
          getClientColor(key, collaborator),
      });
      trail.start(this.container);
      this.collabTrails.set(key, trail);
    } else {
      trail = this.collabTrails.get(key)!;
    }

    // 更新轨迹状态
    // ...轨迹更新逻辑
  }
}
```

## 10.5 协作UI组件

### 10.5.1 LiveCollaborationTrigger组件

协作触发按钮是用户启动协作的入口：

```typescript
// packages/excalidraw/components/live-collaboration/LiveCollaborationTrigger.tsx
const LiveCollaborationTrigger = ({
  isCollaborating,
  onSelect,
  ...rest
}: {
  isCollaborating: boolean;
  onSelect: () => void;
} & React.ButtonHTMLAttributes<HTMLButtonElement>) => {
  const appState = useUIAppState();

  // 根据屏幕大小决定是否只显示图标
  const showIconOnly =
    isMobileOrTablet() || appState.width < MQ_MIN_WIDTH_DESKTOP;

  return (
    <Button
      {...rest}
      className={clsx("collab-button", { active: isCollaborating })}
      type="button"
      onSelect={onSelect}
      style={{ position: "relative", width: showIconOnly ? undefined : "auto" }}
      title={t("labels.liveCollaboration")}
    >
      {showIconOnly ? share : t("labels.share")}
      
      {/* 显示当前协作者数量 */}
      {appState.collaborators.size > 0 && (
        <div className="CollabButton-collaborators">
          {appState.collaborators.size}
        </div>
      )}
    </Button>
  );
};
```

## 10.6 协作状态同步机制

### 10.6.1 协作者状态更新

虽然具体的WebSocket实现在主应用中，但我们可以从类型定义中理解状态同步的数据结构：

```typescript
// 协作者状态更新的数据结构示例
interface CollaboratorUpdate {
  socketId: SocketId;
  pointer?: {
    x: number;
    y: number;
    tool: "pointer" | "laser";
  };
  selectedElementIds?: string[];
  userState?: UserIdleState;
  username?: string;
}

// 协作者状态同步处理
const handleCollaboratorUpdate = (
  appState: AppState,
  update: CollaboratorUpdate
): AppState => {
  const newCollaborators = new Map(appState.collaborators);
  
  const existingCollaborator = newCollaborators.get(update.socketId);
  const updatedCollaborator: Collaborator = {
    ...existingCollaborator,
    socketId: update.socketId,
    pointer: update.pointer,
    selectedElementIds: update.selectedElementIds ? 
      arrayToMap(update.selectedElementIds) : 
      existingCollaborator?.selectedElementIds,
    userState: update.userState ?? existingCollaborator?.userState,
    username: update.username ?? existingCollaborator?.username,
  };

  newCollaborators.set(update.socketId, updatedCollaborator);

  return {
    ...appState,
    collaborators: newCollaborators,
  };
};
```

### 10.6.2 元素选择状态同步

协作中的元素选择状态需要特殊处理：

```typescript
// 远程选择状态构建
const buildRemoteSelectedElementIds = (
  collaborators: Map<SocketId, Collaborator>
): Map<ExcalidrawElement["id"], SocketId[]> => {
  const remoteSelected = new Map<ExcalidrawElement["id"], SocketId[]>();

  for (const [socketId, collaborator] of collaborators) {
    if (collaborator.selectedElementIds) {
      for (const elementId of Object.keys(collaborator.selectedElementIds)) {
        if (!remoteSelected.has(elementId)) {
          remoteSelected.set(elementId, []);
        }
        remoteSelected.get(elementId)!.push(socketId);
      }
    }
  }

  return remoteSelected;
};
```

## 10.7 用户跟踪功能

### 10.7.1 跟踪状态管理

用户可以选择跟踪其他协作者的视角：

```typescript
// 开始跟踪用户
const startFollowingUser = (
  appState: AppState,
  userToFollow: UserToFollow
): AppState => {
  return {
    ...appState,
    userToFollow,
    // 跟踪时通常需要调整视角
    scrollX: 0, // 将根据被跟踪用户的位置计算
    scrollY: 0,
  };
};

// 停止跟踪用户
const stopFollowingUser = (appState: AppState): AppState => {
  return {
    ...appState,
    userToFollow: null,
  };
};

// 处理被跟踪状态
const handleBeingFollowed = (
  appState: AppState,
  followerSocketId: SocketId,
  isFollowing: boolean
): AppState => {
  const newFollowedBy = new Set(appState.followedBy);
  
  if (isFollowing) {
    newFollowedBy.add(followerSocketId);
  } else {
    newFollowedBy.delete(followerSocketId);
  }

  return {
    ...appState,
    followedBy: newFollowedBy,
  };
};
```

### 10.7.2 视角同步逻辑

跟踪功能需要同步视角状态：

```typescript
// 同步被跟踪用户的视角
const syncViewportToFollowedUser = (
  appState: AppState,
  followedUserViewport: { scrollX: number; scrollY: number; zoom: number }
): AppState => {
  if (!appState.userToFollow) {
    return appState;
  }

  return {
    ...appState,
    scrollX: followedUserViewport.scrollX,
    scrollY: followedUserViewport.scrollY,
    zoom: { value: followedUserViewport.zoom as NormalizedZoomValue },
  };
};
```

## 10.8 协作渲染系统

### 10.8.1 协作者指针渲染

协作者的指针需要在画布上实时渲染：

```typescript
// 渲染协作者指针
const renderCollaboratorPointers = (
  context: CanvasRenderingContext2D,
  appState: AppState,
  collaborators: Map<SocketId, Collaborator>
) => {
  for (const [socketId, collaborator] of collaborators) {
    if (!collaborator.pointer || collaborator.isCurrentUser) {
      continue;
    }

    const { x, y } = collaborator.pointer;
    const color = getClientColor(socketId, collaborator);

    // 渲染指针光标
    renderCursor(context, x, y, color, collaborator.username);

    // 如果有用户名，渲染用户名标签
    if (collaborator.username && collaborator.pointer.renderCursor !== false) {
      renderUsernameLabel(context, x, y, collaborator.username, color);
    }
  }
};

// 渲染光标
const renderCursor = (
  context: CanvasRenderingContext2D,
  x: number,
  y: number,
  color: string,
  username?: string | null
) => {
  context.save();
  context.translate(x, y);
  
  // 绘制光标形状
  context.fillStyle = color;
  context.beginPath();
  context.moveTo(0, 0);
  context.lineTo(0, 16);
  context.lineTo(4, 12);
  context.lineTo(8, 16);
  context.lineTo(12, 12);
  context.lineTo(8, 8);
  context.closePath();
  context.fill();
  
  context.restore();
};
```

### 10.8.2 选择状态可视化

协作者的选择状态需要特殊的视觉反馈：

```typescript
// 渲染远程选择状态
const renderRemoteSelections = (
  context: CanvasRenderingContext2D,
  elements: readonly ExcalidrawElement[],
  remoteSelectedElementIds: Map<ExcalidrawElement["id"], SocketId[]>,
  collaborators: Map<SocketId, Collaborator>
) => {
  for (const element of elements) {
    const remoteSelectorIds = remoteSelectedElementIds.get(element.id);
    if (!remoteSelectorIds) continue;

    // 为每个远程选择者渲染选择框
    for (const socketId of remoteSelectorIds) {
      const collaborator = collaborators.get(socketId);
      if (!collaborator) continue;

      const color = getClientColor(socketId, collaborator);
      renderElementSelection(context, element, color, /* remote */ true);
    }
  }
};
```

## 10.9 性能优化策略

### 10.9.1 协作数据节流

频繁的协作数据更新需要节流处理：

```typescript
// 协作者状态更新节流
const throttledCollaboratorUpdate = throttle((
  socketId: SocketId,
  update: Partial<Collaborator>
) => {
  // 发送协作者状态更新
  sendCollaboratorUpdate(socketId, update);
}, 50); // 50ms节流

// 指针位置更新节流
const throttledPointerUpdate = throttle((
  pointer: CollaboratorPointer
) => {
  throttledCollaboratorUpdate(currentSocketId, { pointer });
}, 16); // ~60fps
```

### 10.9.2 协作者列表优化

大量协作者时的性能优化：

```typescript
// 优化的协作者列表渲染
const OptimizedCollaboratorList = ({ collaborators }: {
  collaborators: Map<SocketId, Collaborator>
}) => {
  // 只渲染活跃的协作者
  const activeCollaborators = useMemo(() => {
    return Array.from(collaborators.values()).filter(
      collaborator => 
        collaborator.userState === UserIdleState.ACTIVE &&
        !collaborator.isCurrentUser
    );
  }, [collaborators]);

  // 限制显示的协作者数量
  const displayedCollaborators = activeCollaborators.slice(0, 10);

  return (
    <div className="collaborator-list">
      {displayedCollaborators.map(collaborator => (
        <CollaboratorAvatar 
          key={collaborator.socketId} 
          collaborator={collaborator} 
        />
      ))}
      {activeCollaborators.length > 10 && (
        <div className="more-collaborators">
          +{activeCollaborators.length - 10}
        </div>
      )}
    </div>
  );
};
```

## 10.10 协作安全考虑

### 10.10.1 数据验证

协作数据需要严格的验证：

```typescript
// 协作者数据验证
const validateCollaboratorUpdate = (
  update: any
): update is CollaboratorUpdate => {
  if (!update.socketId || typeof update.socketId !== 'string') {
    return false;
  }

  if (update.pointer) {
    if (typeof update.pointer.x !== 'number' || 
        typeof update.pointer.y !== 'number') {
      return false;
    }
    if (!['pointer', 'laser'].includes(update.pointer.tool)) {
      return false;
    }
  }

  if (update.selectedElementIds && !Array.isArray(update.selectedElementIds)) {
    return false;
  }

  return true;
};
```

### 10.10.2 权限控制

协作功能需要适当的权限控制：

```typescript
// 协作权限检查
const hasCollaborationPermission = (
  user: User,
  room: CollaborationRoom
): boolean => {
  // 检查用户是否有协作权限
  return room.participants.includes(user.id) ||
         room.owner === user.id ||
         room.isPublic;
};

// 操作权限检查
const canPerformAction = (
  user: User,
  action: string,
  room: CollaborationRoom
): boolean => {
  if (room.owner === user.id) return true;
  
  const userRole = room.participants.find(p => p.userId === user.id)?.role;
  
  switch (action) {
    case 'edit':
      return userRole === 'editor' || userRole === 'owner';
    case 'view':
      return true; // 所有参与者都可以查看
    case 'manage':
      return userRole === 'owner';
    default:
      return false;
  }
};
```

## 10.11 实际应用示例

### 10.11.1 基本协作集成

```typescript
// 协作功能的基本集成示例
const CollaborativeExcalidraw = () => {
  const [collaborators, setCollaborators] = useState<Map<SocketId, Collaborator>>(new Map());
  const [socket, setSocket] = useState<WebSocket | null>(null);

  // 初始化WebSocket连接
  useEffect(() => {
    const ws = new WebSocket('ws://localhost:8080/collaborate');
    
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      
      switch (data.type) {
        case 'collaborator-update':
          handleCollaboratorUpdate(data.payload);
          break;
        case 'collaborator-left':
          handleCollaboratorLeft(data.socketId);
          break;
      }
    };

    setSocket(ws);
    return () => ws.close();
  }, []);

  const handleCollaboratorUpdate = (update: CollaboratorUpdate) => {
    setCollaborators(prev => {
      const newMap = new Map(prev);
      const existing = newMap.get(update.socketId);
      newMap.set(update.socketId, { ...existing, ...update });
      return newMap;
    });
  };

  const handlePointerMove = (pointer: CollaboratorPointer) => {
    if (socket) {
      socket.send(JSON.stringify({
        type: 'pointer-update',
        payload: pointer
      }));
    }
  };

  return (
    <Excalidraw
      initialData={{
        collaborators,
      }}
      onPointerMove={(pointer) => handlePointerMove(pointer)}
    />
  );
};
```

### 10.11.2 激光笔演示功能

```typescript
// 激光笔演示功能示例
const LaserPresentationMode = ({ excalidrawAPI }: {
  excalidrawAPI: ExcalidrawImperativeAPI
}) => {
  const [isPresentationMode, setIsPresentationMode] = useState(false);

  const startPresentation = () => {
    // 切换到激光笔工具
    excalidrawAPI.setActiveTool({ type: "laser" });
    setIsPresentationMode(true);
    
    // 广播演示开始事件
    broadcastPresentationStart();
  };

  const stopPresentation = () => {
    // 切换回选择工具
    excalidrawAPI.setActiveTool({ type: "selection" });
    setIsPresentationMode(false);
    
    // 广播演示结束事件
    broadcastPresentationEnd();
  };

  return (
    <div className="presentation-controls">
      <button 
        onClick={isPresentationMode ? stopPresentation : startPresentation}
        className={isPresentationMode ? "active" : ""}
      >
        {isPresentationMode ? "结束演示" : "开始演示"}
      </button>
    </div>
  );
};
```

## 10.12 总结

Excalidraw的协作系统展现了以下优秀特点：

### 10.12.1 设计优势

1. **实时性**：高效的实时数据同步机制
2. **可扩展性**：支持大量协作者的系统架构
3. **用户体验**：丰富的协作可视化反馈
4. **性能优化**：多层次的性能优化策略
5. **安全性**：完善的数据验证和权限控制

### 10.12.2 关键学习点

1. **数据结构设计**：如何设计高效的协作者数据结构
2. **实时同步策略**：协作状态的同步机制和优化
3. **UI交互设计**：协作功能的用户界面设计
4. **性能优化**：大规模协作的性能优化技巧
5. **系统架构**：可扩展的协作系统架构设计

通过深入分析Excalidraw的协作系统，我们可以学习到如何构建一个高效、稳定且用户友好的实时协作系统。这些设计模式和实现策略对于开发任何需要多用户实时协作功能的应用都具有重要的参考价值。