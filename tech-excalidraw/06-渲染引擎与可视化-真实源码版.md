# 第六章：渲染引擎与可视化（基于真实Excalidraw源码）

## 6.1 真实的渲染架构分析

通过深入分析Excalidraw的真实源码，我们发现其渲染系统采用了分层的、性能优化的架构设计。让我们从实际代码出发，理解这个成熟的渲染引擎。

### 6.1.1 渲染器分层架构

```typescript
// 基于 packages/excalidraw/renderer/ 的真实架构

// 1. 静态场景渲染器 - staticScene.ts
// 用于导出、预览等静态渲染场景
export const renderStaticScene = (
  renderConfig: StaticSceneRenderConfig
) => {
  const { canvas, elements, appState, scale } = renderConfig;
  
  // 初始化画布
  const context = bootstrapCanvas({
    canvas,
    scale,
    normalizedWidth,
    normalizedHeight,
    theme: appState.theme,
    isExporting: renderConfig.isExporting,
    viewBackgroundColor: appState.viewBackgroundColor,
  });
  
  // 应用变换
  context.scale(appState.zoom.value, appState.zoom.value);
  
  // 渲染网格
  if (renderConfig.renderGrid) {
    strokeGrid(context, appState.gridSize, appState.gridStep, ...);
  }
  
  // 渲染可见元素
  visibleElements
    .filter(el => !isIframeLikeElement(el))
    .forEach(element => {
      // 处理框架裁剪
      if (shouldApplyFrameClip(element, frame, appState)) {
        frameClip(frame, context, renderConfig, appState);
      }
      
      // 渲染元素
      renderElement(element, elementsMap, allElementsMap, rc, context, renderConfig, appState);
    });
};

// 2. 交互式场景渲染器 - interactiveScene.ts  
// 用于实时交互、选择、拖拽等动态场景
export const renderInteractiveScene = (
  renderConfig: InteractiveCanvasRenderConfig
) => {
  const { canvas, elements, appState, scale, rc } = renderConfig;
  
  // 渲染选择框
  if (appState.selectionElement) {
    renderSelectionElement(appState.selectionElement, context, appState);
  }
  
  // 渲染变换句柄
  if (selectedElements.length > 0) {
    renderTransformHandles(selectedElements, context, appState);
  }
  
  // 渲染绑定指示器
  if (appState.suggestedBindings.length > 0) {
    renderBindingHighlight(appState.suggestedBindings, context);
  }
  
  // 渲染吸附线
  if (appState.snapLines.length > 0) {
    renderSnapLines(appState.snapLines, context, appState);
  }
  
  // 渲染协作光标
  renderCollaborators(appState.collaborators, context, appState);
};

// 3. SVG场景渲染器 - staticSvgScene.ts
// 用于SVG导出
export const renderStaticSvgScene = (
  renderConfig: StaticSvgRenderConfig
): SVGSVGElement => {
  const svg = document.createElementNS(SVG_NS, "svg");
  
  // 设置SVG属性
  svg.setAttribute("width", width.toString());
  svg.setAttribute("height", height.toString());
  
  // 渲染元素到SVG
  elements.forEach(element => {
    const svgElement = renderElementToSvg(element, renderConfig);
    if (svgElement) {
      svg.appendChild(svgElement);
    }
  });
  
  return svg;
};
```

### 6.1.2 画布初始化和管理

```typescript
// 基于 packages/excalidraw/renderer/helpers.ts 的真实实现

export const bootstrapCanvas = ({
  canvas,
  scale,
  normalizedWidth,
  normalizedHeight,
  theme,
  isExporting = false,
  viewBackgroundColor,
}: {
  canvas: HTMLCanvasElement;
  scale: number;
  normalizedWidth: number;
  normalizedHeight: number;
  theme: Theme;
  isExporting?: boolean;
  viewBackgroundColor: string;
}): CanvasRenderingContext2D => {
  const context = canvas.getContext("2d")!;
  
  // 设置画布尺寸
  canvas.width = normalizedWidth;
  canvas.height = normalizedHeight;
  
  // 应用DPI缩放
  context.scale(scale, scale);
  
  // 设置背景
  if (isExporting || viewBackgroundColor !== "transparent") {
    context.save();
    context.fillStyle = viewBackgroundColor;
    context.fillRect(0, 0, normalizedWidth / scale, normalizedHeight / scale);
    context.restore();
  }
  
  // 设置默认样式
  context.lineJoin = "round";
  context.lineCap = "round";
  
  // 设置图像平滑
  context.imageSmoothingEnabled = true;
  context.imageSmoothingQuality = "high";
  
  return context;
};

// 获取标准化画布尺寸
export const getNormalizedCanvasDimensions = (
  canvas: HTMLCanvasElement,
  scale: number
): [number, number] => {
  // 考虑设备像素比例
  const dpr = window.devicePixelRatio || 1;
  const baseWidth = canvas.clientWidth || canvas.width;
  const baseHeight = canvas.clientHeight || canvas.height;
  
  return [
    Math.floor(baseWidth * scale * dpr),
    Math.floor(baseHeight * scale * dpr),
  ];
};
```

### 6.1.3 网格渲染系统

```typescript
// 基于真实源码的网格渲染实现

const GridLineColor = {
  Bold: "#dddddd",
  Regular: "#e5e5e5",
} as const;

const strokeGrid = (
  context: CanvasRenderingContext2D,
  gridSize: number,
  gridStep: number,
  scrollX: number,
  scrollY: number,
  zoom: Zoom,
  width: number,
  height: number
): void => {
  if (gridSize <= 0) return;
  
  context.save();
  context.strokeStyle = GridLineColor.Regular;
  context.lineWidth = 1 / zoom.value;
  
  const actualGridSize = gridSize * zoom.value;
  
  // 计算可见网格范围
  const startX = Math.floor((scrollX * zoom.value) / actualGridSize) * actualGridSize;
  const startY = Math.floor((scrollY * zoom.value) / actualGridSize) * actualGridSize;
  const endX = startX + width + actualGridSize;
  const endY = startY + height + actualGridSize;
  
  // 绘制垂直线
  for (let x = startX; x <= endX; x += actualGridSize) {
    const worldX = x / zoom.value;
    const shouldDrawBold = gridStep > 1 && 
      Math.round(worldX / gridSize) % gridStep === 0;
    
    if (shouldDrawBold) {
      context.save();
      context.strokeStyle = GridLineColor.Bold;
      context.lineWidth = 2 / zoom.value;
    }
    
    context.beginPath();
    context.moveTo(worldX, scrollY);
    context.lineTo(worldX, scrollY + height / zoom.value);
    context.stroke();
    
    if (shouldDrawBold) {
      context.restore();
    }
  }
  
  // 绘制水平线
  for (let y = startY; y <= endY; y += actualGridSize) {
    const worldY = y / zoom.value;
    const shouldDrawBold = gridStep > 1 && 
      Math.round(worldY / gridSize) % gridStep === 0;
    
    if (shouldDrawBold) {
      context.save();
      context.strokeStyle = GridLineColor.Bold;
      context.lineWidth = 2 / zoom.value;
    }
    
    context.beginPath();
    context.moveTo(scrollX, worldY);
    context.lineTo(scrollX + width / zoom.value, worldY);
    context.stroke();
    
    if (shouldDrawBold) {
      context.restore();
    }
  }
  
  context.restore();
};
```

## 6.2 视口变换系统

### 6.2.1 坐标系统和变换矩阵

```typescript
// 基于真实Excalidraw的坐标转换系统

interface ViewportTransform {
  scrollX: number;
  scrollY: number;
  zoom: NormalizedZoomValue;
}

class ViewportManager {
  // 屏幕坐标转世界坐标
  static screenToWorld(
    screenCoords: { x: number; y: number },
    transform: ViewportTransform
  ): { x: number; y: number } {
    return {
      x: screenCoords.x / transform.zoom + transform.scrollX,
      y: screenCoords.y / transform.zoom + transform.scrollY,
    };
  }
  
  // 世界坐标转屏幕坐标
  static worldToScreen(
    worldCoords: { x: number; y: number },
    transform: ViewportTransform
  ): { x: number; y: number } {
    return {
      x: (worldCoords.x - transform.scrollX) * transform.zoom,
      y: (worldCoords.y - transform.scrollY) * transform.zoom,
    };
  }
  
  // 应用视口变换到画布上下文
  static applyViewportTransform(
    context: CanvasRenderingContext2D,
    transform: ViewportTransform
  ): void {
    context.translate(-transform.scrollX, -transform.scrollY);
    context.scale(transform.zoom, transform.zoom);
  }
  
  // 计算可见区域边界
  static getVisibleBounds(
    canvasWidth: number,
    canvasHeight: number,
    transform: ViewportTransform
  ): {
    minX: number;
    minY: number;
    maxX: number;
    maxY: number;
  } {
    const topLeft = this.screenToWorld({ x: 0, y: 0 }, transform);
    const bottomRight = this.screenToWorld(
      { x: canvasWidth, y: canvasHeight },
      transform
    );
    
    return {
      minX: topLeft.x,
      minY: topLeft.y,
      maxX: bottomRight.x,
      maxY: bottomRight.y,
    };
  }
  
  // 视口边界检测（用于剔除不可见元素）
  static isElementVisible(
    element: ExcalidrawElement,
    canvasWidth: number,
    canvasHeight: number,
    transform: ViewportTransform,
    margin = 100 // 额外边距，确保即将进入视口的元素也被渲染
  ): boolean {
    const bounds = this.getVisibleBounds(canvasWidth, canvasHeight, transform);
    const [elMinX, elMinY, elMaxX, elMaxY] = getElementAbsoluteCoords(element);
    
    return !(
      elMaxX < bounds.minX - margin ||
      elMinX > bounds.maxX + margin ||
      elMaxY < bounds.minY - margin ||
      elMinY > bounds.maxY + margin
    );
  }
}
```

### 6.2.2 缩放和滚动管理

```typescript
// 基于真实实现的缩放管理系统

export const normalizeZoom = (zoom: number): NormalizedZoomValue => {
  const MIN_ZOOM = 0.1 as NormalizedZoomValue;
  const MAX_ZOOM = 30 as NormalizedZoomValue;
  
  return Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, zoom)) as NormalizedZoomValue;
};

export const getNewZoom = (
  currentZoom: NormalizedZoomValue,
  direction: "in" | "out",
  canvasElement: HTMLCanvasElement,
  pointerCoords?: { x: number; y: number }
): {
  zoom: NormalizedZoomValue;
  scrollX?: number;
  scrollY?: number;
} => {
  const ZOOM_STEP = 0.1;
  const MAX_STEP = 0.5;
  
  // 计算新的缩放值
  let newZoom: number;
  if (direction === "in") {
    const step = Math.min(MAX_STEP, currentZoom * ZOOM_STEP);
    newZoom = currentZoom + step;
  } else {
    const step = Math.min(MAX_STEP, currentZoom * ZOOM_STEP);
    newZoom = currentZoom - step;
  }
  
  newZoom = normalizeZoom(newZoom);
  
  // 如果有指针坐标，计算以指针为中心的缩放
  if (pointerCoords) {
    const rect = canvasElement.getBoundingClientRect();
    const centerX = pointerCoords.x - rect.left;
    const centerY = pointerCoords.y - rect.top;
    
    // 计算缩放后的滚动偏移
    const zoomRatio = newZoom / currentZoom;
    const scrollX = centerX - (centerX * zoomRatio);
    const scrollY = centerY - (centerY * zoomRatio);
    
    return {
      zoom: newZoom,
      scrollX,
      scrollY,
    };
  }
  
  return { zoom: newZoom };
};

// 平滑缩放动画
export class SmoothZoomManager {
  private animationId: number | null = null;
  private startTime: number = 0;
  private duration = 150; // 动画持续时间(ms)
  
  private startZoom: number = 1;
  private targetZoom: number = 1;
  private startScrollX: number = 0;
  private startScrollY: number = 0;
  private targetScrollX: number = 0;
  private targetScrollY: number = 0;
  
  animateZoom(
    from: {
      zoom: NormalizedZoomValue;
      scrollX: number;
      scrollY: number;
    },
    to: {
      zoom: NormalizedZoomValue;
      scrollX?: number;
      scrollY?: number;
    },
    onUpdate: (state: {
      zoom: NormalizedZoomValue;
      scrollX: number;
      scrollY: number;
    }) => void,
    onComplete?: () => void
  ): void {
    // 取消之前的动画
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }
    
    this.startTime = performance.now();
    this.startZoom = from.zoom;
    this.targetZoom = to.zoom;
    this.startScrollX = from.scrollX;
    this.startScrollY = from.scrollY;
    this.targetScrollX = to.scrollX ?? from.scrollX;
    this.targetScrollY = to.scrollY ?? from.scrollY;
    
    const animate = (currentTime: number) => {
      const elapsed = currentTime - this.startTime;
      const progress = Math.min(elapsed / this.duration, 1);
      
      // 使用缓动函数
      const eased = this.easeOutCubic(progress);
      
      // 插值计算
      const currentZoom = normalizeZoom(
        this.startZoom + (this.targetZoom - this.startZoom) * eased
      );
      const currentScrollX = this.startScrollX + 
        (this.targetScrollX - this.startScrollX) * eased;
      const currentScrollY = this.startScrollY + 
        (this.targetScrollY - this.startScrollY) * eased;
      
      onUpdate({
        zoom: currentZoom,
        scrollX: currentScrollX,
        scrollY: currentScrollY,
      });
      
      if (progress < 1) {
        this.animationId = requestAnimationFrame(animate);
      } else {
        this.animationId = null;
        onComplete?.();
      }
    };
    
    this.animationId = requestAnimationFrame(animate);
  }
  
  private easeOutCubic(t: number): number {
    return 1 - Math.pow(1 - t, 3);
  }
  
  cancel(): void {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
  }
}
```

## 6.3 框架裁剪系统

### 6.3.1 框架裁剪的真实实现

```typescript
// 基于 packages/excalidraw/renderer/staticScene.ts 的框架裁剪

const frameClip = (
  frame: ExcalidrawFrameLikeElement,
  context: CanvasRenderingContext2D,
  renderConfig: StaticCanvasRenderConfig,
  appState: StaticCanvasAppState
) => {
  const { x, y, width, height } = frame;
  
  context.save();
  context.beginPath();
  
  if (frame.roundness?.type === ROUNDNESS.PROPORTIONAL_RADIUS) {
    // 圆角框架裁剪
    const radius = frame.roundness.value || 0;
    roundRect(context, x, y, width, height, radius);
  } else {
    // 矩形框架裁剪
    context.rect(x, y, width, height);
  }
  
  context.clip();
};

// 检查元素是否应该应用框架裁剪
export const shouldApplyFrameClip = (
  element: ExcalidrawElement,
  frame: ExcalidrawFrameLikeElement,
  appState: StaticCanvasAppState,
  elementsMap: ElementsMap,
  inFrameGroupsMap: Map<string, boolean>
): boolean => {
  // 框架本身不裁剪
  if (element.id === frame.id) {
    return false;
  }
  
  // 检查元素是否在框架内
  if (element.frameId === frame.id) {
    return true;
  }
  
  // 检查群组是否在框架内
  if (element.groupIds.length > 0) {
    const isGroupInFrame = element.groupIds.some(groupId => {
      const cached = inFrameGroupsMap.get(groupId);
      if (cached !== undefined) {
        return cached;
      }
      
      // 检查群组中的其他元素
      const groupElements = getElementsInGroup(elementsMap, groupId);
      const result = groupElements.some(el => 
        el.frameId === frame.id || 
        elementOverlapsWithFrame(el, frame, elementsMap)
      );
      
      inFrameGroupsMap.set(groupId, result);
      return result;
    });
    
    return isGroupInFrame;
  }
  
  return false;
};

// 检查元素是否与框架重叠
export const elementOverlapsWithFrame = (
  element: ExcalidrawElement,
  frame: ExcalidrawFrameLikeElement,
  elementsMap: ElementsMap
): boolean => {
  const [elX1, elY1, elX2, elY2] = getElementAbsoluteCoords(element);
  const [frameX1, frameY1, frameX2, frameY2] = getElementAbsoluteCoords(frame);
  
  // 边界框相交检测
  return !(
    elX2 < frameX1 ||
    elX1 > frameX2 ||
    elY2 < frameY1 ||
    elY1 > frameY2
  );
};
```

## 6.4 性能优化渲染

### 6.4.1 可见性剔除

```typescript
// 基于真实源码的可见性剔除实现

export const getVisibleElements = (
  elements: readonly ExcalidrawElement[],
  canvasWidth: number,
  canvasHeight: number,
  appState: {
    scrollX: number;
    scrollY: number;
    zoom: { value: NormalizedZoomValue };
  }
): ExcalidrawElement[] => {
  // 计算可见区域
  const viewBounds = ViewportManager.getVisibleBounds(
    canvasWidth,
    canvasHeight,
    {
      scrollX: appState.scrollX,
      scrollY: appState.scrollY,
      zoom: appState.zoom.value,
    }
  );
  
  return elements.filter(element => {
    if (element.isDeleted) {
      return false;
    }
    
    // 始终包含选中的元素
    if (appState.selectedElementIds?.[element.id]) {
      return true;
    }
    
    // 可见性检测
    const [minX, minY, maxX, maxY] = getElementAbsoluteCoords(element);
    
    // 添加一些边距以确保部分可见的元素也被包含
    const MARGIN = 50;
    
    return !(
      maxX < viewBounds.minX - MARGIN ||
      minX > viewBounds.maxX + MARGIN ||
      maxY < viewBounds.minY - MARGIN ||
      minY > viewBounds.maxY + MARGIN
    );
  });
};
```

### 6.4.2 分批渲染系统

```typescript
// 基于性能考虑的分批渲染实现

class BatchRenderer {
  private renderQueue: ExcalidrawElement[] = [];
  private isRendering = false;
  private frameId: number | null = null;
  
  private maxElementsPerFrame = 50; // 每帧最多渲染的元素数
  private targetFrameTime = 16; // 目标帧时间 (60fps)
  
  constructor(
    private canvas: HTMLCanvasElement,
    private appState: StaticCanvasAppState
  ) {}
  
  // 添加元素到渲染队列
  queueElements(elements: ExcalidrawElement[]): void {
    this.renderQueue.push(...elements);
    this.scheduleRender();
  }
  
  // 调度渲染
  private scheduleRender(): void {
    if (this.isRendering || this.frameId !== null) {
      return;
    }
    
    this.frameId = requestAnimationFrame(() => {
      this.renderBatch();
    });
  }
  
  // 分批渲染
  private renderBatch(): void {
    this.frameId = null;
    
    if (this.renderQueue.length === 0) {
      this.isRendering = false;
      return;
    }
    
    this.isRendering = true;
    const startTime = performance.now();
    
    const context = this.canvas.getContext("2d")!;
    const rc = rough.canvas(this.canvas);
    
    let renderedCount = 0;
    
    while (
      this.renderQueue.length > 0 && 
      renderedCount < this.maxElementsPerFrame &&
      (performance.now() - startTime) < this.targetFrameTime
    ) {
      const element = this.renderQueue.shift()!;
      
      try {
        renderElement(
          element,
          new Map(), // elementsMap - 在实际应用中需要提供
          new Map(), // allElementsMap
          rc,
          context,
          { isExporting: false, renderGrid: false },
          this.appState
        );
        renderedCount++;
      } catch (error) {
        console.error('Error rendering element:', error);
      }
    }
    
    // 如果还有元素需要渲染，继续下一帧
    if (this.renderQueue.length > 0) {
      this.scheduleRender();
    } else {
      this.isRendering = false;
    }
  }
  
  // 清空渲染队列
  clear(): void {
    this.renderQueue.length = 0;
    if (this.frameId !== null) {
      cancelAnimationFrame(this.frameId);
      this.frameId = null;
    }
    this.isRendering = false;
  }
  
  // 获取渲染状态
  getStatus(): {
    queueLength: number;
    isRendering: boolean;
  } {
    return {
      queueLength: this.renderQueue.length,
      isRendering: this.isRendering,
    };
  }
}
```

### 6.4.3 渲染缓存系统

```typescript
// 基于真实需求的渲染缓存实现

interface RenderCache {
  canvas: OffscreenCanvas;
  version: number;
  bounds: readonly [number, number, number, number];
  timestamp: number;
}

class RenderCacheManager {
  private cache = new Map<string, RenderCache>();
  private maxCacheSize = 100;
  private maxCacheAge = 60000; // 1分钟
  
  // 获取元素的渲染缓存
  getCache(
    element: ExcalidrawElement,
    transform: ViewportTransform
  ): RenderCache | null {
    const cacheKey = this.getCacheKey(element, transform);
    const cached = this.cache.get(cacheKey);
    
    if (!cached) {
      return null;
    }
    
    // 检查版本和时效性
    if (
      cached.version !== element.version ||
      Date.now() - cached.timestamp > this.maxCacheAge
    ) {
      this.cache.delete(cacheKey);
      return null;
    }
    
    // 更新访问时间
    cached.timestamp = Date.now();
    return cached;
  }
  
  // 创建并缓存渲染结果
  setCache(
    element: ExcalidrawElement,
    transform: ViewportTransform,
    renderFn: (context: CanvasRenderingContext2D) => void
  ): RenderCache {
    // 清理过期缓存
    this.cleanup();
    
    // 如果缓存已满，删除最旧的
    if (this.cache.size >= this.maxCacheSize) {
      this.evictOldest();
    }
    
    // 计算元素边界
    const bounds = getElementAbsoluteCoords(element);
    const width = Math.ceil(bounds[2] - bounds[0]);
    const height = Math.ceil(bounds[3] - bounds[1]);
    
    // 创建离屏画布
    const canvas = new OffscreenCanvas(width, height);
    const context = canvas.getContext("2d")!;
    
    // 调整坐标系统到缓存画布
    context.translate(-bounds[0], -bounds[1]);
    
    // 执行渲染
    renderFn(context);
    
    const cache: RenderCache = {
      canvas,
      version: element.version,
      bounds,
      timestamp: Date.now(),
    };
    
    const cacheKey = this.getCacheKey(element, transform);
    this.cache.set(cacheKey, cache);
    
    return cache;
  }
  
  // 使用缓存渲染到目标画布
  renderFromCache(
    targetContext: CanvasRenderingContext2D,
    cache: RenderCache
  ): void {
    const [x, y] = cache.bounds;
    targetContext.drawImage(cache.canvas, x, y);
  }
  
  // 生成缓存键
  private getCacheKey(
    element: ExcalidrawElement,
    transform: ViewportTransform
  ): string {
    // 简化的缓存键生成，实际实现可能更复杂
    const zoomLevel = Math.round(transform.zoom * 10) / 10; // 量化缩放级别
    return `${element.id}-${element.version}-${zoomLevel}`;
  }
  
  // 清理过期缓存
  private cleanup(): void {
    const now = Date.now();
    for (const [key, cache] of this.cache) {
      if (now - cache.timestamp > this.maxCacheAge) {
        this.cache.delete(key);
      }
    }
  }
  
  // 删除最旧的缓存
  private evictOldest(): void {
    let oldestKey = '';
    let oldestTime = Date.now();
    
    for (const [key, cache] of this.cache) {
      if (cache.timestamp < oldestTime) {
        oldestTime = cache.timestamp;
        oldestKey = key;
      }
    }
    
    if (oldestKey) {
      this.cache.delete(oldestKey);
    }
  }
  
  // 使元素缓存失效
  invalidateElement(elementId: string): void {
    for (const [key] of this.cache) {
      if (key.startsWith(elementId)) {
        this.cache.delete(key);
      }
    }
  }
  
  // 清空所有缓存
  clear(): void {
    this.cache.clear();
  }
  
  // 获取缓存统计信息
  getStats(): {
    size: number;
    maxSize: number;
    memoryUsage: number;
  } {
    let memoryUsage = 0;
    
    for (const cache of this.cache.values()) {
      memoryUsage += cache.canvas.width * cache.canvas.height * 4; // RGBA
    }
    
    return {
      size: this.cache.size,
      maxSize: this.maxCacheSize,
      memoryUsage: memoryUsage / (1024 * 1024), // MB
    };
  }
}
```

## 6.5 实践项目：完整的渲染引擎

基于真实的Excalidraw渲染架构，让我们实现一个完整的渲染引擎：

```typescript
// 完整的渲染引擎实现
class ExcalidrawRenderEngine {
  private canvas: HTMLCanvasElement;
  private context: CanvasRenderingContext2D;
  private roughCanvas: RoughCanvas;
  
  private batchRenderer: BatchRenderer;
  private cacheManager: RenderCacheManager;
  private zoomManager: SmoothZoomManager;
  
  private isRendering = false;
  private pendingRender = false;
  
  constructor(canvas: HTMLCanvasElement) {
    this.canvas = canvas;
    this.context = canvas.getContext("2d")!;
    this.roughCanvas = rough.canvas(canvas);
    
    this.batchRenderer = new BatchRenderer(canvas);
    this.cacheManager = new RenderCacheManager();
    this.zoomManager = new SmoothZoomManager();
  }
  
  // 主渲染方法
  async render(
    elements: readonly ExcalidrawElement[],
    appState: StaticCanvasAppState,
    options: {
      isExporting?: boolean;
      renderGrid?: boolean;
      renderBackground?: boolean;
    } = {}
  ): Promise<void> {
    if (this.isRendering) {
      this.pendingRender = true;
      return;
    }
    
    this.isRendering = true;
    
    try {
      // 初始化画布
      this.initializeCanvas(appState, options);
      
      // 应用视口变换
      this.applyViewportTransform(appState);
      
      // 渲染背景
      if (options.renderBackground !== false) {
        this.renderBackground(appState);
      }
      
      // 渲染网格
      if (options.renderGrid && appState.gridModeEnabled) {
        this.renderGrid(appState);
      }
      
      // 过滤可见元素
      const visibleElements = this.getVisibleElements(elements, appState);
      
      // 分层渲染
      await this.renderLayers(visibleElements, appState, options);
      
      // 渲染交互层
      if (!options.isExporting) {
        this.renderInteractiveLayer(appState);
      }
      
    } finally {
      this.isRendering = false;
      
      // 处理待渲染请求
      if (this.pendingRender) {
        this.pendingRender = false;
        setTimeout(() => this.render(elements, appState, options), 0);
      }
    }
  }
  
  // 初始化画布
  private initializeCanvas(
    appState: StaticCanvasAppState,
    options: { isExporting?: boolean }
  ): void {
    const scale = window.devicePixelRatio || 1;
    const [width, height] = getNormalizedCanvasDimensions(this.canvas, scale);
    
    bootstrapCanvas({
      canvas: this.canvas,
      scale,
      normalizedWidth: width,
      normalizedHeight: height,
      theme: appState.theme,
      isExporting: options.isExporting || false,
      viewBackgroundColor: appState.viewBackgroundColor,
    });
  }
  
  // 应用视口变换
  private applyViewportTransform(appState: StaticCanvasAppState): void {
    this.context.save();
    ViewportManager.applyViewportTransform(this.context, {
      scrollX: appState.scrollX,
      scrollY: appState.scrollY,
      zoom: appState.zoom.value,
    });
  }
  
  // 渲染背景
  private renderBackground(appState: StaticCanvasAppState): void {
    if (appState.viewBackgroundColor === "transparent") {
      return;
    }
    
    this.context.save();
    this.context.fillStyle = appState.viewBackgroundColor;
    this.context.fillRect(
      appState.scrollX,
      appState.scrollY,
      this.canvas.width / appState.zoom.value,
      this.canvas.height / appState.zoom.value
    );
    this.context.restore();
  }
  
  // 渲染网格
  private renderGrid(appState: StaticCanvasAppState): void {
    strokeGrid(
      this.context,
      appState.gridSize,
      appState.gridStep,
      appState.scrollX,
      appState.scrollY,
      appState.zoom,
      this.canvas.width / appState.zoom.value,
      this.canvas.height / appState.zoom.value
    );
  }
  
  // 获取可见元素
  private getVisibleElements(
    elements: readonly ExcalidrawElement[],
    appState: StaticCanvasAppState
  ): ExcalidrawElement[] {
    return getVisibleElements(
      elements,
      this.canvas.width,
      this.canvas.height,
      {
        scrollX: appState.scrollX,
        scrollY: appState.scrollY,
        zoom: appState.zoom,
      }
    );
  }
  
  // 分层渲染
  private async renderLayers(
    elements: ExcalidrawElement[],
    appState: StaticCanvasAppState,
    options: { isExporting?: boolean }
  ): Promise<void> {
    // 按层级排序元素
    const sortedElements = elements.sort((a, b) => {
      const indexA = a.index || "";
      const indexB = b.index || "";
      return indexA.localeCompare(indexB);
    });
    
    // 分批渲染以保持响应性
    const batchSize = 20;
    for (let i = 0; i < sortedElements.length; i += batchSize) {
      const batch = sortedElements.slice(i, i + batchSize);
      
      for (const element of batch) {
        await this.renderElementWithCache(element, appState);
      }
      
      // 让出控制权以保持UI响应
      if (i + batchSize < sortedElements.length) {
        await this.yieldControl();
      }
    }
  }
  
  // 使用缓存渲染元素
  private async renderElementWithCache(
    element: ExcalidrawElement,
    appState: StaticCanvasAppState
  ): Promise<void> {
    const transform = {
      scrollX: appState.scrollX,
      scrollY: appState.scrollY,
      zoom: appState.zoom.value,
    };
    
    // 尝试从缓存获取
    const cached = this.cacheManager.getCache(element, transform);
    
    if (cached) {
      this.cacheManager.renderFromCache(this.context, cached);
    } else {
      // 渲染并缓存
      this.cacheManager.setCache(element, transform, (context) => {
        renderElement(
          element,
          new Map(), // 在实际应用中需要提供完整的 elementsMap
          new Map(), // 在实际应用中需要提供完整的 allElementsMap
          rough.canvas(context.canvas as any),
          context,
          { isExporting: false, renderGrid: false },
          appState
        );
      });
    }
  }
  
  // 渲染交互层
  private renderInteractiveLayer(appState: StaticCanvasAppState): void {
    // 这里会渲染选择框、变换句柄、吸附线等交互元素
    // 实际实现会调用 interactiveScene.ts 中的方法
  }
  
  // 让出控制权
  private yieldControl(): Promise<void> {
    return new Promise(resolve => {
      setTimeout(resolve, 0);
    });
  }
  
  // 清理资源
  dispose(): void {
    this.batchRenderer.clear();
    this.cacheManager.clear();
    this.zoomManager.cancel();
  }
  
  // 获取渲染统计信息
  getStats(): {
    cacheStats: ReturnType<RenderCacheManager['getStats']>;
    batchStats: ReturnType<BatchRenderer['getStatus']>;
  } {
    return {
      cacheStats: this.cacheManager.getStats(),
      batchStats: this.batchRenderer.getStatus(),
    };
  }
}

// 使用示例
const canvas = document.getElementById('canvas') as HTMLCanvasElement;
const renderEngine = new ExcalidrawRenderEngine(canvas);

// 渲染场景
await renderEngine.render(elements, appState, {
  renderGrid: true,
  renderBackground: true,
});

// 获取性能统计
const stats = renderEngine.getStats();
console.log('Render stats:', stats);
```

通过深入分析真实的Excalidraw渲染源码，我们看到了一个成熟的渲染引擎是如何设计的：分层的渲染架构、智能的视口管理、高效的缓存机制、以及优雅的性能优化。这些设计模式为构建高性能的图形应用提供了强有力的参考。