# 第3章：事件交互与用户输入

## 学习目标
通过本章学习，你将掌握：
- Web事件系统的工作原理
- 不同类型输入设备的事件处理
- 如何构建统一的事件处理系统
- 手势识别和多点触控
- 键盘快捷键系统
- 拖拽系统的实现
- 事件委托和性能优化

## 3.1 Web事件系统基础

### 3.1.1 事件模型概述

Web浏览器使用事件驱动的编程模型，用户与页面的所有交互都会产生相应的事件。

```javascript
// 基础事件处理示例
class BasicEventHandler {
    constructor(canvas) {
        this.canvas = canvas;
        this.isDrawing = false;
        this.lastPosition = null;
        
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        // 鼠标事件
        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
        
        // 触摸事件
        this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));
        this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));
        this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
        
        // 键盘事件
        document.addEventListener('keydown', this.handleKeyDown.bind(this));
        document.addEventListener('keyup', this.handleKeyUp.bind(this));
    }
    
    handleMouseDown(event) {
        console.log('Mouse down at:', event.clientX, event.clientY);
        this.isDrawing = true;
        this.lastPosition = { x: event.clientX, y: event.clientY };
    }
    
    handleMouseMove(event) {
        if (!this.isDrawing) return;
        console.log('Mouse move to:', event.clientX, event.clientY);
    }
    
    handleMouseUp(event) {
        console.log('Mouse up');
        this.isDrawing = false;
        this.lastPosition = null;
    }
    
    handleTouchStart(event) {
        event.preventDefault(); // 防止触摸滚动
        const touch = event.touches[0];
        this.handleMouseDown({
            clientX: touch.clientX,
            clientY: touch.clientY
        });
    }
    
    handleTouchMove(event) {
        event.preventDefault();
        const touch = event.touches[0];
        this.handleMouseMove({
            clientX: touch.clientX,
            clientY: touch.clientY
        });
    }
    
    handleTouchEnd(event) {
        event.preventDefault();
        this.handleMouseUp(event);
    }
    
    handleKeyDown(event) {
        console.log('Key down:', event.key, event.code);
    }
    
    handleKeyUp(event) {
        console.log('Key up:', event.key, event.code);
    }
}
```

### 3.1.2 事件对象详解

每个事件都包含丰富的信息，了解这些属性对于精确的交互处理至关重要。

```javascript
class EventAnalyzer {
    analyzeMouseEvent(event) {
        return {
            // 基本位置信息
            clientX: event.clientX,     // 相对于视口的X坐标
            clientY: event.clientY,     // 相对于视口的Y坐标
            screenX: event.screenX,     // 相对于屏幕的X坐标
            screenY: event.screenY,     // 相对于屏幕的Y坐标
            offsetX: event.offsetX,     // 相对于目标元素的X坐标
            offsetY: event.offsetY,     // 相对于目标元素的Y坐标
            
            // 按键状态
            button: event.button,       // 按下的鼠标按键(0:左键, 1:中键, 2:右键)
            buttons: event.buttons,     // 当前按下的所有按键的位掩码
            
            // 修饰键状态
            ctrlKey: event.ctrlKey,     // Ctrl键是否按下
            shiftKey: event.shiftKey,   // Shift键是否按下
            altKey: event.altKey,       // Alt键是否按下
            metaKey: event.metaKey,     // Meta键(Cmd/Win)是否按下
            
            // 其他信息
            target: event.target,       // 事件目标元素
            currentTarget: event.currentTarget, // 当前处理事件的元素
            timeStamp: event.timeStamp  // 事件发生的时间戳
        };
    }
    
    analyzeTouchEvent(event) {
        const touches = Array.from(event.touches).map(touch => ({
            identifier: touch.identifier,   // 触摸点唯一标识
            clientX: touch.clientX,
            clientY: touch.clientY,
            screenX: touch.screenX,
            screenY: touch.screenY,
            pageX: touch.pageX,
            pageY: touch.pageY,
            radiusX: touch.radiusX,        // 触摸椭圆的X轴半径
            radiusY: touch.radiusY,        // 触摸椭圆的Y轴半径
            rotationAngle: touch.rotationAngle, // 触摸椭圆的旋转角度
            force: touch.force             // 压力值(0-1)
        }));
        
        return {
            touches: touches,
            changedTouches: Array.from(event.changedTouches),
            targetTouches: Array.from(event.targetTouches),
            touchCount: event.touches.length
        };
    }
    
    analyzeKeyboardEvent(event) {
        return {
            key: event.key,             // 按键字符值
            code: event.code,           // 按键物理位置代码
            keyCode: event.keyCode,     // 已弃用，但仍需兼容
            which: event.which,         // 已弃用，但仍需兼容
            location: event.location,   // 按键位置(左右修饰键区分)
            repeat: event.repeat,       // 是否为重复按键
            ctrlKey: event.ctrlKey,
            shiftKey: event.shiftKey,
            altKey: event.altKey,
            metaKey: event.metaKey
        };
    }
}
```

## 3.2 坐标系统与位置转换

### 3.2.1 多种坐标系统

在Canvas绘图应用中，需要处理多种坐标系统之间的转换。

```javascript
class CoordinateSystem {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        
        // 视图变换参数
        this.viewOffset = { x: 0, y: 0 };
        this.scale = 1;
    }
    
    // 获取Canvas的DPI缩放比
    getDPR() {
        return window.devicePixelRatio || 1;
    }
    
    // 客户端坐标转Canvas坐标
    clientToCanvas(clientX, clientY) {
        const rect = this.canvas.getBoundingClientRect();
        const dpr = this.getDPR();
        
        return {
            x: (clientX - rect.left) * dpr,
            y: (clientY - rect.top) * dpr
        };
    }
    
    // Canvas坐标转场景坐标(考虑缩放和平移)
    canvasToScene(canvasX, canvasY) {
        return {
            x: (canvasX - this.viewOffset.x) / this.scale,
            y: (canvasY - this.viewOffset.y) / this.scale
        };
    }
    
    // 场景坐标转Canvas坐标
    sceneToCanvas(sceneX, sceneY) {
        return {
            x: sceneX * this.scale + this.viewOffset.x,
            y: sceneY * this.scale + this.viewOffset.y
        };
    }
    
    // 直接从客户端坐标转场景坐标
    clientToScene(clientX, clientY) {
        const canvasCoord = this.clientToCanvas(clientX, clientY);
        return this.canvasToScene(canvasCoord.x, canvasCoord.y);
    }
    
    // 场景坐标转客户端坐标
    sceneToClient(sceneX, sceneY) {
        const canvasCoord = this.sceneToCanvas(sceneX, sceneY);
        const rect = this.canvas.getBoundingClientRect();
        const dpr = this.getDPR();
        
        return {
            x: canvasCoord.x / dpr + rect.left,
            y: canvasCoord.y / dpr + rect.top
        };
    }
    
    // 设置视图变换
    setView(offsetX, offsetY, scale) {
        this.viewOffset.x = offsetX;
        this.viewOffset.y = offsetY;
        this.scale = scale;
    }
    
    // 缩放到指定点
    zoomToPoint(clientX, clientY, scaleDelta) {
        const scenePoint = this.clientToScene(clientX, clientY);
        const newScale = Math.max(0.1, Math.min(10, this.scale * scaleDelta));
        
        // 计算新的偏移，使缩放中心保持在相同位置
        const canvasPoint = this.clientToCanvas(clientX, clientY);
        this.viewOffset.x = canvasPoint.x - scenePoint.x * newScale;
        this.viewOffset.y = canvasPoint.y - scenePoint.y * newScale;
        this.scale = newScale;
    }
}
```

### 3.2.2 高精度坐标处理

对于绘图应用，坐标精度非常重要，特别是在高DPI屏幕上。

```javascript
class PrecisionCoordinates {
    constructor(canvas) {
        this.canvas = canvas;
        this.coordinateSystem = new CoordinateSystem(canvas);
    }
    
    // 获取高精度鼠标位置
    getHighPrecisionMousePosition(event) {
        // 使用movementX/Y获得亚像素精度
        const basePosition = this.coordinateSystem.clientToScene(
            event.clientX, 
            event.clientY
        );
        
        // 如果有movement信息，可以用于增量更新
        if (this.lastPosition && (event.movementX || event.movementY)) {
            const movement = {
                x: event.movementX / this.coordinateSystem.scale,
                y: event.movementY / this.coordinateSystem.scale
            };
            
            return {
                x: this.lastPosition.x + movement.x,
                y: this.lastPosition.y + movement.y,
                movement: movement
            };
        }
        
        this.lastPosition = basePosition;
        return basePosition;
    }
    
    // 触摸位置平滑处理
    smoothTouchPositions(touches) {
        return touches.map(touch => {
            const position = this.coordinateSystem.clientToScene(
                touch.clientX, 
                touch.clientY
            );
            
            // 可以在这里添加位置平滑算法
            return this.applyPositionSmoothing(position, touch.identifier);
        });
    }
    
    applyPositionSmoothing(position, touchId) {
        // 简单的指数平滑
        const smoothingFactor = 0.8;
        const lastPosition = this.lastTouchPositions?.get(touchId);
        
        if (!this.lastTouchPositions) {
            this.lastTouchPositions = new Map();
        }
        
        if (lastPosition) {
            const smoothed = {
                x: lastPosition.x * smoothingFactor + position.x * (1 - smoothingFactor),
                y: lastPosition.y * smoothingFactor + position.y * (1 - smoothingFactor)
            };
            this.lastTouchPositions.set(touchId, smoothed);
            return smoothed;
        } else {
            this.lastTouchPositions.set(touchId, position);
            return position;
        }
    }
}
```

## 3.3 统一事件处理系统

### 3.3.1 指针事件抽象

现代Web开发推荐使用Pointer Events API来统一处理鼠标、触摸和手写笔输入。

```javascript
class UnifiedPointerHandler {
    constructor(canvas) {
        this.canvas = canvas;
        this.coordinateSystem = new CoordinateSystem(canvas);
        this.activePointers = new Map();
        this.eventHandlers = {
            pointerdown: [],
            pointermove: [],
            pointerup: [],
            pointercancel: []
        };
        
        this.setupPointerEvents();
    }
    
    setupPointerEvents() {
        // 检查Pointer Events支持
        if (window.PointerEvent) {
            this.canvas.addEventListener('pointerdown', this.handlePointerDown.bind(this));
            this.canvas.addEventListener('pointermove', this.handlePointerMove.bind(this));
            this.canvas.addEventListener('pointerup', this.handlePointerUp.bind(this));
            this.canvas.addEventListener('pointercancel', this.handlePointerCancel.bind(this));
        } else {
            // 降级到鼠标和触摸事件
            this.setupFallbackEvents();
        }
        
        // 设置canvas捕获指针
        this.canvas.style.touchAction = 'none';
    }
    
    setupFallbackEvents() {
        // 鼠标事件
        this.canvas.addEventListener('mousedown', this.convertMouseToPointer.bind(this, 'pointerdown'));
        this.canvas.addEventListener('mousemove', this.convertMouseToPointer.bind(this, 'pointermove'));
        this.canvas.addEventListener('mouseup', this.convertMouseToPointer.bind(this, 'pointerup'));
        
        // 触摸事件
        this.canvas.addEventListener('touchstart', this.convertTouchToPointer.bind(this, 'pointerdown'));
        this.canvas.addEventListener('touchmove', this.convertTouchToPointer.bind(this, 'pointermove'));
        this.canvas.addEventListener('touchend', this.convertTouchToPointer.bind(this, 'pointerup'));
        this.canvas.addEventListener('touchcancel', this.convertTouchToPointer.bind(this, 'pointercancel'));
    }
    
    handlePointerDown(event) {
        const pointer = this.createPointerData(event);
        this.activePointers.set(event.pointerId, pointer);
        
        // 设置指针捕获
        this.canvas.setPointerCapture(event.pointerId);
        
        this.emitEvent('pointerdown', pointer, event);
    }
    
    handlePointerMove(event) {
        const pointer = this.createPointerData(event);
        this.activePointers.set(event.pointerId, pointer);
        
        this.emitEvent('pointermove', pointer, event);
    }
    
    handlePointerUp(event) {
        const pointer = this.createPointerData(event);
        this.activePointers.delete(event.pointerId);
        
        this.emitEvent('pointerup', pointer, event);
    }
    
    handlePointerCancel(event) {
        const pointer = this.createPointerData(event);
        this.activePointers.delete(event.pointerId);
        
        this.emitEvent('pointercancel', pointer, event);
    }
    
    createPointerData(event) {
        const scenePosition = this.coordinateSystem.clientToScene(
            event.clientX, 
            event.clientY
        );
        
        return {
            id: event.pointerId,
            type: event.pointerType,
            position: scenePosition,
            clientPosition: { x: event.clientX, y: event.clientY },
            pressure: event.pressure,
            tiltX: event.tiltX,
            tiltY: event.tiltY,
            twist: event.twist,
            width: event.width,
            height: event.height,
            button: event.button,
            buttons: event.buttons,
            isPrimary: event.isPrimary,
            modifiers: {
                ctrl: event.ctrlKey,
                shift: event.shiftKey,
                alt: event.altKey,
                meta: event.metaKey
            },
            timestamp: event.timeStamp
        };
    }
    
    convertMouseToPointer(type, event) {
        const pointerEvent = {
            pointerId: 1,
            pointerType: 'mouse',
            clientX: event.clientX,
            clientY: event.clientY,
            pressure: event.buttons > 0 ? 1 : 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            width: 1,
            height: 1,
            button: event.button,
            buttons: event.buttons,
            isPrimary: true,
            ctrlKey: event.ctrlKey,
            shiftKey: event.shiftKey,
            altKey: event.altKey,
            metaKey: event.metaKey,
            timeStamp: event.timeStamp
        };
        
        this.handlePointerEvent(type, pointerEvent, event);
    }
    
    convertTouchToPointer(type, event) {
        event.preventDefault();
        
        const touches = type === 'pointerup' || type === 'pointercancel' 
            ? event.changedTouches 
            : event.touches;
            
        for (const touch of touches) {
            const pointerEvent = {
                pointerId: touch.identifier + 2, // 避免与鼠标ID冲突
                pointerType: 'touch',
                clientX: touch.clientX,
                clientY: touch.clientY,
                pressure: 1,
                tiltX: 0,
                tiltY: 0,
                twist: 0,
                width: touch.radiusX * 2,
                height: touch.radiusY * 2,
                button: 0,
                buttons: type === 'pointerup' ? 0 : 1,
                isPrimary: touch.identifier === 0,
                ctrlKey: false,
                shiftKey: false,
                altKey: false,
                metaKey: false,
                timeStamp: event.timeStamp
            };
            
            this.handlePointerEvent(type, pointerEvent, event);
        }
    }
    
    handlePointerEvent(type, pointerEvent, originalEvent) {
        switch (type) {
            case 'pointerdown':
                this.handlePointerDown(pointerEvent);
                break;
            case 'pointermove':
                this.handlePointerMove(pointerEvent);
                break;
            case 'pointerup':
                this.handlePointerUp(pointerEvent);
                break;
            case 'pointercancel':
                this.handlePointerCancel(pointerEvent);
                break;
        }
    }
    
    // 事件监听器管理
    addEventListener(type, handler) {
        if (this.eventHandlers[type]) {
            this.eventHandlers[type].push(handler);
        }
    }
    
    removeEventListener(type, handler) {
        if (this.eventHandlers[type]) {
            const index = this.eventHandlers[type].indexOf(handler);
            if (index > -1) {
                this.eventHandlers[type].splice(index, 1);
            }
        }
    }
    
    emitEvent(type, pointer, originalEvent) {
        if (this.eventHandlers[type]) {
            this.eventHandlers[type].forEach(handler => {
                handler(pointer, originalEvent);
            });
        }
    }
    
    // 获取当前活跃的指针
    getActivePointers() {
        return Array.from(this.activePointers.values());
    }
    
    // 获取主指针
    getPrimaryPointer() {
        for (const pointer of this.activePointers.values()) {
            if (pointer.isPrimary) {
                return pointer;
            }
        }
        return null;
    }
}
```

### 3.3.2 手势识别系统

基于指针事件构建手势识别系统，支持平移、缩放、旋转等操作。

```javascript
class GestureRecognizer {
    constructor(pointerHandler) {
        this.pointerHandler = pointerHandler;
        this.gestures = {
            pan: { active: false, startPosition: null, lastPosition: null },
            pinch: { active: false, startDistance: 0, startScale: 1 },
            rotate: { active: false, startAngle: 0, startRotation: 0 }
        };
        
        this.gestureHandlers = {
            panstart: [],
            panmove: [],
            panend: [],
            pinchstart: [],
            pinchmove: [],
            pinchend: [],
            rotatestart: [],
            rotatemove: [],
            rotateend: []
        };
        
        this.setupGestureRecognition();
    }
    
    setupGestureRecognition() {
        this.pointerHandler.addEventListener('pointerdown', this.handlePointerDown.bind(this));
        this.pointerHandler.addEventListener('pointermove', this.handlePointerMove.bind(this));
        this.pointerHandler.addEventListener('pointerup', this.handlePointerUp.bind(this));
        this.pointerHandler.addEventListener('pointercancel', this.handlePointerCancel.bind(this));
    }
    
    handlePointerDown(pointer) {
        const activePointers = this.pointerHandler.getActivePointers();
        
        if (activePointers.length === 1) {
            // 单指操作，可能是平移
            this.startPanGesture(pointer);
        } else if (activePointers.length === 2) {
            // 双指操作，可能是缩放或旋转
            this.startMultiTouchGestures(activePointers);
        }
    }
    
    handlePointerMove(pointer) {
        const activePointers = this.pointerHandler.getActivePointers();
        
        if (activePointers.length === 1 && this.gestures.pan.active) {
            this.updatePanGesture(pointer);
        } else if (activePointers.length === 2) {
            this.updateMultiTouchGestures(activePointers);
        }
    }
    
    handlePointerUp(pointer) {
        const activePointers = this.pointerHandler.getActivePointers();
        
        if (this.gestures.pan.active && activePointers.length === 0) {
            this.endPanGesture(pointer);
        }
        
        if (activePointers.length < 2) {
            this.endMultiTouchGestures();
        }
    }
    
    handlePointerCancel(pointer) {
        this.endAllGestures();
    }
    
    startPanGesture(pointer) {
        this.gestures.pan.active = true;
        this.gestures.pan.startPosition = { ...pointer.position };
        this.gestures.pan.lastPosition = { ...pointer.position };
        
        this.emitGestureEvent('panstart', {
            position: pointer.position,
            pointer: pointer
        });
    }
    
    updatePanGesture(pointer) {
        if (!this.gestures.pan.active) return;
        
        const delta = {
            x: pointer.position.x - this.gestures.pan.lastPosition.x,
            y: pointer.position.y - this.gestures.pan.lastPosition.y
        };
        
        const totalDelta = {
            x: pointer.position.x - this.gestures.pan.startPosition.x,
            y: pointer.position.y - this.gestures.pan.startPosition.y
        };
        
        this.gestures.pan.lastPosition = { ...pointer.position };
        
        this.emitGestureEvent('panmove', {
            position: pointer.position,
            delta: delta,
            totalDelta: totalDelta,
            pointer: pointer
        });
    }
    
    endPanGesture(pointer) {
        if (!this.gestures.pan.active) return;
        
        this.gestures.pan.active = false;
        
        this.emitGestureEvent('panend', {
            position: pointer.position,
            totalDelta: {
                x: pointer.position.x - this.gestures.pan.startPosition.x,
                y: pointer.position.y - this.gestures.pan.startPosition.y
            },
            pointer: pointer
        });
    }
    
    startMultiTouchGestures(pointers) {
        if (pointers.length !== 2) return;
        
        const [p1, p2] = pointers;
        const distance = this.calculateDistance(p1.position, p2.position);
        const angle = this.calculateAngle(p1.position, p2.position);
        const center = this.calculateCenter(p1.position, p2.position);
        
        // 开始缩放手势
        this.gestures.pinch.active = true;
        this.gestures.pinch.startDistance = distance;
        this.gestures.pinch.startScale = 1;
        
        this.emitGestureEvent('pinchstart', {
            center: center,
            distance: distance,
            scale: 1,
            pointers: pointers
        });
        
        // 开始旋转手势
        this.gestures.rotate.active = true;
        this.gestures.rotate.startAngle = angle;
        this.gestures.rotate.startRotation = 0;
        
        this.emitGestureEvent('rotatestart', {
            center: center,
            angle: angle,
            rotation: 0,
            pointers: pointers
        });
    }
    
    updateMultiTouchGestures(pointers) {
        if (pointers.length !== 2) return;
        
        const [p1, p2] = pointers;
        const distance = this.calculateDistance(p1.position, p2.position);
        const angle = this.calculateAngle(p1.position, p2.position);
        const center = this.calculateCenter(p1.position, p2.position);
        
        // 更新缩放手势
        if (this.gestures.pinch.active) {
            const scale = distance / this.gestures.pinch.startDistance;
            
            this.emitGestureEvent('pinchmove', {
                center: center,
                distance: distance,
                scale: scale,
                deltaScale: scale / this.gestures.pinch.startScale,
                pointers: pointers
            });
            
            this.gestures.pinch.startScale = scale;
        }
        
        // 更新旋转手势
        if (this.gestures.rotate.active) {
            let rotation = angle - this.gestures.rotate.startAngle;
            
            // 处理角度跨越问题
            if (rotation > Math.PI) rotation -= 2 * Math.PI;
            if (rotation < -Math.PI) rotation += 2 * Math.PI;
            
            this.emitGestureEvent('rotatemove', {
                center: center,
                angle: angle,
                rotation: rotation,
                deltaRotation: rotation - this.gestures.rotate.startRotation,
                pointers: pointers
            });
            
            this.gestures.rotate.startRotation = rotation;
        }
    }
    
    endMultiTouchGestures() {
        if (this.gestures.pinch.active) {
            this.gestures.pinch.active = false;
            this.emitGestureEvent('pinchend', {});
        }
        
        if (this.gestures.rotate.active) {
            this.gestures.rotate.active = false;
            this.emitGestureEvent('rotateend', {});
        }
    }
    
    endAllGestures() {
        if (this.gestures.pan.active) {
            this.gestures.pan.active = false;
            this.emitGestureEvent('panend', {});
        }
        
        this.endMultiTouchGestures();
    }
    
    calculateDistance(p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    calculateAngle(p1, p2) {
        return Math.atan2(p2.y - p1.y, p2.x - p1.x);
    }
    
    calculateCenter(p1, p2) {
        return {
            x: (p1.x + p2.x) / 2,
            y: (p1.y + p2.y) / 2
        };
    }
    
    // 手势事件监听器管理
    addEventListener(type, handler) {
        if (this.gestureHandlers[type]) {
            this.gestureHandlers[type].push(handler);
        }
    }
    
    removeEventListener(type, handler) {
        if (this.gestureHandlers[type]) {
            const index = this.gestureHandlers[type].indexOf(handler);
            if (index > -1) {
                this.gestureHandlers[type].splice(index, 1);
            }
        }
    }
    
    emitGestureEvent(type, data) {
        if (this.gestureHandlers[type]) {
            this.gestureHandlers[type].forEach(handler => {
                handler(data);
            });
        }
    }
}
```

## 3.4 键盘快捷键系统

### 3.4.1 快捷键管理器

构建一个灵活的键盘快捷键系统，支持组合键和上下文相关的快捷键。

```javascript
class ShortcutManager {
    constructor() {
        this.shortcuts = new Map();
        this.activeKeys = new Set();
        this.contexts = new Set(['global']); // 默认全局上下文
        this.enabled = true;
        
        this.setupKeyboardEvents();
    }
    
    setupKeyboardEvents() {
        document.addEventListener('keydown', this.handleKeyDown.bind(this));
        document.addEventListener('keyup', this.handleKeyUp.bind(this));
        
        // 处理窗口失去焦点时的按键重置
        window.addEventListener('blur', this.resetActiveKeys.bind(this));
        window.addEventListener('focus', this.resetActiveKeys.bind(this));
    }
    
    handleKeyDown(event) {
        if (!this.enabled) return;
        
        // 阻止在输入框中触发快捷键
        if (this.isInputElement(event.target)) return;
        
        const keyCombo = this.getKeyCombo(event);
        this.activeKeys.add(event.code);
        
        // 检查是否匹配任何快捷键
        const matchedShortcut = this.findMatchingShortcut(keyCombo);
        if (matchedShortcut) {
            event.preventDefault();
            matchedShortcut.handler(event);
        }
    }
    
    handleKeyUp(event) {
        this.activeKeys.delete(event.code);
    }
    
    resetActiveKeys() {
        this.activeKeys.clear();
    }
    
    getKeyCombo(event) {
        const modifiers = [];
        if (event.ctrlKey || event.metaKey) modifiers.push('mod');
        if (event.shiftKey) modifiers.push('shift');
        if (event.altKey) modifiers.push('alt');
        
        return {
            key: event.code,
            modifiers: modifiers,
            combo: modifiers.length > 0 ? modifiers.join('+') + '+' + event.code : event.code
        };
    }
    
    findMatchingShortcut(keyCombo) {
        // 按上下文优先级查找快捷键
        for (const context of this.contexts) {
            const contextShortcuts = this.shortcuts.get(context);
            if (contextShortcuts) {
                const shortcut = contextShortcuts.get(keyCombo.combo);
                if (shortcut) {
                    return shortcut;
                }
            }
        }
        
        // 查找全局快捷键
        const globalShortcuts = this.shortcuts.get('global');
        if (globalShortcuts) {
            return globalShortcuts.get(keyCombo.combo);
        }
        
        return null;
    }
    
    isInputElement(element) {
        const inputTypes = ['INPUT', 'TEXTAREA', 'SELECT'];
        return inputTypes.includes(element.tagName) || 
               element.contentEditable === 'true';
    }
    
    // 注册快捷键
    register(combo, handler, context = 'global', description = '') {
        if (!this.shortcuts.has(context)) {
            this.shortcuts.set(context, new Map());
        }
        
        const contextShortcuts = this.shortcuts.get(context);
        contextShortcuts.set(combo, {
            combo,
            handler,
            context,
            description
        });
    }
    
    // 批量注册快捷键
    registerMultiple(shortcuts, context = 'global') {
        shortcuts.forEach(({ combo, handler, description }) => {
            this.register(combo, handler, context, description);
        });
    }
    
    // 注销快捷键
    unregister(combo, context = 'global') {
        const contextShortcuts = this.shortcuts.get(context);
        if (contextShortcuts) {
            contextShortcuts.delete(combo);
        }
    }
    
    // 设置当前上下文
    setContext(contexts) {
        if (Array.isArray(contexts)) {
            this.contexts = new Set([...contexts, 'global']);
        } else {
            this.contexts = new Set([contexts, 'global']);
        }
    }
    
    // 启用/禁用快捷键系统
    setEnabled(enabled) {
        this.enabled = enabled;
    }
    
    // 获取所有快捷键列表
    getShortcutsList(context = null) {
        const result = [];
        
        if (context) {
            const contextShortcuts = this.shortcuts.get(context);
            if (contextShortcuts) {
                contextShortcuts.forEach(shortcut => result.push(shortcut));
            }
        } else {
            this.shortcuts.forEach((contextShortcuts, contextName) => {
                contextShortcuts.forEach(shortcut => result.push({
                    ...shortcut,
                    context: contextName
                }));
            });
        }
        
        return result;
    }
    
    // 格式化快捷键显示
    formatShortcut(combo) {
        return combo
            .replace('mod+', navigator.platform.indexOf('Mac') > -1 ? '⌘+' : 'Ctrl+')
            .replace('shift+', 'Shift+')
            .replace('alt+', 'Alt+')
            .replace(/Key([A-Z])/g, '$1')
            .replace(/Digit([0-9])/g, '$1')
            .replace(/Arrow([A-Z][a-z]+)/g, '$1')
            .replace('Space', 'Space')
            .replace('Enter', 'Enter')
            .replace('Escape', 'Esc');
    }
}

// 使用示例
const shortcutManager = new ShortcutManager();

// 注册绘图工具快捷键
shortcutManager.registerMultiple([
    {
        combo: 'KeyR',
        handler: () => console.log('Rectangle tool selected'),
        description: 'Select rectangle tool'
    },
    {
        combo: 'KeyC',
        handler: () => console.log('Circle tool selected'),
        description: 'Select circle tool'
    },
    {
        combo: 'KeyL',
        handler: () => console.log('Line tool selected'),
        description: 'Select line tool'
    },
    {
        combo: 'KeyP',
        handler: () => console.log('Pen tool selected'),
        description: 'Select pen tool'
    }
], 'drawing');

// 注册编辑快捷键
shortcutManager.registerMultiple([
    {
        combo: 'mod+KeyZ',
        handler: () => console.log('Undo'),
        description: 'Undo last action'
    },
    {
        combo: 'mod+shift+KeyZ',
        handler: () => console.log('Redo'),
        description: 'Redo last action'
    },
    {
        combo: 'mod+KeyC',
        handler: () => console.log('Copy'),
        description: 'Copy selected elements'
    },
    {
        combo: 'mod+KeyV',
        handler: () => console.log('Paste'),
        description: 'Paste elements'
    },
    {
        combo: 'Delete',
        handler: () => console.log('Delete selected'),
        description: 'Delete selected elements'
    }
], 'editing');
```

### 3.4.2 上下文相关快捷键

根据不同的应用状态提供不同的快捷键组合。

```javascript
class ContextualShortcuts {
    constructor(shortcutManager) {
        this.shortcutManager = shortcutManager;
        this.currentTool = null;
        this.selectedElements = [];
        this.isEditing = false;
        
        this.registerContextualShortcuts();
    }
    
    registerContextualShortcuts() {
        // 全局快捷键 - 始终可用
        this.shortcutManager.registerMultiple([
            {
                combo: 'mod+KeyN',
                handler: () => this.newDocument(),
                description: 'New document'
            },
            {
                combo: 'mod+KeyO',
                handler: () => this.openDocument(),
                description: 'Open document'
            },
            {
                combo: 'mod+KeyS',
                handler: () => this.saveDocument(),
                description: 'Save document'
            },
            {
                combo: 'F11',
                handler: () => this.toggleFullscreen(),
                description: 'Toggle fullscreen'
            }
        ], 'global');
        
        // 工具选择快捷键
        this.shortcutManager.registerMultiple([
            {
                combo: 'KeyV',
                handler: () => this.selectTool('select'),
                description: 'Select tool'
            },
            {
                combo: 'KeyR',
                handler: () => this.selectTool('rectangle'),
                description: 'Rectangle tool'
            },
            {
                combo: 'KeyO',
                handler: () => this.selectTool('ellipse'),
                description: 'Ellipse tool'
            },
            {
                combo: 'KeyL',
                handler: () => this.selectTool('line'),
                description: 'Line tool'
            },
            {
                combo: 'KeyP',
                handler: () => this.selectTool('pen'),
                description: 'Pen tool'
            },
            {
                combo: 'KeyT',
                handler: () => this.selectTool('text'),
                description: 'Text tool'
            }
        ], 'tools');
        
        // 选中元素时的快捷键
        this.shortcutManager.registerMultiple([
            {
                combo: 'mod+KeyC',
                handler: () => this.copySelected(),
                description: 'Copy selected'
            },
            {
                combo: 'mod+KeyX',
                handler: () => this.cutSelected(),
                description: 'Cut selected'
            },
            {
                combo: 'mod+KeyD',
                handler: () => this.duplicateSelected(),
                description: 'Duplicate selected'
            },
            {
                combo: 'Delete',
                handler: () => this.deleteSelected(),
                description: 'Delete selected'
            },
            {
                combo: 'mod+KeyG',
                handler: () => this.groupSelected(),
                description: 'Group selected'
            },
            {
                combo: 'mod+shift+KeyG',
                handler: () => this.ungroupSelected(),
                description: 'Ungroup selected'
            }
        ], 'selection');
        
        // 文本编辑时的快捷键
        this.shortcutManager.registerMultiple([
            {
                combo: 'mod+KeyB',
                handler: () => this.toggleBold(),
                description: 'Toggle bold'
            },
            {
                combo: 'mod+KeyI',
                handler: () => this.toggleItalic(),
                description: 'Toggle italic'
            },
            {
                combo: 'Escape',
                handler: () => this.exitTextEdit(),
                description: 'Exit text editing'
            }
        ], 'textEditing');
        
        // 视图操作快捷键
        this.shortcutManager.registerMultiple([
            {
                combo: 'mod+KeyPlus',
                handler: () => this.zoomIn(),
                description: 'Zoom in'
            },
            {
                combo: 'mod+KeyMinus',
                handler: () => this.zoomOut(),
                description: 'Zoom out'
            },
            {
                combo: 'mod+Key0',
                handler: () => this.resetZoom(),
                description: 'Reset zoom'
            },
            {
                combo: 'mod+Key1',
                handler: () => this.fitToScreen(),
                description: 'Fit to screen'
            },
            {
                combo: 'Space',
                handler: () => this.enablePanMode(),
                description: 'Pan mode (hold)'
            }
        ], 'view');
    }
    
    // 根据应用状态更新活跃的快捷键上下文
    updateContexts() {
        const contexts = ['global', 'tools', 'view'];
        
        if (this.selectedElements.length > 0) {
            contexts.push('selection');
        }
        
        if (this.isEditing) {
            contexts.push('textEditing');
        }
        
        this.shortcutManager.setContext(contexts);
    }
    
    // 工具相关方法
    selectTool(tool) {
        this.currentTool = tool;
        this.updateContexts();
        console.log(`Tool selected: ${tool}`);
    }
    
    // 选择相关方法
    setSelectedElements(elements) {
        this.selectedElements = elements;
        this.updateContexts();
    }
    
    copySelected() {
        console.log('Copying selected elements');
    }
    
    cutSelected() {
        console.log('Cutting selected elements');
    }
    
    duplicateSelected() {
        console.log('Duplicating selected elements');
    }
    
    deleteSelected() {
        console.log('Deleting selected elements');
        this.selectedElements = [];
        this.updateContexts();
    }
    
    groupSelected() {
        console.log('Grouping selected elements');
    }
    
    ungroupSelected() {
        console.log('Ungrouping selected elements');
    }
    
    // 文本编辑相关方法
    enterTextEdit() {
        this.isEditing = true;
        this.updateContexts();
        console.log('Entering text edit mode');
    }
    
    exitTextEdit() {
        this.isEditing = false;
        this.updateContexts();
        console.log('Exiting text edit mode');
    }
    
    toggleBold() {
        console.log('Toggling bold text');
    }
    
    toggleItalic() {
        console.log('Toggling italic text');
    }
    
    // 文档相关方法
    newDocument() {
        console.log('Creating new document');
    }
    
    openDocument() {
        console.log('Opening document');
    }
    
    saveDocument() {
        console.log('Saving document');
    }
    
    // 视图相关方法
    zoomIn() {
        console.log('Zooming in');
    }
    
    zoomOut() {
        console.log('Zooming out');
    }
    
    resetZoom() {
        console.log('Resetting zoom');
    }
    
    fitToScreen() {
        console.log('Fitting to screen');
    }
    
    enablePanMode() {
        console.log('Pan mode enabled');
    }
    
    toggleFullscreen() {
        if (document.fullscreenElement) {
            document.exitFullscreen();
        } else {
            document.documentElement.requestFullscreen();
        }
    }
}
```

## 3.5 拖拽系统

### 3.5.1 通用拖拽管理器

实现一个灵活的拖拽系统，支持多种拖拽行为。

```javascript
class DragManager {
    constructor(pointerHandler) {
        this.pointerHandler = pointerHandler;
        this.dragSessions = new Map(); // pointerId -> dragSession
        this.dragHandlers = [];
        
        this.setupDragEvents();
    }
    
    setupDragEvents() {
        this.pointerHandler.addEventListener('pointerdown', this.handlePointerDown.bind(this));
        this.pointerHandler.addEventListener('pointermove', this.handlePointerMove.bind(this));
        this.pointerHandler.addEventListener('pointerup', this.handlePointerUp.bind(this));
        this.pointerHandler.addEventListener('pointercancel', this.handlePointerCancel.bind(this));
    }
    
    handlePointerDown(pointer) {
        // 查找可以处理此拖拽的处理器
        for (const handler of this.dragHandlers) {
            const dragData = handler.canStartDrag(pointer);
            if (dragData) {
                this.startDrag(pointer, handler, dragData);
                break;
            }
        }
    }
    
    handlePointerMove(pointer) {
        const session = this.dragSessions.get(pointer.id);
        if (session) {
            this.updateDrag(pointer, session);
        }
    }
    
    handlePointerUp(pointer) {
        const session = this.dragSessions.get(pointer.id);
        if (session) {
            this.endDrag(pointer, session);
        }
    }
    
    handlePointerCancel(pointer) {
        const session = this.dragSessions.get(pointer.id);
        if (session) {
            this.cancelDrag(pointer, session);
        }
    }
    
    startDrag(pointer, handler, dragData) {
        const session = {
            pointerId: pointer.id,
            handler: handler,
            startPosition: { ...pointer.position },
            currentPosition: { ...pointer.position },
            data: dragData,
            isDragging: false,
            threshold: handler.dragThreshold || 5 // 拖拽阈值
        };
        
        this.dragSessions.set(pointer.id, session);
        
        // 调用处理器的开始方法
        if (handler.onDragStart) {
            handler.onDragStart(pointer, session);
        }
    }
    
    updateDrag(pointer, session) {
        session.currentPosition = { ...pointer.position };
        
        // 检查是否超过拖拽阈值
        if (!session.isDragging) {
            const distance = Math.sqrt(
                Math.pow(pointer.position.x - session.startPosition.x, 2) +
                Math.pow(pointer.position.y - session.startPosition.y, 2)
            );
            
            if (distance > session.threshold) {
                session.isDragging = true;
                if (session.handler.onDragBegin) {
                    session.handler.onDragBegin(pointer, session);
                }
            }
        }
        
        // 如果已经在拖拽状态，更新拖拽
        if (session.isDragging && session.handler.onDragMove) {
            session.handler.onDragMove(pointer, session);
        }
    }
    
    endDrag(pointer, session) {
        if (session.isDragging && session.handler.onDragEnd) {
            session.handler.onDragEnd(pointer, session);
        } else if (session.handler.onClick) {
            // 如果没有进入拖拽状态，可能是点击
            session.handler.onClick(pointer, session);
        }
        
        this.dragSessions.delete(pointer.id);
    }
    
    cancelDrag(pointer, session) {
        if (session.handler.onDragCancel) {
            session.handler.onDragCancel(pointer, session);
        }
        
        this.dragSessions.delete(pointer.id);
    }
    
    // 注册拖拽处理器
    registerDragHandler(handler) {
        this.dragHandlers.push(handler);
    }
    
    // 移除拖拽处理器
    unregisterDragHandler(handler) {
        const index = this.dragHandlers.indexOf(handler);
        if (index > -1) {
            this.dragHandlers.splice(index, 1);
        }
    }
    
    // 检查是否有活跃的拖拽
    hasActiveDrag() {
        return this.dragSessions.size > 0;
    }
    
    // 获取所有活跃的拖拽会话
    getActiveDragSessions() {
        return Array.from(this.dragSessions.values());
    }
}
```

### 3.5.2 具体拖拽处理器实现

实现各种具体的拖拽行为。

```javascript
// 元素选择拖拽处理器
class SelectionDragHandler {
    constructor(elementManager) {
        this.elementManager = elementManager;
        this.dragThreshold = 5;
    }
    
    canStartDrag(pointer) {
        const element = this.elementManager.getElementAt(pointer.position);
        if (element) {
            return {
                type: 'element',
                element: element,
                isSelected: this.elementManager.isSelected(element)
            };
        }
        
        // 如果没有元素，可能是框选
        return {
            type: 'selection',
            startPosition: pointer.position
        };
    }
    
    onDragStart(pointer, session) {
        if (session.data.type === 'element') {
            // 如果元素未选中，则选中它
            if (!session.data.isSelected) {
                this.elementManager.selectElement(session.data.element, !pointer.modifiers.shift);
            }
        }
    }
    
    onDragBegin(pointer, session) {
        if (session.data.type === 'element') {
            // 开始移动选中的元素
            this.startElementMove(session);
        } else if (session.data.type === 'selection') {
            // 开始框选
            this.startSelectionBox(session);
        }
    }
    
    onDragMove(pointer, session) {
        const delta = {
            x: pointer.position.x - session.startPosition.x,
            y: pointer.position.y - session.startPosition.y
        };
        
        if (session.data.type === 'element') {
            this.updateElementMove(session, delta);
        } else if (session.data.type === 'selection') {
            this.updateSelectionBox(session, pointer.position);
        }
    }
    
    onDragEnd(pointer, session) {
        if (session.data.type === 'element') {
            this.endElementMove(session);
        } else if (session.data.type === 'selection') {
            this.endSelectionBox(session, pointer.position);
        }
    }
    
    onClick(pointer, session) {
        if (session.data.type === 'element') {
            // 单击选择元素
            this.elementManager.selectElement(
                session.data.element, 
                !pointer.modifiers.shift
            );
        } else {
            // 单击空白区域，清除选择
            if (!pointer.modifiers.shift) {
                this.elementManager.clearSelection();
            }
        }
    }
    
    startElementMove(session) {
        const selectedElements = this.elementManager.getSelectedElements();
        session.data.originalPositions = selectedElements.map(el => ({
            element: el,
            position: { ...el.position }
        }));
    }
    
    updateElementMove(session, delta) {
        session.data.originalPositions.forEach(({ element, position }) => {
            element.position.x = position.x + delta.x;
            element.position.y = position.y + delta.y;
        });
        
        this.elementManager.requestRedraw();
    }
    
    endElementMove(session) {
        // 提交移动操作到历史记录
        this.elementManager.commitMove(session.data.originalPositions);
    }
    
    startSelectionBox(session) {
        session.data.selectionBox = {
            start: { ...session.startPosition },
            end: { ...session.startPosition }
        };
        
        this.elementManager.showSelectionBox(session.data.selectionBox);
    }
    
    updateSelectionBox(session, currentPosition) {
        session.data.selectionBox.end = { ...currentPosition };
        this.elementManager.updateSelectionBox(session.data.selectionBox);
    }
    
    endSelectionBox(session, endPosition) {
        const box = session.data.selectionBox;
        const selectedElements = this.elementManager.getElementsInBox(box);
        
        this.elementManager.selectElements(selectedElements, !pointer.modifiers.shift);
        this.elementManager.hideSelectionBox();
    }
}

// 画布平移拖拽处理器
class PanDragHandler {
    constructor(viewport) {
        this.viewport = viewport;
        this.dragThreshold = 0; // 立即开始平移
        this.isPanMode = false;
    }
    
    setPanMode(enabled) {
        this.isPanMode = enabled;
    }
    
    canStartDrag(pointer) {
        // 只有在平移模式下或按住空格键时才允许平移
        if (this.isPanMode || pointer.modifiers.space) {
            return {
                type: 'pan',
                startOffset: { ...this.viewport.offset }
            };
        }
        
        return null;
    }
    
    onDragMove(pointer, session) {
        const delta = {
            x: pointer.position.x - session.startPosition.x,
            y: pointer.position.y - session.startPosition.y
        };
        
        this.viewport.setOffset(
            session.data.startOffset.x + delta.x,
            session.data.startOffset.y + delta.y
        );
    }
}

// 元素创建拖拽处理器
class CreateElementDragHandler {
    constructor(elementManager, currentTool) {
        this.elementManager = elementManager;
        this.currentTool = currentTool;
        this.dragThreshold = 5;
    }
    
    canStartDrag(pointer) {
        if (this.currentTool && this.currentTool.type !== 'select') {
            return {
                type: 'create',
                tool: this.currentTool,
                startPosition: pointer.position
            };
        }
        
        return null;
    }
    
    onDragBegin(pointer, session) {
        // 创建新元素
        const element = this.createElement(session.data.tool, session.startPosition);
        session.data.element = element;
        this.elementManager.addElement(element);
    }
    
    onDragMove(pointer, session) {
        // 更新元素大小/形状
        this.updateElement(
            session.data.element, 
            session.startPosition, 
            pointer.position
        );
        
        this.elementManager.requestRedraw();
    }
    
    onDragEnd(pointer, session) {
        // 完成元素创建
        this.elementManager.commitElementCreation(session.data.element);
    }
    
    onClick(pointer, session) {
        // 对于某些工具，单击也会创建元素
        if (session.data.tool.type === 'text') {
            const element = this.createElement(session.data.tool, pointer.position);
            this.elementManager.addElement(element);
            this.elementManager.startTextEdit(element);
        }
    }
    
    createElement(tool, position) {
        switch (tool.type) {
            case 'rectangle':
                return {
                    id: this.generateId(),
                    type: 'rectangle',
                    position: { ...position },
                    size: { width: 0, height: 0 },
                    style: { ...tool.style }
                };
                
            case 'ellipse':
                return {
                    id: this.generateId(),
                    type: 'ellipse',
                    position: { ...position },
                    size: { width: 0, height: 0 },
                    style: { ...tool.style }
                };
                
            case 'line':
                return {
                    id: this.generateId(),
                    type: 'line',
                    points: [position, position],
                    style: { ...tool.style }
                };
                
            default:
                return null;
        }
    }
    
    updateElement(element, startPos, currentPos) {
        switch (element.type) {
            case 'rectangle':
            case 'ellipse':
                element.size.width = Math.abs(currentPos.x - startPos.x);
                element.size.height = Math.abs(currentPos.y - startPos.y);
                element.position.x = Math.min(startPos.x, currentPos.x);
                element.position.y = Math.min(startPos.y, currentPos.y);
                break;
                
            case 'line':
                element.points[1] = { ...currentPos };
                break;
        }
    }
    
    generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }
}
```

## 3.6 完整事件系统集成示例

将所有事件处理组件整合到一个完整的交互式绘图应用中。

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>事件交互系统演示</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #container {
            display: flex;
            height: 100vh;
        }
        
        #toolbar {
            width: 200px;
            background: #f5f5f5;
            padding: 20px;
            border-right: 1px solid #ddd;
        }
        
        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            cursor: crosshair;
        }
        
        .tool-button {
            display: block;
            width: 100%;
            padding: 10px;
            margin-bottom: 5px;
            background: white;
            border: 1px solid #ccc;
            cursor: pointer;
        }
        
        .tool-button.active {
            background: #007acc;
            color: white;
        }
        
        .shortcut-hint {
            font-size: 12px;
            color: #666;
            margin-top: 20px;
        }
        
        .status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: #333;
            color: white;
            padding: 5px 10px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="toolbar">
            <h3>工具箱</h3>
            <button class="tool-button active" data-tool="select">选择工具 (V)</button>
            <button class="tool-button" data-tool="rectangle">矩形 (R)</button>
            <button class="tool-button" data-tool="ellipse">椭圆 (O)</button>
            <button class="tool-button" data-tool="line">直线 (L)</button>
            <button class="tool-button" data-tool="pen">画笔 (P)</button>
            <button class="tool-button" data-tool="text">文本 (T)</button>
            
            <div class="shortcut-hint">
                <h4>快捷键</h4>
                <p>Ctrl+Z: 撤销</p>
                <p>Ctrl+Y: 重做</p>
                <p>Delete: 删除选中</p>
                <p>Ctrl+C: 复制</p>
                <p>Ctrl+V: 粘贴</p>
                <p>Space: 拖拽画布</p>
                <p>Ctrl+滚轮: 缩放</p>
            </div>
        </div>
        
        <div id="canvas-container">
            <canvas id="main-canvas"></canvas>
            <div class="status-bar">
                <span id="status-text">准备就绪</span>
                <span style="float: right;">
                    缩放: <span id="zoom-level">100%</span> | 
                    位置: <span id="cursor-position">0, 0</span>
                </span>
            </div>
        </div>
    </div>

    <script>
        // 在这里插入前面定义的所有类...
        
        // 主应用类
        class DrawingApp {
            constructor() {
                this.canvas = document.getElementById('main-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.container = document.getElementById('canvas-container');
                
                this.elements = [];
                this.selectedElements = [];
                this.currentTool = { type: 'select' };
                this.viewport = {
                    offset: { x: 0, y: 0 },
                    scale: 1
                };
                
                this.setupCanvas();
                this.initializeEventSystem();
                this.setupUI();
                this.render();
            }
            
            setupCanvas() {
                const updateCanvasSize = () => {
                    const rect = this.container.getBoundingClientRect();
                    const dpr = window.devicePixelRatio || 1;
                    
                    this.canvas.width = rect.width * dpr;
                    this.canvas.height = rect.height * dpr;
                    this.canvas.style.width = rect.width + 'px';
                    this.canvas.style.height = rect.height + 'px';
                    
                    this.ctx.scale(dpr, dpr);
                    this.render();
                };
                
                updateCanvasSize();
                window.addEventListener('resize', updateCanvasSize);
            }
            
            initializeEventSystem() {
                // 初始化坐标系统
                this.coordinateSystem = new CoordinateSystem(this.canvas);
                this.coordinateSystem.setView(
                    this.viewport.offset.x, 
                    this.viewport.offset.y, 
                    this.viewport.scale
                );
                
                // 初始化指针事件处理
                this.pointerHandler = new UnifiedPointerHandler(this.canvas);
                
                // 初始化手势识别
                this.gestureRecognizer = new GestureRecognizer(this.pointerHandler);
                
                // 初始化快捷键系统
                this.shortcutManager = new ShortcutManager();
                this.contextualShortcuts = new ContextualShortcuts(this.shortcutManager);
                
                // 初始化拖拽系统
                this.dragManager = new DragManager(this.pointerHandler);
                
                this.setupEventHandlers();
            }
            
            setupEventHandlers() {
                // 设置手势事件监听
                this.gestureRecognizer.addEventListener('panmove', (data) => {
                    if (data.pointer.modifiers.space || this.currentTool.type === 'pan') {
                        this.viewport.offset.x += data.delta.x;
                        this.viewport.offset.y += data.delta.y;
                        this.coordinateSystem.setView(
                            this.viewport.offset.x,
                            this.viewport.offset.y,
                            this.viewport.scale
                        );
                        this.render();
                        this.updateStatus('平移画布');
                    }
                });
                
                this.gestureRecognizer.addEventListener('pinchmove', (data) => {
                    const newScale = Math.max(0.1, Math.min(10, this.viewport.scale * data.scale));
                    this.coordinateSystem.zoomToPoint(
                        data.center.x, 
                        data.center.y, 
                        data.scale
                    );
                    this.viewport.scale = newScale;
                    this.render();
                    this.updateStatus(`缩放: ${Math.round(newScale * 100)}%`);
                });
                
                // 鼠标位置更新
                this.pointerHandler.addEventListener('pointermove', (pointer) => {
                    document.getElementById('cursor-position').textContent = 
                        `${Math.round(pointer.position.x)}, ${Math.round(pointer.position.y)}`;
                });
                
                // 滚轮缩放
                this.canvas.addEventListener('wheel', (event) => {
                    event.preventDefault();
                    
                    if (event.ctrlKey) {
                        const scaleFactor = event.deltaY > 0 ? 0.9 : 1.1;
                        this.coordinateSystem.zoomToPoint(
                            event.clientX,
                            event.clientY,
                            scaleFactor
                        );
                        this.viewport.scale = this.coordinateSystem.scale;
                        document.getElementById('zoom-level').textContent = 
                            Math.round(this.viewport.scale * 100) + '%';
                        this.render();
                    }
                });
            }
            
            setupUI() {
                // 工具按钮事件
                document.querySelectorAll('.tool-button').forEach(button => {
                    button.addEventListener('click', () => {
                        document.querySelector('.tool-button.active').classList.remove('active');
                        button.classList.add('active');
                        this.selectTool(button.dataset.tool);
                    });
                });
                
                // 绑定快捷键到工具选择
                this.contextualShortcuts.selectTool = (tool) => {
                    document.querySelector(`[data-tool="${tool}"]`).click();
                };
            }
            
            selectTool(toolType) {
                this.currentTool = { type: toolType };
                this.updateStatus(`工具: ${toolType}`);
                
                // 更新鼠标光标
                switch (toolType) {
                    case 'select':
                        this.canvas.style.cursor = 'default';
                        break;
                    case 'pen':
                        this.canvas.style.cursor = 'crosshair';
                        break;
                    default:
                        this.canvas.style.cursor = 'crosshair';
                }
            }
            
            render() {
                // 清除画布
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // 应用变换
                this.ctx.save();
                this.ctx.translate(this.viewport.offset.x, this.viewport.offset.y);
                this.ctx.scale(this.viewport.scale, this.viewport.scale);
                
                // 绘制网格
                this.drawGrid();
                
                // 绘制元素
                this.elements.forEach(element => {
                    this.drawElement(element);
                });
                
                // 绘制选择框
                this.drawSelection();
                
                this.ctx.restore();
            }
            
            drawGrid() {
                const gridSize = 20;
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 1 / this.viewport.scale;
                
                const bounds = this.getVisibleBounds();
                
                for (let x = Math.floor(bounds.left / gridSize) * gridSize; x <= bounds.right; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, bounds.top);
                    this.ctx.lineTo(x, bounds.bottom);
                    this.ctx.stroke();
                }
                
                for (let y = Math.floor(bounds.top / gridSize) * gridSize; y <= bounds.bottom; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(bounds.left, y);
                    this.ctx.lineTo(bounds.right, y);
                    this.ctx.stroke();
                }
            }
            
            drawElement(element) {
                this.ctx.save();
                
                switch (element.type) {
                    case 'rectangle':
                        this.ctx.fillStyle = element.style.fill || 'transparent';
                        this.ctx.strokeStyle = element.style.stroke || '#000';
                        this.ctx.lineWidth = element.style.strokeWidth || 1;
                        
                        if (element.style.fill) {
                            this.ctx.fillRect(
                                element.position.x, 
                                element.position.y,
                                element.size.width, 
                                element.size.height
                            );
                        }
                        
                        this.ctx.strokeRect(
                            element.position.x, 
                            element.position.y,
                            element.size.width, 
                            element.size.height
                        );
                        break;
                        
                    case 'ellipse':
                        this.ctx.fillStyle = element.style.fill || 'transparent';
                        this.ctx.strokeStyle = element.style.stroke || '#000';
                        this.ctx.lineWidth = element.style.strokeWidth || 1;
                        
                        this.ctx.beginPath();
                        this.ctx.ellipse(
                            element.position.x + element.size.width / 2,
                            element.position.y + element.size.height / 2,
                            element.size.width / 2,
                            element.size.height / 2,
                            0, 0, 2 * Math.PI
                        );
                        
                        if (element.style.fill) {
                            this.ctx.fill();
                        }
                        this.ctx.stroke();
                        break;
                        
                    case 'line':
                        this.ctx.strokeStyle = element.style.stroke || '#000';
                        this.ctx.lineWidth = element.style.strokeWidth || 1;
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(element.points[0].x, element.points[0].y);
                        this.ctx.lineTo(element.points[1].x, element.points[1].y);
                        this.ctx.stroke();
                        break;
                }
                
                this.ctx.restore();
            }
            
            drawSelection() {
                if (this.selectedElements.length > 0) {
                    this.ctx.strokeStyle = '#007acc';
                    this.ctx.lineWidth = 2 / this.viewport.scale;
                    this.ctx.setLineDash([5 / this.viewport.scale, 5 / this.viewport.scale]);
                    
                    this.selectedElements.forEach(element => {
                        const bounds = this.getElementBounds(element);
                        this.ctx.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);
                    });
                    
                    this.ctx.setLineDash([]);
                }
            }
            
            getElementBounds(element) {
                switch (element.type) {
                    case 'rectangle':
                    case 'ellipse':
                        return {
                            x: element.position.x,
                            y: element.position.y,
                            width: element.size.width,
                            height: element.size.height
                        };
                        
                    case 'line':
                        const minX = Math.min(element.points[0].x, element.points[1].x);
                        const maxX = Math.max(element.points[0].x, element.points[1].x);
                        const minY = Math.min(element.points[0].y, element.points[1].y);
                        const maxY = Math.max(element.points[0].y, element.points[1].y);
                        
                        return {
                            x: minX,
                            y: minY,
                            width: maxX - minX,
                            height: maxY - minY
                        };
                        
                    default:
                        return { x: 0, y: 0, width: 0, height: 0 };
                }
            }
            
            getVisibleBounds() {
                const rect = this.canvas.getBoundingClientRect();
                const topLeft = this.coordinateSystem.canvasToScene(0, 0);
                const bottomRight = this.coordinateSystem.canvasToScene(rect.width, rect.height);
                
                return {
                    left: topLeft.x,
                    top: topLeft.y,
                    right: bottomRight.x,
                    bottom: bottomRight.y
                };
            }
            
            updateStatus(message) {
                document.getElementById('status-text').textContent = message;
                setTimeout(() => {
                    document.getElementById('status-text').textContent = '准备就绪';
                }, 2000);
            }
        }
        
        // 启动应用
        window.addEventListener('DOMContentLoaded', () => {
            new DrawingApp();
        });
    </script>
</body>
</html>
```

## 总结

本章详细介绍了事件交互与用户输入系统的构建，包括：

1. **Web事件系统基础** - 了解浏览器事件模型和事件对象属性
2. **坐标系统转换** - 处理多种坐标系之间的精确转换
3. **统一事件处理** - 使用Pointer Events API统一处理不同输入设备
4. **手势识别** - 实现平移、缩放、旋转等手势操作
5. **键盘快捷键** - 构建灵活的快捷键系统
6. **拖拽系统** - 实现各种拖拽行为的统一管理

这套事件系统为构建复杂的交互式绘图应用提供了坚实的基础，具有良好的扩展性和可维护性。在下一章中，我们将学习如何构建状态管理系统来协调这些交互操作。